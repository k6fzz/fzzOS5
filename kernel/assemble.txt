
./bin/kernel.elf:     file format elf64-x86-64


Disassembly of section .text:

ffffffff80000000 <gdt_load>:
ffffffff80000000:	0f 01 17             	lgdt   (%rdi)
ffffffff80000003:	55                   	push   %rbp
ffffffff80000004:	48 89 e5             	mov    %rsp,%rbp
ffffffff80000007:	6a 10                	pushq  $0x10
ffffffff80000009:	55                   	push   %rbp
ffffffff8000000a:	9c                   	pushfq 
ffffffff8000000b:	6a 08                	pushq  $0x8
ffffffff8000000d:	68 14 00 00 80       	pushq  $0xffffffff80000014
ffffffff80000012:	48 cf                	iretq  

ffffffff80000014 <gdt_load.trampoline>:
ffffffff80000014:	5d                   	pop    %rbp
ffffffff80000015:	66 b8 10 00          	mov    $0x10,%ax
ffffffff80000019:	8e d8                	mov    %eax,%ds
ffffffff8000001b:	8e c0                	mov    %eax,%es
ffffffff8000001d:	8e e0                	mov    %eax,%fs
ffffffff8000001f:	8e e8                	mov    %eax,%gs
ffffffff80000021:	8e d0                	mov    %eax,%ss
ffffffff80000023:	66 b8 50 00          	mov    $0x50,%ax
ffffffff80000027:	0f 00 d8             	ltr    %ax
ffffffff8000002a:	c3                   	retq   

ffffffff8000002b <gdt_load.end>:
ffffffff8000002b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80000030 <read_cr2>:
ffffffff80000030:	0f 20 d0             	mov    %cr2,%rax
ffffffff80000033:	c3                   	retq   

ffffffff80000034 <_interrupt_common>:
ffffffff80000034:	fc                   	cld    
ffffffff80000035:	50                   	push   %rax
ffffffff80000036:	53                   	push   %rbx
ffffffff80000037:	51                   	push   %rcx
ffffffff80000038:	52                   	push   %rdx
ffffffff80000039:	56                   	push   %rsi
ffffffff8000003a:	57                   	push   %rdi
ffffffff8000003b:	55                   	push   %rbp
ffffffff8000003c:	41 50                	push   %r8
ffffffff8000003e:	41 51                	push   %r9
ffffffff80000040:	41 52                	push   %r10
ffffffff80000042:	41 53                	push   %r11
ffffffff80000044:	41 54                	push   %r12
ffffffff80000046:	41 55                	push   %r13
ffffffff80000048:	41 56                	push   %r14
ffffffff8000004a:	41 57                	push   %r15
ffffffff8000004c:	48 89 e7             	mov    %rsp,%rdi
ffffffff8000004f:	e8 3c 15 00 00       	callq  ffffffff80001590 <interrupt_handler>
ffffffff80000054:	48 89 c4             	mov    %rax,%rsp
ffffffff80000057:	41 5f                	pop    %r15
ffffffff80000059:	41 5e                	pop    %r14
ffffffff8000005b:	41 5d                	pop    %r13
ffffffff8000005d:	41 5c                	pop    %r12
ffffffff8000005f:	41 5b                	pop    %r11
ffffffff80000061:	41 5a                	pop    %r10
ffffffff80000063:	41 59                	pop    %r9
ffffffff80000065:	41 58                	pop    %r8
ffffffff80000067:	5d                   	pop    %rbp
ffffffff80000068:	5f                   	pop    %rdi
ffffffff80000069:	5e                   	pop    %rsi
ffffffff8000006a:	5a                   	pop    %rdx
ffffffff8000006b:	59                   	pop    %rcx
ffffffff8000006c:	5b                   	pop    %rbx
ffffffff8000006d:	58                   	pop    %rax
ffffffff8000006e:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80000072:	48 cf                	iretq  

ffffffff80000074 <_interrupt0>:
ffffffff80000074:	6a 00                	pushq  $0x0
ffffffff80000076:	6a 00                	pushq  $0x0
ffffffff80000078:	eb ba                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff8000007a <_interrupt1>:
ffffffff8000007a:	6a 00                	pushq  $0x0
ffffffff8000007c:	6a 01                	pushq  $0x1
ffffffff8000007e:	eb b4                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff80000080 <_interrupt2>:
ffffffff80000080:	6a 00                	pushq  $0x0
ffffffff80000082:	6a 02                	pushq  $0x2
ffffffff80000084:	eb ae                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff80000086 <_interrupt3>:
ffffffff80000086:	6a 00                	pushq  $0x0
ffffffff80000088:	6a 03                	pushq  $0x3
ffffffff8000008a:	eb a8                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff8000008c <_interrupt4>:
ffffffff8000008c:	6a 00                	pushq  $0x0
ffffffff8000008e:	6a 04                	pushq  $0x4
ffffffff80000090:	eb a2                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff80000092 <_interrupt5>:
ffffffff80000092:	6a 00                	pushq  $0x0
ffffffff80000094:	6a 05                	pushq  $0x5
ffffffff80000096:	eb 9c                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff80000098 <_interrupt6>:
ffffffff80000098:	6a 00                	pushq  $0x0
ffffffff8000009a:	6a 06                	pushq  $0x6
ffffffff8000009c:	eb 96                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff8000009e <_interrupt7>:
ffffffff8000009e:	6a 00                	pushq  $0x0
ffffffff800000a0:	6a 07                	pushq  $0x7
ffffffff800000a2:	eb 90                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff800000a4 <_interrupt8>:
ffffffff800000a4:	6a 08                	pushq  $0x8
ffffffff800000a6:	eb 8c                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff800000a8 <_interrupt9>:
ffffffff800000a8:	6a 00                	pushq  $0x0
ffffffff800000aa:	6a 09                	pushq  $0x9
ffffffff800000ac:	eb 86                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff800000ae <_interrupt10>:
ffffffff800000ae:	6a 0a                	pushq  $0xa
ffffffff800000b0:	eb 82                	jmp    ffffffff80000034 <_interrupt_common>

ffffffff800000b2 <_interrupt11>:
ffffffff800000b2:	6a 0b                	pushq  $0xb
ffffffff800000b4:	e9 7b ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800000b9 <_interrupt12>:
ffffffff800000b9:	6a 0c                	pushq  $0xc
ffffffff800000bb:	e9 74 ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800000c0 <_interrupt13>:
ffffffff800000c0:	6a 0d                	pushq  $0xd
ffffffff800000c2:	e9 6d ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800000c7 <_interrupt14>:
ffffffff800000c7:	6a 0e                	pushq  $0xe
ffffffff800000c9:	e9 66 ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800000ce <_interrupt15>:
ffffffff800000ce:	6a 00                	pushq  $0x0
ffffffff800000d0:	6a 0f                	pushq  $0xf
ffffffff800000d2:	e9 5d ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800000d7 <_interrupt16>:
ffffffff800000d7:	6a 00                	pushq  $0x0
ffffffff800000d9:	6a 10                	pushq  $0x10
ffffffff800000db:	e9 54 ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800000e0 <_interrupt17>:
ffffffff800000e0:	6a 11                	pushq  $0x11
ffffffff800000e2:	e9 4d ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800000e7 <_interrupt18>:
ffffffff800000e7:	6a 00                	pushq  $0x0
ffffffff800000e9:	6a 12                	pushq  $0x12
ffffffff800000eb:	e9 44 ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800000f0 <_interrupt19>:
ffffffff800000f0:	6a 00                	pushq  $0x0
ffffffff800000f2:	6a 13                	pushq  $0x13
ffffffff800000f4:	e9 3b ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800000f9 <_interrupt20>:
ffffffff800000f9:	6a 00                	pushq  $0x0
ffffffff800000fb:	6a 14                	pushq  $0x14
ffffffff800000fd:	e9 32 ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000102 <_interrupt21>:
ffffffff80000102:	6a 00                	pushq  $0x0
ffffffff80000104:	6a 15                	pushq  $0x15
ffffffff80000106:	e9 29 ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff8000010b <_interrupt22>:
ffffffff8000010b:	6a 00                	pushq  $0x0
ffffffff8000010d:	6a 16                	pushq  $0x16
ffffffff8000010f:	e9 20 ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000114 <_interrupt23>:
ffffffff80000114:	6a 00                	pushq  $0x0
ffffffff80000116:	6a 17                	pushq  $0x17
ffffffff80000118:	e9 17 ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff8000011d <_interrupt24>:
ffffffff8000011d:	6a 00                	pushq  $0x0
ffffffff8000011f:	6a 18                	pushq  $0x18
ffffffff80000121:	e9 0e ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000126 <_interrupt25>:
ffffffff80000126:	6a 00                	pushq  $0x0
ffffffff80000128:	6a 19                	pushq  $0x19
ffffffff8000012a:	e9 05 ff ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff8000012f <_interrupt26>:
ffffffff8000012f:	6a 00                	pushq  $0x0
ffffffff80000131:	6a 1a                	pushq  $0x1a
ffffffff80000133:	e9 fc fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000138 <_interrupt27>:
ffffffff80000138:	6a 00                	pushq  $0x0
ffffffff8000013a:	6a 1b                	pushq  $0x1b
ffffffff8000013c:	e9 f3 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000141 <_interrupt28>:
ffffffff80000141:	6a 00                	pushq  $0x0
ffffffff80000143:	6a 1c                	pushq  $0x1c
ffffffff80000145:	e9 ea fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff8000014a <_interrupt29>:
ffffffff8000014a:	6a 00                	pushq  $0x0
ffffffff8000014c:	6a 1d                	pushq  $0x1d
ffffffff8000014e:	e9 e1 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000153 <_interrupt30>:
ffffffff80000153:	6a 1e                	pushq  $0x1e
ffffffff80000155:	e9 da fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff8000015a <_interrupt31>:
ffffffff8000015a:	6a 00                	pushq  $0x0
ffffffff8000015c:	6a 1f                	pushq  $0x1f
ffffffff8000015e:	e9 d1 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000163 <_interrupt32>:
ffffffff80000163:	6a 00                	pushq  $0x0
ffffffff80000165:	6a 20                	pushq  $0x20
ffffffff80000167:	e9 c8 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff8000016c <_interrupt33>:
ffffffff8000016c:	6a 00                	pushq  $0x0
ffffffff8000016e:	6a 21                	pushq  $0x21
ffffffff80000170:	e9 bf fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000175 <_interrupt34>:
ffffffff80000175:	6a 00                	pushq  $0x0
ffffffff80000177:	6a 22                	pushq  $0x22
ffffffff80000179:	e9 b6 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff8000017e <_interrupt35>:
ffffffff8000017e:	6a 00                	pushq  $0x0
ffffffff80000180:	6a 23                	pushq  $0x23
ffffffff80000182:	e9 ad fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000187 <_interrupt36>:
ffffffff80000187:	6a 00                	pushq  $0x0
ffffffff80000189:	6a 24                	pushq  $0x24
ffffffff8000018b:	e9 a4 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000190 <_interrupt37>:
ffffffff80000190:	6a 00                	pushq  $0x0
ffffffff80000192:	6a 25                	pushq  $0x25
ffffffff80000194:	e9 9b fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000199 <_interrupt38>:
ffffffff80000199:	6a 00                	pushq  $0x0
ffffffff8000019b:	6a 26                	pushq  $0x26
ffffffff8000019d:	e9 92 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001a2 <_interrupt39>:
ffffffff800001a2:	6a 00                	pushq  $0x0
ffffffff800001a4:	6a 27                	pushq  $0x27
ffffffff800001a6:	e9 89 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001ab <_interrupt40>:
ffffffff800001ab:	6a 00                	pushq  $0x0
ffffffff800001ad:	6a 28                	pushq  $0x28
ffffffff800001af:	e9 80 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001b4 <_interrupt41>:
ffffffff800001b4:	6a 00                	pushq  $0x0
ffffffff800001b6:	6a 29                	pushq  $0x29
ffffffff800001b8:	e9 77 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001bd <_interrupt42>:
ffffffff800001bd:	6a 00                	pushq  $0x0
ffffffff800001bf:	6a 2a                	pushq  $0x2a
ffffffff800001c1:	e9 6e fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001c6 <_interrupt43>:
ffffffff800001c6:	6a 00                	pushq  $0x0
ffffffff800001c8:	6a 2b                	pushq  $0x2b
ffffffff800001ca:	e9 65 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001cf <_interrupt44>:
ffffffff800001cf:	6a 00                	pushq  $0x0
ffffffff800001d1:	6a 2c                	pushq  $0x2c
ffffffff800001d3:	e9 5c fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001d8 <_interrupt45>:
ffffffff800001d8:	6a 00                	pushq  $0x0
ffffffff800001da:	6a 2d                	pushq  $0x2d
ffffffff800001dc:	e9 53 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001e1 <_interrupt46>:
ffffffff800001e1:	6a 00                	pushq  $0x0
ffffffff800001e3:	6a 2e                	pushq  $0x2e
ffffffff800001e5:	e9 4a fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001ea <_interrupt47>:
ffffffff800001ea:	6a 00                	pushq  $0x0
ffffffff800001ec:	6a 2f                	pushq  $0x2f
ffffffff800001ee:	e9 41 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001f3 <_interrupt127>:
ffffffff800001f3:	6a 00                	pushq  $0x0
ffffffff800001f5:	6a 7f                	pushq  $0x7f
ffffffff800001f7:	e9 38 fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff800001fc <_interrupt128>:
ffffffff800001fc:	6a 00                	pushq  $0x0
ffffffff800001fe:	68 80 00 00 00       	pushq  $0x80
ffffffff80000203:	e9 2c fe ff ff       	jmpq   ffffffff80000034 <_interrupt_common>

ffffffff80000208 <isr_stub_table>:
ffffffff80000208:	74 00 00 80 ff ff ff ff 7a 00 00 80 ff ff ff ff     t.......z.......
ffffffff80000218:	80 00 00 80 ff ff ff ff 86 00 00 80 ff ff ff ff     ................
ffffffff80000228:	8c 00 00 80 ff ff ff ff 92 00 00 80 ff ff ff ff     ................
ffffffff80000238:	98 00 00 80 ff ff ff ff 9e 00 00 80 ff ff ff ff     ................
ffffffff80000248:	a4 00 00 80 ff ff ff ff a8 00 00 80 ff ff ff ff     ................
ffffffff80000258:	ae 00 00 80 ff ff ff ff b2 00 00 80 ff ff ff ff     ................
ffffffff80000268:	b9 00 00 80 ff ff ff ff c0 00 00 80 ff ff ff ff     ................
ffffffff80000278:	c7 00 00 80 ff ff ff ff ce 00 00 80 ff ff ff ff     ................
ffffffff80000288:	d7 00 00 80 ff ff ff ff e0 00 00 80 ff ff ff ff     ................
ffffffff80000298:	e7 00 00 80 ff ff ff ff f0 00 00 80 ff ff ff ff     ................
ffffffff800002a8:	f9 00 00 80 ff ff ff ff 02 01 00 80 ff ff ff ff     ................
ffffffff800002b8:	0b 01 00 80 ff ff ff ff 14 01 00 80 ff ff ff ff     ................
ffffffff800002c8:	1d 01 00 80 ff ff ff ff 26 01 00 80 ff ff ff ff     ........&.......
ffffffff800002d8:	2f 01 00 80 ff ff ff ff 38 01 00 80 ff ff ff ff     /.......8.......
ffffffff800002e8:	41 01 00 80 ff ff ff ff 4a 01 00 80 ff ff ff ff     A.......J.......
ffffffff800002f8:	53 01 00 80 ff ff ff ff 5a 01 00 80 ff ff ff ff     S.......Z.......
ffffffff80000308:	63 01 00 80 ff ff ff ff 6c 01 00 80 ff ff ff ff     c.......l.......
ffffffff80000318:	75 01 00 80 ff ff ff ff 7e 01 00 80 ff ff ff ff     u.......~.......
ffffffff80000328:	87 01 00 80 ff ff ff ff 90 01 00 80 ff ff ff ff     ................
ffffffff80000338:	99 01 00 80 ff ff ff ff a2 01 00 80 ff ff ff ff     ................
ffffffff80000348:	ab 01 00 80 ff ff ff ff b4 01 00 80 ff ff ff ff     ................
ffffffff80000358:	bd 01 00 80 ff ff ff ff c6 01 00 80 ff ff ff ff     ................
ffffffff80000368:	cf 01 00 80 ff ff ff ff d8 01 00 80 ff ff ff ff     ................
ffffffff80000378:	e1 01 00 80 ff ff ff ff ea 01 00 80 ff ff ff ff     ................
ffffffff80000388:	f3 01 00 80 ff ff ff ff fc 01 00 80 ff ff ff ff     ................

ffffffff80000398 <idt_load>:
ffffffff80000398:	0f 01 1f             	lidt   (%rdi)
ffffffff8000039b:	fb                   	sti    
ffffffff8000039c:	c3                   	retq   

ffffffff8000039d <int_test>:
ffffffff8000039d:	cd 7f                	int    $0x7f
ffffffff8000039f:	c3                   	retq   

ffffffff800003a0 <vmm_read_cr3>:
ffffffff800003a0:	0f 20 d8             	mov    %cr3,%rax
ffffffff800003a3:	c3                   	retq   

ffffffff800003a4 <vmm_write_cr3>:
ffffffff800003a4:	0f 22 df             	mov    %rdi,%cr3
ffffffff800003a7:	c3                   	retq   

ffffffff800003a8 <vmm_flush_tlb>:
ffffffff800003a8:	0f 01 3f             	invlpg (%rdi)
ffffffff800003ab:	c3                   	retq   

ffffffff800003ac <vmm_read_efer>:
ffffffff800003ac:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff800003b1:	0f 32                	rdmsr  
ffffffff800003b3:	c3                   	retq   

ffffffff800003b4 <vmm_enable_nxe>:
ffffffff800003b4:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff800003b9:	0f 32                	rdmsr  
ffffffff800003bb:	0d 00 08 00 00       	or     $0x800,%eax
ffffffff800003c0:	0f 30                	wrmsr  

ffffffff800003c2 <vmm_enable_nxe.end>:
ffffffff800003c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800003c9:	00 00 00 
ffffffff800003cc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff800003d0 <switch_to_task>:
ffffffff800003d0:	50                   	push   %rax
ffffffff800003d1:	53                   	push   %rbx
ffffffff800003d2:	51                   	push   %rcx
ffffffff800003d3:	52                   	push   %rdx
ffffffff800003d4:	56                   	push   %rsi
ffffffff800003d5:	57                   	push   %rdi
ffffffff800003d6:	55                   	push   %rbp
ffffffff800003d7:	41 50                	push   %r8
ffffffff800003d9:	41 51                	push   %r9
ffffffff800003db:	41 52                	push   %r10
ffffffff800003dd:	41 53                	push   %r11
ffffffff800003df:	41 54                	push   %r12
ffffffff800003e1:	41 55                	push   %r13
ffffffff800003e3:	41 56                	push   %r14
ffffffff800003e5:	41 57                	push   %r15

ffffffff800003e7 <switch_to_task.end>:
ffffffff800003e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800003ee:	00 00 

ffffffff800003f0 <to_usermode>:
ffffffff800003f0:	48 89 f9             	mov    %rdi,%rcx
ffffffff800003f3:	48 89 f4             	mov    %rsi,%rsp
ffffffff800003f6:	41 bb 02 32 00 00    	mov    $0x3202,%r11d
ffffffff800003fc:	48 0f 07             	rex.W sysret 

ffffffff800003ff <read_msr>:
ffffffff800003ff:	48 89 f9             	mov    %rdi,%rcx
ffffffff80000402:	0f 32                	rdmsr  
ffffffff80000404:	c3                   	retq   

ffffffff80000405 <enable_syscall>:
ffffffff80000405:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff8000040a:	0f 32                	rdmsr  
ffffffff8000040c:	83 c8 01             	or     $0x1,%eax
ffffffff8000040f:	0f 30                	wrmsr  
ffffffff80000411:	b9 81 00 00 c0       	mov    $0xc0000081,%ecx
ffffffff80000416:	0f 32                	rdmsr  
ffffffff80000418:	48 89 fa             	mov    %rdi,%rdx
ffffffff8000041b:	0f 30                	wrmsr  
ffffffff8000041d:	b9 82 00 00 c0       	mov    $0xc0000082,%ecx
ffffffff80000422:	0f 32                	rdmsr  
ffffffff80000424:	48 89 f0             	mov    %rsi,%rax
ffffffff80000427:	48 89 f2             	mov    %rsi,%rdx
ffffffff8000042a:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8000042e:	0f 30                	wrmsr  
ffffffff80000430:	c3                   	retq   

ffffffff80000431 <enable_sce>:
ffffffff80000431:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff80000436:	0f 32                	rdmsr  
ffffffff80000438:	83 c8 01             	or     $0x1,%eax
ffffffff8000043b:	0f 30                	wrmsr  
ffffffff8000043d:	b9 81 00 00 c0       	mov    $0xc0000081,%ecx
ffffffff80000442:	0f 32                	rdmsr  
ffffffff80000444:	ba 08 00 18 00       	mov    $0x180008,%edx
ffffffff80000449:	0f 30                	wrmsr  
ffffffff8000044b:	c3                   	retq   

ffffffff8000044c <__syscall_handler>:
ffffffff8000044c:	53                   	push   %rbx
ffffffff8000044d:	54                   	push   %rsp
ffffffff8000044e:	55                   	push   %rbp
ffffffff8000044f:	41 54                	push   %r12
ffffffff80000451:	41 55                	push   %r13
ffffffff80000453:	41 56                	push   %r14
ffffffff80000455:	41 57                	push   %r15
ffffffff80000457:	51                   	push   %rcx
ffffffff80000458:	e8 63 2d 00 00       	callq  ffffffff800031c0 <syscall_handler>
ffffffff8000045d:	59                   	pop    %rcx
ffffffff8000045e:	41 5f                	pop    %r15
ffffffff80000460:	41 5e                	pop    %r14
ffffffff80000462:	41 5d                	pop    %r13
ffffffff80000464:	41 5c                	pop    %r12
ffffffff80000466:	5d                   	pop    %rbp
ffffffff80000467:	5c                   	pop    %rsp
ffffffff80000468:	5b                   	pop    %rbx
ffffffff80000469:	48 0f 07             	rex.W sysret 

ffffffff8000046c <__syscall_handler.end>:
ffffffff8000046c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000470 <_elf_start>:

void _elf_start()
{
    for(;;)
    {
        asm("hlt");
ffffffff80000470:	f4                   	hlt    
    for(;;)
ffffffff80000471:	eb fd                	jmp    ffffffff80000470 <_elf_start>
ffffffff80000473:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000047a:	00 00 00 
ffffffff8000047d:	0f 1f 00             	nopl   (%rax)

ffffffff80000480 <_limine_start>:
};

void _limine_start()
{

    boot_info.type = LIMINE;
ffffffff80000480:	c7 05 36 8c 00 00 01 	movl   $0x1,0x8c36(%rip)        # ffffffff800090c0 <boot_info>
ffffffff80000487:	00 00 00 
ffffffff8000048a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    //boot_info.limine_terminal = terminal_request.response->terminals[0];


    for(;;)
    {
        asm("hlt");
ffffffff80000490:	f4                   	hlt    
    for(;;)
ffffffff80000491:	eb fd                	jmp    ffffffff80000490 <_limine_start+0x10>
ffffffff80000493:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000049a:	00 00 00 
ffffffff8000049d:	0f 1f 00             	nopl   (%rax)

ffffffff800004a0 <_start>:
    .tags = (uintptr_t)&framebuffer_hdr_tag
};


static void *stivale2_get_tag(struct stivale2_struct *stivale2_struct, uint64_t id) {
    struct stivale2_tag *current_tag = (void *)stivale2_struct->tags;
ffffffff800004a0:	48 8b 97 80 00 00 00 	mov    0x80(%rdi),%rdx
}

//Entry point. We're going to make sure the bootloader did what it's supposed to do, then pass off to the kernel.
void _start(struct stivale2_struct* stivale2_struct)
{
    boot_info.type = STIVALE2;
ffffffff800004a7:	c7 05 0f 8c 00 00 00 	movl   $0x0,0x8c0f(%rip)        # ffffffff800090c0 <boot_info>
ffffffff800004ae:	00 00 00 
        if (current_tag == NULL) {
ffffffff800004b1:	48 85 d2             	test   %rdx,%rdx
ffffffff800004b4:	0f 84 6e 01 00 00    	je     ffffffff80000628 <_start+0x188>
        if (current_tag->identifier == id) {
ffffffff800004ba:	48 b9 74 09 3b 23 c3 	movabs $0xc2b3f4c3233b0974,%rcx
ffffffff800004c1:	f4 b3 c2 
    struct stivale2_tag *current_tag = (void *)stivale2_struct->tags;
ffffffff800004c4:	48 89 d0             	mov    %rdx,%rax
ffffffff800004c7:	eb 10                	jmp    ffffffff800004d9 <_start+0x39>
ffffffff800004c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        current_tag = (void *)current_tag->next;
ffffffff800004d0:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (current_tag == NULL) {
ffffffff800004d4:	48 85 c0             	test   %rax,%rax
ffffffff800004d7:	74 05                	je     ffffffff800004de <_start+0x3e>
        if (current_tag->identifier == id) {
ffffffff800004d9:	48 39 08             	cmp    %rcx,(%rax)
ffffffff800004dc:	75 f2                	jne    ffffffff800004d0 <_start+0x30>
ffffffff800004de:	48 b9 fa 08 04 95 d2 	movabs $0x506461d2950408fa,%rcx
ffffffff800004e5:	61 64 50 
ffffffff800004e8:	48 89 d0             	mov    %rdx,%rax
ffffffff800004eb:	eb 10                	jmp    ffffffff800004fd <_start+0x5d>
ffffffff800004ed:	0f 1f 00             	nopl   (%rax)
        current_tag = (void *)current_tag->next;
ffffffff800004f0:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (current_tag == NULL) {
ffffffff800004f4:	48 85 c0             	test   %rax,%rax
ffffffff800004f7:	0f 84 2b 01 00 00    	je     ffffffff80000628 <_start+0x188>
        if (current_tag->identifier == id) {
ffffffff800004fd:	48 39 08             	cmp    %rcx,(%rax)
ffffffff80000500:	75 ee                	jne    ffffffff800004f0 <_start+0x50>
   
    //Grab the Framebuffer

    

    boot_info.tag_framebuffer = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_FRAMEBUFFER_ID);
ffffffff80000502:	48 89 05 d7 8b 00 00 	mov    %rax,0x8bd7(%rip)        # ffffffff800090e0 <boot_info+0x20>
ffffffff80000509:	48 89 d0             	mov    %rdx,%rax
        if (current_tag->identifier == id) {
ffffffff8000050c:	48 b9 07 de 12 86 9e 	movabs $0x2187f79e8612de07,%rcx
ffffffff80000513:	f7 87 21 
ffffffff80000516:	eb 15                	jmp    ffffffff8000052d <_start+0x8d>
ffffffff80000518:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000051f:	00 
        current_tag = (void *)current_tag->next;
ffffffff80000520:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (current_tag == NULL) {
ffffffff80000524:	48 85 c0             	test   %rax,%rax
ffffffff80000527:	0f 84 0e 01 00 00    	je     ffffffff8000063b <_start+0x19b>
        if (current_tag->identifier == id) {
ffffffff8000052d:	48 39 08             	cmp    %rcx,(%rax)
ffffffff80000530:	75 ee                	jne    ffffffff80000520 <_start+0x80>
        for( ;; ) 
            asm("hlt");
    }
 
    //Memory Map
    boot_info.tag_memmap = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MEMMAP_ID);
ffffffff80000532:	48 89 05 9f 8b 00 00 	mov    %rax,0x8b9f(%rip)        # ffffffff800090d8 <boot_info+0x18>
ffffffff80000539:	48 89 d0             	mov    %rdx,%rax
        if (current_tag->identifier == id) {
ffffffff8000053c:	48 b9 f0 8a 2a 4a 87 	movabs $0x60d78874a2a8af0,%rcx
ffffffff80000543:	78 0d 06 
ffffffff80000546:	eb 15                	jmp    ffffffff8000055d <_start+0xbd>
ffffffff80000548:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000054f:	00 
        current_tag = (void *)current_tag->next;
ffffffff80000550:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (current_tag == NULL) {
ffffffff80000554:	48 85 c0             	test   %rax,%rax
ffffffff80000557:	0f 84 ee 00 00 00    	je     ffffffff8000064b <_start+0x1ab>
        if (current_tag->identifier == id) {
ffffffff8000055d:	48 39 08             	cmp    %rcx,(%rax)
ffffffff80000560:	75 ee                	jne    ffffffff80000550 <_start+0xb0>
        for( ;; ) 
            asm("hlt");
    }
 
    //Kernel Base Address
    boot_info.tag_kernel_base_address = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_KERNEL_BASE_ADDRESS_ID);
ffffffff80000562:	48 89 05 5f 8b 00 00 	mov    %rax,0x8b5f(%rip)        # ffffffff800090c8 <boot_info+0x8>
ffffffff80000569:	48 89 d0             	mov    %rdx,%rax
        if (current_tag->identifier == id) {
ffffffff8000056c:	48 b9 78 5e 37 0a 93 	movabs $0x9e1786930a375e78,%rcx
ffffffff80000573:	86 17 9e 
ffffffff80000576:	eb 15                	jmp    ffffffff8000058d <_start+0xed>
ffffffff80000578:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000057f:	00 
        current_tag = (void *)current_tag->next;
ffffffff80000580:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (current_tag == NULL) {
ffffffff80000584:	48 85 c0             	test   %rax,%rax
ffffffff80000587:	0f 84 ce 00 00 00    	je     ffffffff8000065b <_start+0x1bb>
        if (current_tag->identifier == id) {
ffffffff8000058d:	48 39 08             	cmp    %rcx,(%rax)
ffffffff80000590:	75 ee                	jne    ffffffff80000580 <_start+0xe0>
        for( ;; ) 
            asm("hlt");
    }

    //ACPI RSDP
    boot_info.tag_rsdp = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_RSDP_ID);
ffffffff80000592:	48 89 05 57 8b 00 00 	mov    %rax,0x8b57(%rip)        # ffffffff800090f0 <boot_info+0x30>
ffffffff80000599:	48 89 d0             	mov    %rdx,%rax
        if (current_tag->identifier == id) {
ffffffff8000059c:	48 b9 8f b5 8c b1 7d 	movabs $0xb0ed257db18cb58f,%rcx
ffffffff800005a3:	25 ed b0 
ffffffff800005a6:	eb 15                	jmp    ffffffff800005bd <_start+0x11d>
ffffffff800005a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff800005af:	00 
        current_tag = (void *)current_tag->next;
ffffffff800005b0:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (current_tag == NULL) {
ffffffff800005b4:	48 85 c0             	test   %rax,%rax
ffffffff800005b7:	0f 84 ae 00 00 00    	je     ffffffff8000066b <_start+0x1cb>
        if (current_tag->identifier == id) {
ffffffff800005bd:	48 39 08             	cmp    %rcx,(%rax)
ffffffff800005c0:	75 ee                	jne    ffffffff800005b0 <_start+0x110>
        for( ;; )
            asm("hlt");
    }
    
    //Higher Half Direct Map
    boot_info.tag_hhdm = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_HHDM_ID);
ffffffff800005c2:	48 89 05 37 8b 00 00 	mov    %rax,0x8b37(%rip)        # ffffffff80009100 <boot_info+0x40>
ffffffff800005c9:	48 89 d0             	mov    %rdx,%rax
        if (current_tag->identifier == id) {
ffffffff800005cc:	48 b9 bd b6 47 40 a6 	movabs $0x5df266a64047b6bd,%rcx
ffffffff800005d3:	66 f2 5d 
ffffffff800005d6:	eb 15                	jmp    ffffffff800005ed <_start+0x14d>
ffffffff800005d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff800005df:	00 
        current_tag = (void *)current_tag->next;
ffffffff800005e0:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (current_tag == NULL) {
ffffffff800005e4:	48 85 c0             	test   %rax,%rax
ffffffff800005e7:	0f 84 9e 00 00 00    	je     ffffffff8000068b <_start+0x1eb>
        if (current_tag->identifier == id) {
ffffffff800005ed:	48 39 08             	cmp    %rcx,(%rax)
ffffffff800005f0:	75 ee                	jne    ffffffff800005e0 <_start+0x140>
        for( ;; )
            asm("hlt");
    }

    //Protected Memory Ranges
    boot_info.tag_pmrs = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_PMRS_ID);
ffffffff800005f2:	48 89 05 0f 8b 00 00 	mov    %rax,0x8b0f(%rip)        # ffffffff80009108 <boot_info+0x48>
        if (current_tag->identifier == id) {
ffffffff800005f9:	48 b8 ce 04 de aa 66 	movabs $0x4b6fe466aade04ce,%rax
ffffffff80000600:	e4 6f 4b 
ffffffff80000603:	eb 0c                	jmp    ffffffff80000611 <_start+0x171>
ffffffff80000605:	0f 1f 00             	nopl   (%rax)
        current_tag = (void *)current_tag->next;
ffffffff80000608:	48 8b 52 08          	mov    0x8(%rdx),%rdx
        if (current_tag == NULL) {
ffffffff8000060c:	48 85 d2             	test   %rdx,%rdx
ffffffff8000060f:	74 6a                	je     ffffffff8000067b <_start+0x1db>
        if (current_tag->identifier == id) {
ffffffff80000611:	48 39 02             	cmp    %rax,(%rdx)
ffffffff80000614:	75 f2                	jne    ffffffff80000608 <_start+0x168>
{
ffffffff80000616:	55                   	push   %rbp
    {
        for( ;; )
            asm("hlt");
    }

    kernel();
ffffffff80000617:	31 c0                	xor    %eax,%eax
    boot_info.tag_modules = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MODULES_ID);
ffffffff80000619:	48 89 15 c8 8a 00 00 	mov    %rdx,0x8ac8(%rip)        # ffffffff800090e8 <boot_info+0x28>
{
ffffffff80000620:	48 89 e5             	mov    %rsp,%rbp
    kernel();
ffffffff80000623:	e8 78 12 00 00       	callq  ffffffff800018a0 <kernel>
    boot_info.tag_framebuffer = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_FRAMEBUFFER_ID);
ffffffff80000628:	45 31 c9             	xor    %r9d,%r9d
ffffffff8000062b:	4c 89 0d ae 8a 00 00 	mov    %r9,0x8aae(%rip)        # ffffffff800090e0 <boot_info+0x20>
ffffffff80000632:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            asm("hlt");
ffffffff80000638:	f4                   	hlt    
        for( ;; ) 
ffffffff80000639:	eb fd                	jmp    ffffffff80000638 <_start+0x198>
    boot_info.tag_memmap = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MEMMAP_ID);
ffffffff8000063b:	31 c0                	xor    %eax,%eax
ffffffff8000063d:	48 89 05 94 8a 00 00 	mov    %rax,0x8a94(%rip)        # ffffffff800090d8 <boot_info+0x18>
    if (boot_info.tag_memmap == NULL)
ffffffff80000644:	0f 1f 40 00          	nopl   0x0(%rax)
            asm("hlt");
ffffffff80000648:	f4                   	hlt    
        for( ;; ) 
ffffffff80000649:	eb fd                	jmp    ffffffff80000648 <_start+0x1a8>
    boot_info.tag_kernel_base_address = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_KERNEL_BASE_ADDRESS_ID);
ffffffff8000064b:	31 d2                	xor    %edx,%edx
ffffffff8000064d:	48 89 15 74 8a 00 00 	mov    %rdx,0x8a74(%rip)        # ffffffff800090c8 <boot_info+0x8>
    if (boot_info.tag_kernel_base_address == NULL)
ffffffff80000654:	0f 1f 40 00          	nopl   0x0(%rax)
            asm("hlt");
ffffffff80000658:	f4                   	hlt    
        for( ;; ) 
ffffffff80000659:	eb fd                	jmp    ffffffff80000658 <_start+0x1b8>
    boot_info.tag_rsdp = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_RSDP_ID);
ffffffff8000065b:	31 c9                	xor    %ecx,%ecx
ffffffff8000065d:	48 89 0d 8c 8a 00 00 	mov    %rcx,0x8a8c(%rip)        # ffffffff800090f0 <boot_info+0x30>
    if (boot_info.tag_rsdp == NULL)
ffffffff80000664:	0f 1f 40 00          	nopl   0x0(%rax)
            asm("hlt");
ffffffff80000668:	f4                   	hlt    
        for( ;; )
ffffffff80000669:	eb fd                	jmp    ffffffff80000668 <_start+0x1c8>
    boot_info.tag_hhdm = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_HHDM_ID);
ffffffff8000066b:	31 f6                	xor    %esi,%esi
ffffffff8000066d:	48 89 35 8c 8a 00 00 	mov    %rsi,0x8a8c(%rip)        # ffffffff80009100 <boot_info+0x40>
    if (boot_info.tag_hhdm == NULL)
ffffffff80000674:	0f 1f 40 00          	nopl   0x0(%rax)
            asm("hlt");
ffffffff80000678:	f4                   	hlt    
        for( ;; )
ffffffff80000679:	eb fd                	jmp    ffffffff80000678 <_start+0x1d8>
    boot_info.tag_modules = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MODULES_ID);
ffffffff8000067b:	45 31 c0             	xor    %r8d,%r8d
ffffffff8000067e:	4c 89 05 63 8a 00 00 	mov    %r8,0x8a63(%rip)        # ffffffff800090e8 <boot_info+0x28>
    if (boot_info.tag_modules == NULL)
ffffffff80000685:	0f 1f 00             	nopl   (%rax)
            asm("hlt");
ffffffff80000688:	f4                   	hlt    
        for( ;; )
ffffffff80000689:	eb fd                	jmp    ffffffff80000688 <_start+0x1e8>
    boot_info.tag_pmrs = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_PMRS_ID);
ffffffff8000068b:	31 ff                	xor    %edi,%edi
ffffffff8000068d:	48 89 3d 74 8a 00 00 	mov    %rdi,0x8a74(%rip)        # ffffffff80009108 <boot_info+0x48>
    if (boot_info.tag_pmrs == NULL)
ffffffff80000694:	0f 1f 40 00          	nopl   0x0(%rax)
            asm("hlt");
ffffffff80000698:	f4                   	hlt    
        for( ;; )
ffffffff80000699:	eb fd                	jmp    ffffffff80000698 <_start+0x1f8>
ffffffff8000069b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff800006a0 <acpi_init>:
    struct RSDP20Descriptor* rsdp;

}ACPI_Info;

void acpi_init()
{
ffffffff800006a0:	55                   	push   %rbp
ffffffff800006a1:	48 89 e5             	mov    %rsp,%rbp
ffffffff800006a4:	48 83 ec 10          	sub    $0x10,%rsp
    ACPI_Info.rsdp = (struct RSDP20Descriptor*)boot_info.tag_rsdp->rsdp;
ffffffff800006a8:	48 8b 05 41 8a 00 00 	mov    0x8a41(%rip),%rax        # ffffffff800090f0 <boot_info+0x30>
ffffffff800006af:	48 8b 50 10          	mov    0x10(%rax),%rdx
    
    uint8_t test[8] = {'R', 'S', 'P', ' ', 'P', 'T', 'R', ' '};
ffffffff800006b3:	48 b8 52 53 50 20 50 	movabs $0x2052545020505352,%rax
ffffffff800006ba:	54 52 20 
ffffffff800006bd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff800006c1:	31 c0                	xor    %eax,%eax
    ACPI_Info.rsdp = (struct RSDP20Descriptor*)boot_info.tag_rsdp->rsdp;
ffffffff800006c3:	48 89 15 56 9a 00 00 	mov    %rdx,0x9a56(%rip)        # ffffffff8000a120 <ACPI_Info>
    for(uint32_t i = 0; i < 8; i++)
    {
        if(test[i] == ACPI_Info.rsdp->header.signature[i]) 
ffffffff800006ca:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
ffffffff800006ce:	38 4c 05 f8          	cmp    %cl,-0x8(%rbp,%rax,1)
ffffffff800006d2:	74 0c                	je     ffffffff800006e0 <acpi_init+0x40>
            return;
    }

    printf("Valid RSDP Header. Revision %d\n", ACPI_Info.rsdp->header.revision);
    
ffffffff800006d4:	c9                   	leaveq 
ffffffff800006d5:	c3                   	retq   
ffffffff800006d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800006dd:	00 00 00 
    for(uint32_t i = 0; i < 8; i++)
ffffffff800006e0:	48 83 c0 01          	add    $0x1,%rax
ffffffff800006e4:	48 83 f8 08          	cmp    $0x8,%rax
ffffffff800006e8:	75 e0                	jne    ffffffff800006ca <acpi_init+0x2a>
    printf("Valid RSDP Header. Revision %d\n", ACPI_Info.rsdp->header.revision);
ffffffff800006ea:	0f b6 72 0f          	movzbl 0xf(%rdx),%esi
ffffffff800006ee:	48 c7 c7 80 55 00 80 	mov    $0xffffffff80005580,%rdi
ffffffff800006f5:	31 c0                	xor    %eax,%eax
ffffffff800006f7:	c9                   	leaveq 
    printf("Valid RSDP Header. Revision %d\n", ACPI_Info.rsdp->header.revision);
ffffffff800006f8:	e9 c3 3b 00 00       	jmpq   ffffffff800042c0 <printf_>
ffffffff800006fd:	0f 1f 00             	nopl   (%rax)

ffffffff80000700 <console_input>:
    //write the output buffer to screen
}

void console_input(KEY_INFO_t key)
{
    con_input_buffer.index++;
ffffffff80000700:	48 8b 05 79 9a 00 00 	mov    0x9a79(%rip),%rax        # ffffffff8000a180 <con_input_buffer+0x10>
ffffffff80000707:	66 c1 ef 08          	shr    $0x8,%di
ffffffff8000070b:	48 8d 50 01          	lea    0x1(%rax),%rdx
ffffffff8000070f:	48 89 15 6a 9a 00 00 	mov    %rdx,0x9a6a(%rip)        # ffffffff8000a180 <con_input_buffer+0x10>
    con_input_buffer.buffer[con_input_buffer.index] = key.ascii;
ffffffff80000716:	48 8b 15 53 9a 00 00 	mov    0x9a53(%rip),%rdx        # ffffffff8000a170 <con_input_buffer>
ffffffff8000071d:	40 88 7c 02 01       	mov    %dil,0x1(%rdx,%rax,1)
    

    con_output_buffer.buffer[con_output_buffer.index] = key.ascii;
ffffffff80000722:	48 8b 05 87 9b 00 00 	mov    0x9b87(%rip),%rax        # ffffffff8000a2b0 <con_output_buffer+0x10>
ffffffff80000729:	48 8b 15 70 9b 00 00 	mov    0x9b70(%rip),%rdx        # ffffffff8000a2a0 <con_output_buffer>
ffffffff80000730:	40 88 3c 02          	mov    %dil,(%rdx,%rax,1)
    con_output_buffer.index++;
ffffffff80000734:	48 8b 05 75 9b 00 00 	mov    0x9b75(%rip),%rax        # ffffffff8000a2b0 <con_output_buffer+0x10>
ffffffff8000073b:	48 8d 50 01          	lea    0x1(%rax),%rdx
ffffffff8000073f:	48 89 15 6a 9b 00 00 	mov    %rdx,0x9b6a(%rip)        # ffffffff8000a2b0 <con_output_buffer+0x10>
    con_output_buffer.buffer[con_output_buffer.index] = 0x00;
ffffffff80000746:	48 8b 15 53 9b 00 00 	mov    0x9b53(%rip),%rdx        # ffffffff8000a2a0 <con_output_buffer>
ffffffff8000074d:	c6 44 02 01 00       	movb   $0x0,0x1(%rdx,%rax,1)
    return;
ffffffff80000752:	c3                   	retq   
ffffffff80000753:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000075a:	00 00 00 00 
ffffffff8000075e:	66 90                	xchg   %ax,%ax

ffffffff80000760 <putchar>:
    switch(c)
ffffffff80000760:	40 80 ff 0a          	cmp    $0xa,%dil
ffffffff80000764:	0f 84 36 01 00 00    	je     ffffffff800008a0 <putchar+0x140>
ffffffff8000076a:	40 80 ff 0d          	cmp    $0xd,%dil
ffffffff8000076e:	0f 84 fc 00 00 00    	je     ffffffff80000870 <putchar+0x110>
ffffffff80000774:	40 80 ff 09          	cmp    $0x9,%dil
ffffffff80000778:	0f 84 cd 00 00 00    	je     ffffffff8000084b <putchar+0xeb>
{
ffffffff8000077e:	55                   	push   %rbp
ffffffff8000077f:	48 89 e5             	mov    %rsp,%rbp
ffffffff80000782:	41 57                	push   %r15
ffffffff80000784:	41 56                	push   %r14
ffffffff80000786:	41 55                	push   %r13
    switch(c)
ffffffff80000788:	44 0f b6 ef          	movzbl %dil,%r13d
{
ffffffff8000078c:	41 54                	push   %r12
    uint8_t* glyph = (uint8_t*)&_binary_zapl16_psf_start + 4 + (c * PSF1_FONT_HEIGHT);
ffffffff8000078e:	41 c1 e5 04          	shl    $0x4,%r13d
{
ffffffff80000792:	53                   	push   %rbx
    uint8_t* glyph = (uint8_t*)&_binary_zapl16_psf_start + 4 + (c * PSF1_FONT_HEIGHT);
ffffffff80000793:	41 83 c5 04          	add    $0x4,%r13d
ffffffff80000797:	4d 63 ed             	movslq %r13d,%r13
ffffffff8000079a:	49 8d 8d a0 7b 00 80 	lea    -0x7fff8460(%r13),%rcx
{
ffffffff800007a1:	48 83 ec 28          	sub    $0x28,%rsp
    console_drawchar(c, console_info.cursor_x, console_info.cursor_y, console_info.foreground_color, console_info.background_color);
ffffffff800007a5:	8b 05 9d 99 00 00    	mov    0x999d(%rip),%eax        # ffffffff8000a148 <console_info+0x8>
ffffffff800007ab:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
ffffffff800007af:	0f b7 1d 9c 99 00 00 	movzwl 0x999c(%rip),%ebx        # ffffffff8000a152 <console_info+0x12>
ffffffff800007b6:	44 8b 35 8f 99 00 00 	mov    0x998f(%rip),%r14d        # ffffffff8000a14c <console_info+0xc>
ffffffff800007bd:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff800007c0:	0f b7 05 89 99 00 00 	movzwl 0x9989(%rip),%eax        # ffffffff8000a150 <console_info+0x10>
ffffffff800007c7:	8d 4b 10             	lea    0x10(%rbx),%ecx
ffffffff800007ca:	89 45 c8             	mov    %eax,-0x38(%rbp)
    for (uint32_t i = 0; i < 16; i++)
ffffffff800007cd:	44 8d 60 08          	lea    0x8(%rax),%r12d
ffffffff800007d1:	89 4d bc             	mov    %ecx,-0x44(%rbp)
ffffffff800007d4:	0f 1f 40 00          	nopl   0x0(%rax)
        row = glyph[i];
ffffffff800007d8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff800007dc:	44 8b 7d c8          	mov    -0x38(%rbp),%r15d
ffffffff800007e0:	44 0f b6 28          	movzbl (%rax),%r13d
        for (uint32_t j = 0; j < 8; j++)
ffffffff800007e4:	eb 23                	jmp    ffffffff80000809 <putchar+0xa9>
ffffffff800007e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800007ed:	00 00 00 
                fb_putpixel(x+j, y+i, background);
ffffffff800007f0:	44 89 ff             	mov    %r15d,%edi
ffffffff800007f3:	44 89 f2             	mov    %r14d,%edx
ffffffff800007f6:	89 de                	mov    %ebx,%esi
        for (uint32_t j = 0; j < 8; j++)
ffffffff800007f8:	41 83 c7 01          	add    $0x1,%r15d
                fb_putpixel(x+j, y+i, background);
ffffffff800007fc:	e8 4f 04 00 00       	callq  ffffffff80000c50 <fb_putpixel>
            row = row << 1;
ffffffff80000801:	45 01 ed             	add    %r13d,%r13d
        for (uint32_t j = 0; j < 8; j++)
ffffffff80000804:	45 39 fc             	cmp    %r15d,%r12d
ffffffff80000807:	74 1e                	je     ffffffff80000827 <putchar+0xc7>
            if(row & 0x80)
ffffffff80000809:	45 84 ed             	test   %r13b,%r13b
ffffffff8000080c:	79 e2                	jns    ffffffff800007f0 <putchar+0x90>
                fb_putpixel(x+j, y+i, foreground);
ffffffff8000080e:	8b 55 cc             	mov    -0x34(%rbp),%edx
ffffffff80000811:	44 89 ff             	mov    %r15d,%edi
ffffffff80000814:	89 de                	mov    %ebx,%esi
        for (uint32_t j = 0; j < 8; j++)
ffffffff80000816:	41 83 c7 01          	add    $0x1,%r15d
            row = row << 1;
ffffffff8000081a:	45 01 ed             	add    %r13d,%r13d
                fb_putpixel(x+j, y+i, foreground);
ffffffff8000081d:	e8 2e 04 00 00       	callq  ffffffff80000c50 <fb_putpixel>
        for (uint32_t j = 0; j < 8; j++)
ffffffff80000822:	45 39 fc             	cmp    %r15d,%r12d
ffffffff80000825:	75 e2                	jne    ffffffff80000809 <putchar+0xa9>
    for (uint32_t i = 0; i < 16; i++)
ffffffff80000827:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
ffffffff8000082c:	83 c3 01             	add    $0x1,%ebx
ffffffff8000082f:	39 5d bc             	cmp    %ebx,-0x44(%rbp)
ffffffff80000832:	75 a4                	jne    ffffffff800007d8 <putchar+0x78>
    console_info.cursor_x += 8;
ffffffff80000834:	66 83 05 14 99 00 00 	addw   $0x8,0x9914(%rip)        # ffffffff8000a150 <console_info+0x10>
ffffffff8000083b:	08 
}
ffffffff8000083c:	48 83 c4 28          	add    $0x28,%rsp
ffffffff80000840:	5b                   	pop    %rbx
ffffffff80000841:	41 5c                	pop    %r12
ffffffff80000843:	41 5d                	pop    %r13
ffffffff80000845:	41 5e                	pop    %r14
ffffffff80000847:	41 5f                	pop    %r15
ffffffff80000849:	5d                   	pop    %rbp
ffffffff8000084a:	c3                   	retq   
            if((console_info.cursor_x += (PSF1_FONT_WIDTH * 4)) < fb_info.width)
ffffffff8000084b:	0f b7 05 fe 98 00 00 	movzwl 0x98fe(%rip),%eax        # ffffffff8000a150 <console_info+0x10>
ffffffff80000852:	0f b7 15 71 aa 00 00 	movzwl 0xaa71(%rip),%edx        # ffffffff8000b2ca <fb_info+0xa>
ffffffff80000859:	8d 48 20             	lea    0x20(%rax),%ecx
ffffffff8000085c:	66 39 d1             	cmp    %dx,%cx
ffffffff8000085f:	0f 83 46 01 00 00    	jae    ffffffff800009ab <putchar+0x24b>
                console_info.cursor_x += (PSF1_FONT_WIDTH * 4);
ffffffff80000865:	83 c0 40             	add    $0x40,%eax
ffffffff80000868:	66 89 05 e1 98 00 00 	mov    %ax,0x98e1(%rip)        # ffffffff8000a150 <console_info+0x10>
                return;
ffffffff8000086f:	c3                   	retq   
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80000870:	0f b7 05 db 98 00 00 	movzwl 0x98db(%rip),%eax        # ffffffff8000a152 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80000877:	0f b7 15 4a aa 00 00 	movzwl 0xaa4a(%rip),%edx        # ffffffff8000b2c8 <fb_info+0x8>
    console_info.cursor_x = 0;
ffffffff8000087e:	31 f6                	xor    %esi,%esi
ffffffff80000880:	66 89 35 c9 98 00 00 	mov    %si,0x98c9(%rip)        # ffffffff8000a150 <console_info+0x10>
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80000887:	83 c0 10             	add    $0x10,%eax
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff8000088a:	8d 4a f1             	lea    -0xf(%rdx),%ecx
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff8000088d:	66 89 05 be 98 00 00 	mov    %ax,0x98be(%rip)        # ffffffff8000a152 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80000894:	0f b7 c0             	movzwl %ax,%eax
ffffffff80000897:	39 c1                	cmp    %eax,%ecx
ffffffff80000899:	0f 8e 9c 00 00 00    	jle    ffffffff8000093b <putchar+0x1db>
ffffffff8000089f:	c3                   	retq   
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800008a0:	0f b7 05 ab 98 00 00 	movzwl 0x98ab(%rip),%eax        # ffffffff8000a152 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800008a7:	0f b7 15 1a aa 00 00 	movzwl 0xaa1a(%rip),%edx        # ffffffff8000b2c8 <fb_info+0x8>
    console_info.cursor_x = 0;
ffffffff800008ae:	31 ff                	xor    %edi,%edi
ffffffff800008b0:	66 89 3d 99 98 00 00 	mov    %di,0x9899(%rip)        # ffffffff8000a150 <console_info+0x10>
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800008b7:	83 c0 10             	add    $0x10,%eax
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800008ba:	8d 4a f1             	lea    -0xf(%rdx),%ecx
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800008bd:	66 89 05 8e 98 00 00 	mov    %ax,0x988e(%rip)        # ffffffff8000a152 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800008c4:	0f b7 c0             	movzwl %ax,%eax
ffffffff800008c7:	39 c1                	cmp    %eax,%ecx
ffffffff800008c9:	7f d4                	jg     ffffffff8000089f <putchar+0x13f>
    start_index = fb_info.width * 16 * 4;
ffffffff800008cb:	0f b7 05 f8 a9 00 00 	movzwl 0xa9f8(%rip),%eax        # ffffffff8000b2ca <fb_info+0xa>
    uint32_t* base = (uint32_t*)fb_info.base;
ffffffff800008d2:	4c 8b 0d e7 a9 00 00 	mov    0xa9e7(%rip),%r9        # ffffffff8000b2c0 <fb_info>
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff800008d9:	0f af d0             	imul   %eax,%edx
    start_index = fb_info.width * 16 * 4;
ffffffff800008dc:	89 c1                	mov    %eax,%ecx
ffffffff800008de:	c1 e1 06             	shl    $0x6,%ecx
ffffffff800008e1:	48 63 c9             	movslq %ecx,%rcx
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff800008e4:	4c 63 d2             	movslq %edx,%r10
    end_index = fb_info.height * fb_info.width - 1;
ffffffff800008e7:	83 ea 01             	sub    $0x1,%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff800008ea:	4d 89 d0             	mov    %r10,%r8
    end_index = fb_info.height * fb_info.width - 1;
ffffffff800008ed:	48 63 f2             	movslq %edx,%rsi
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff800008f0:	49 29 c8             	sub    %rcx,%r8
ffffffff800008f3:	74 1a                	je     ffffffff8000090f <putchar+0x1af>
ffffffff800008f5:	4b 8d 3c 81          	lea    (%r9,%r8,4),%rdi
ffffffff800008f9:	48 c1 e1 02          	shl    $0x2,%rcx
ffffffff800008fd:	4c 89 c8             	mov    %r9,%rax
        base[i] = base[start_index + i];
ffffffff80000900:	8b 14 08             	mov    (%rax,%rcx,1),%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80000903:	48 83 c0 04          	add    $0x4,%rax
        base[i] = base[start_index + i];
ffffffff80000907:	89 50 fc             	mov    %edx,-0x4(%rax)
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff8000090a:	48 39 f8             	cmp    %rdi,%rax
ffffffff8000090d:	75 f1                	jne    ffffffff80000900 <putchar+0x1a0>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff8000090f:	49 8d 40 01          	lea    0x1(%r8),%rax
ffffffff80000913:	48 39 f0             	cmp    %rsi,%rax
ffffffff80000916:	0f 83 2e 01 00 00    	jae    ffffffff80000a4a <putchar+0x2ea>
ffffffff8000091c:	49 8d 04 81          	lea    (%r9,%rax,4),%rax
ffffffff80000920:	4b 8d 4c 91 fc       	lea    -0x4(%r9,%r10,4),%rcx
ffffffff80000925:	0f 1f 00             	nopl   (%rax)
        base[i] = console_info.background_color;
ffffffff80000928:	8b 15 1e 98 00 00    	mov    0x981e(%rip),%edx        # ffffffff8000a14c <console_info+0xc>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff8000092e:	48 83 c0 04          	add    $0x4,%rax
        base[i] = console_info.background_color;
ffffffff80000932:	89 50 fc             	mov    %edx,-0x4(%rax)
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80000935:	48 39 c8             	cmp    %rcx,%rax
ffffffff80000938:	75 ee                	jne    ffffffff80000928 <putchar+0x1c8>
ffffffff8000093a:	c3                   	retq   
    start_index = fb_info.width * 16 * 4;
ffffffff8000093b:	0f b7 05 88 a9 00 00 	movzwl 0xa988(%rip),%eax        # ffffffff8000b2ca <fb_info+0xa>
    uint32_t* base = (uint32_t*)fb_info.base;
ffffffff80000942:	4c 8b 0d 77 a9 00 00 	mov    0xa977(%rip),%r9        # ffffffff8000b2c0 <fb_info>
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff80000949:	0f af d0             	imul   %eax,%edx
    start_index = fb_info.width * 16 * 4;
ffffffff8000094c:	89 c1                	mov    %eax,%ecx
ffffffff8000094e:	c1 e1 06             	shl    $0x6,%ecx
ffffffff80000951:	48 63 c9             	movslq %ecx,%rcx
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff80000954:	4c 63 d2             	movslq %edx,%r10
    end_index = fb_info.height * fb_info.width - 1;
ffffffff80000957:	83 ea 01             	sub    $0x1,%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff8000095a:	4d 89 d0             	mov    %r10,%r8
    end_index = fb_info.height * fb_info.width - 1;
ffffffff8000095d:	48 63 f2             	movslq %edx,%rsi
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80000960:	49 29 c8             	sub    %rcx,%r8
ffffffff80000963:	74 1a                	je     ffffffff8000097f <putchar+0x21f>
ffffffff80000965:	4b 8d 3c 81          	lea    (%r9,%r8,4),%rdi
ffffffff80000969:	48 c1 e1 02          	shl    $0x2,%rcx
ffffffff8000096d:	4c 89 c8             	mov    %r9,%rax
        base[i] = base[start_index + i];
ffffffff80000970:	8b 14 08             	mov    (%rax,%rcx,1),%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80000973:	48 83 c0 04          	add    $0x4,%rax
        base[i] = base[start_index + i];
ffffffff80000977:	89 50 fc             	mov    %edx,-0x4(%rax)
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff8000097a:	48 39 f8             	cmp    %rdi,%rax
ffffffff8000097d:	75 f1                	jne    ffffffff80000970 <putchar+0x210>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff8000097f:	49 8d 40 01          	lea    0x1(%r8),%rax
ffffffff80000983:	48 39 f0             	cmp    %rsi,%rax
ffffffff80000986:	0f 83 bd 00 00 00    	jae    ffffffff80000a49 <putchar+0x2e9>
ffffffff8000098c:	49 8d 04 81          	lea    (%r9,%rax,4),%rax
ffffffff80000990:	4b 8d 4c 91 fc       	lea    -0x4(%r9,%r10,4),%rcx
ffffffff80000995:	0f 1f 00             	nopl   (%rax)
        base[i] = console_info.background_color;
ffffffff80000998:	8b 15 ae 97 00 00    	mov    0x97ae(%rip),%edx        # ffffffff8000a14c <console_info+0xc>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff8000099e:	48 83 c0 04          	add    $0x4,%rax
        base[i] = console_info.background_color;
ffffffff800009a2:	89 50 fc             	mov    %edx,-0x4(%rax)
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff800009a5:	48 39 c8             	cmp    %rcx,%rax
ffffffff800009a8:	75 ee                	jne    ffffffff80000998 <putchar+0x238>
ffffffff800009aa:	c3                   	retq   
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800009ab:	0f b7 05 a0 97 00 00 	movzwl 0x97a0(%rip),%eax        # ffffffff8000a152 <console_info+0x12>
    console_info.cursor_x = 0;
ffffffff800009b2:	31 c9                	xor    %ecx,%ecx
ffffffff800009b4:	66 89 0d 95 97 00 00 	mov    %cx,0x9795(%rip)        # ffffffff8000a150 <console_info+0x10>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800009bb:	0f b7 0d 06 a9 00 00 	movzwl 0xa906(%rip),%ecx        # ffffffff8000b2c8 <fb_info+0x8>
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800009c2:	83 c0 10             	add    $0x10,%eax
ffffffff800009c5:	66 89 05 86 97 00 00 	mov    %ax,0x9786(%rip)        # ffffffff8000a152 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800009cc:	8d 71 f1             	lea    -0xf(%rcx),%esi
ffffffff800009cf:	0f b7 c0             	movzwl %ax,%eax
ffffffff800009d2:	39 c6                	cmp    %eax,%esi
ffffffff800009d4:	7e 0d                	jle    ffffffff800009e3 <putchar+0x283>
                console_info.cursor_x += (PSF1_FONT_WIDTH * 4);
ffffffff800009d6:	b8 20 00 00 00       	mov    $0x20,%eax
ffffffff800009db:	66 89 05 6e 97 00 00 	mov    %ax,0x976e(%rip)        # ffffffff8000a150 <console_info+0x10>
                return;
ffffffff800009e2:	c3                   	retq   
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff800009e3:	0f af ca             	imul   %edx,%ecx
    start_index = fb_info.width * 16 * 4;
ffffffff800009e6:	89 d0                	mov    %edx,%eax
    uint32_t* base = (uint32_t*)fb_info.base;
ffffffff800009e8:	4c 8b 05 d1 a8 00 00 	mov    0xa8d1(%rip),%r8        # ffffffff8000b2c0 <fb_info>
    start_index = fb_info.width * 16 * 4;
ffffffff800009ef:	c1 e0 06             	shl    $0x6,%eax
ffffffff800009f2:	48 98                	cltq   
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff800009f4:	4c 63 d1             	movslq %ecx,%r10
    end_index = fb_info.height * fb_info.width - 1;
ffffffff800009f7:	83 e9 01             	sub    $0x1,%ecx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff800009fa:	4d 89 d1             	mov    %r10,%r9
    end_index = fb_info.height * fb_info.width - 1;
ffffffff800009fd:	48 63 c9             	movslq %ecx,%rcx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80000a00:	49 29 c1             	sub    %rax,%r9
ffffffff80000a03:	74 1e                	je     ffffffff80000a23 <putchar+0x2c3>
ffffffff80000a05:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
ffffffff80000a0c:	00 
ffffffff80000a0d:	4b 8d 3c 88          	lea    (%r8,%r9,4),%rdi
ffffffff80000a11:	4c 89 c0             	mov    %r8,%rax
        base[i] = base[start_index + i];
ffffffff80000a14:	8b 34 02             	mov    (%rdx,%rax,1),%esi
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80000a17:	48 83 c0 04          	add    $0x4,%rax
        base[i] = base[start_index + i];
ffffffff80000a1b:	89 70 fc             	mov    %esi,-0x4(%rax)
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80000a1e:	48 39 f8             	cmp    %rdi,%rax
ffffffff80000a21:	75 f1                	jne    ffffffff80000a14 <putchar+0x2b4>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80000a23:	49 8d 41 01          	lea    0x1(%r9),%rax
ffffffff80000a27:	48 39 c8             	cmp    %rcx,%rax
ffffffff80000a2a:	73 aa                	jae    ffffffff800009d6 <putchar+0x276>
ffffffff80000a2c:	49 8d 04 80          	lea    (%r8,%rax,4),%rax
ffffffff80000a30:	4b 8d 4c 90 fc       	lea    -0x4(%r8,%r10,4),%rcx
        base[i] = console_info.background_color;
ffffffff80000a35:	8b 15 11 97 00 00    	mov    0x9711(%rip),%edx        # ffffffff8000a14c <console_info+0xc>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80000a3b:	48 83 c0 04          	add    $0x4,%rax
        base[i] = console_info.background_color;
ffffffff80000a3f:	89 50 fc             	mov    %edx,-0x4(%rax)
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80000a42:	48 39 c1             	cmp    %rax,%rcx
ffffffff80000a45:	75 ee                	jne    ffffffff80000a35 <putchar+0x2d5>
ffffffff80000a47:	eb 8d                	jmp    ffffffff800009d6 <putchar+0x276>
ffffffff80000a49:	c3                   	retq   
ffffffff80000a4a:	c3                   	retq   
ffffffff80000a4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80000a50 <putstring>:
{
ffffffff80000a50:	55                   	push   %rbp
ffffffff80000a51:	48 89 e5             	mov    %rsp,%rbp
ffffffff80000a54:	53                   	push   %rbx
ffffffff80000a55:	48 89 fb             	mov    %rdi,%rbx
ffffffff80000a58:	48 83 ec 08          	sub    $0x8,%rsp
    while(*str)
ffffffff80000a5c:	0f b6 3f             	movzbl (%rdi),%edi
ffffffff80000a5f:	40 84 ff             	test   %dil,%dil
ffffffff80000a62:	74 16                	je     ffffffff80000a7a <putstring+0x2a>
ffffffff80000a64:	0f 1f 40 00          	nopl   0x0(%rax)
        putchar(*str);
ffffffff80000a68:	e8 f3 fc ff ff       	callq  ffffffff80000760 <putchar>
    while(*str)
ffffffff80000a6d:	0f b6 7b 01          	movzbl 0x1(%rbx),%edi
        str++;
ffffffff80000a71:	48 83 c3 01          	add    $0x1,%rbx
    while(*str)
ffffffff80000a75:	40 84 ff             	test   %dil,%dil
ffffffff80000a78:	75 ee                	jne    ffffffff80000a68 <putstring+0x18>
}
ffffffff80000a7a:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
ffffffff80000a7e:	c9                   	leaveq 
ffffffff80000a7f:	c3                   	retq   

ffffffff80000a80 <console_init>:
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80000a80:	0f b7 05 41 a8 00 00 	movzwl 0xa841(%rip),%eax        # ffffffff8000b2c8 <fb_info+0x8>
    uint64_t index = y * fb_info.width;
ffffffff80000a87:	0f b7 3d 3c a8 00 00 	movzwl 0xa83c(%rip),%edi        # ffffffff8000b2ca <fb_info+0xa>
    console_info.foreground_color = FB_COLOR_WHITE;
ffffffff80000a8e:	48 be ff ff ff ff 00 	movabs $0xff000000ffffffff,%rsi
ffffffff80000a95:	00 00 ff 
    console_info.font = (struct PSF1_FONT*)&_binary_zapl16_psf_start;
ffffffff80000a98:	48 c7 05 b5 96 00 00 	movq   $0xffffffff80007ba0,0x96b5(%rip)        # ffffffff8000a158 <console_info+0x18>
ffffffff80000a9f:	a0 7b 00 80 
    console_info.foreground_color = FB_COLOR_WHITE;
ffffffff80000aa3:	48 89 35 9e 96 00 00 	mov    %rsi,0x969e(%rip)        # ffffffff8000a148 <console_info+0x8>
    console_info.cursor_x = 0;
ffffffff80000aaa:	c7 05 9c 96 00 00 00 	movl   $0x0,0x969c(%rip)        # ffffffff8000a150 <console_info+0x10>
ffffffff80000ab1:	00 00 00 
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80000ab4:	89 c2                	mov    %eax,%edx
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80000ab6:	66 c1 e8 02          	shr    $0x2,%ax
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80000aba:	66 c1 ea 04          	shr    $0x4,%dx
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80000abe:	0f b7 c0             	movzwl %ax,%eax
    con_output_buffer.buffer = console_buffer;
ffffffff80000ac1:	48 c7 05 d4 97 00 00 	movq   $0xffffffff8000a2c0,0x97d4(%rip)        # ffffffff8000a2a0 <con_output_buffer>
ffffffff80000ac8:	c0 a2 00 80 
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80000acc:	0f b7 d2             	movzwl %dx,%edx
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80000acf:	8d 04 40             	lea    (%rax,%rax,2),%eax
    con_output_buffer.buffer_size = sizeof(console_buffer);
ffffffff80000ad2:	48 c7 05 cb 97 00 00 	movq   $0x1000,0x97cb(%rip)        # ffffffff8000a2a8 <con_output_buffer+0x8>
ffffffff80000ad9:	00 10 00 00 
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80000add:	89 15 61 96 00 00    	mov    %edx,0x9661(%rip)        # ffffffff8000a144 <console_info+0x4>
    console_draw_hline(console_info.start_pos, FB_COLOR_YELLOW);
ffffffff80000ae3:	48 63 d0             	movslq %eax,%rdx
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80000ae6:	89 05 54 96 00 00    	mov    %eax,0x9654(%rip)        # ffffffff8000a140 <console_info>
    uint64_t index = y * fb_info.width;
ffffffff80000aec:	48 0f af d7          	imul   %rdi,%rdx
    con_output_buffer.index = 0;
ffffffff80000af0:	48 c7 05 b5 97 00 00 	movq   $0x0,0x97b5(%rip)        # ffffffff8000a2b0 <con_output_buffer+0x10>
ffffffff80000af7:	00 00 00 00 
    con_input_buffer.buffer = cmd_buffer;
ffffffff80000afb:	48 c7 05 6a 96 00 00 	movq   $0xffffffff8000a1a0,0x966a(%rip)        # ffffffff8000a170 <con_input_buffer>
ffffffff80000b02:	a0 a1 00 80 
    con_input_buffer.buffer_size = sizeof(cmd_buffer);
ffffffff80000b06:	48 c7 05 67 96 00 00 	movq   $0x100,0x9667(%rip)        # ffffffff8000a178 <con_input_buffer+0x8>
ffffffff80000b0d:	00 01 00 00 
    for(int i = 0; i < fb_info.width; i++)
ffffffff80000b11:	66 85 ff             	test   %di,%di
ffffffff80000b14:	74 59                	je     ffffffff80000b6f <console_init+0xef>
        *((uint32_t*)fb_info.base + index + i) = color;
ffffffff80000b16:	48 8b 35 a3 a7 00 00 	mov    0xa7a3(%rip),%rsi        # ffffffff8000b2c0 <fb_info>
ffffffff80000b1d:	44 8d 47 ff          	lea    -0x1(%rdi),%r8d
ffffffff80000b21:	48 8d 04 96          	lea    (%rsi,%rdx,4),%rax
ffffffff80000b25:	48 8d 4e 04          	lea    0x4(%rsi),%rcx
ffffffff80000b29:	4c 01 c2             	add    %r8,%rdx
ffffffff80000b2c:	48 8d 14 91          	lea    (%rcx,%rdx,4),%rdx
ffffffff80000b30:	c7 00 00 ff ff ff    	movl   $0xffffff00,(%rax)
    for(int i = 0; i < fb_info.width; i++)
ffffffff80000b36:	48 83 c0 04          	add    $0x4,%rax
ffffffff80000b3a:	48 39 d0             	cmp    %rdx,%rax
ffffffff80000b3d:	75 f1                	jne    ffffffff80000b30 <console_init+0xb0>
    console_draw_hline(console_info.start_pos + 1, FB_COLOR_YELLOW);
ffffffff80000b3f:	8b 05 fb 95 00 00    	mov    0x95fb(%rip),%eax        # ffffffff8000a140 <console_info>
ffffffff80000b45:	8d 50 01             	lea    0x1(%rax),%edx
    uint64_t index = y * fb_info.width;
ffffffff80000b48:	48 0f af d7          	imul   %rdi,%rdx
    for(int i = 0; i < fb_info.width; i++)
ffffffff80000b4c:	48 8d 04 96          	lea    (%rsi,%rdx,4),%rax
ffffffff80000b50:	4c 01 c2             	add    %r8,%rdx
ffffffff80000b53:	48 8d 14 91          	lea    (%rcx,%rdx,4),%rdx
ffffffff80000b57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80000b5e:	00 00 
        *((uint32_t*)fb_info.base + index + i) = color;
ffffffff80000b60:	c7 00 00 ff ff ff    	movl   $0xffffff00,(%rax)
    for(int i = 0; i < fb_info.width; i++)
ffffffff80000b66:	48 83 c0 04          	add    $0x4,%rax
ffffffff80000b6a:	48 39 c2             	cmp    %rax,%rdx
ffffffff80000b6d:	75 f1                	jne    ffffffff80000b60 <console_init+0xe0>
    kbd_set_target(console_input);
ffffffff80000b6f:	48 c7 c7 00 07 00 80 	mov    $0xffffffff80000700,%rdi
ffffffff80000b76:	e9 75 01 00 00       	jmpq   ffffffff80000cf0 <kbd_set_target>
ffffffff80000b7b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80000b80 <console_exec>:
    for(int i = console_info.start_pos + (fb_info.width * 2); i < (fb_info.height * fb_info.width); i++)
ffffffff80000b80:	0f b7 05 43 a7 00 00 	movzwl 0xa743(%rip),%eax        # ffffffff8000b2ca <fb_info+0xa>
ffffffff80000b87:	8b 15 b3 95 00 00    	mov    0x95b3(%rip),%edx        # ffffffff8000a140 <console_info>
ffffffff80000b8d:	8d 0c 42             	lea    (%rdx,%rax,2),%ecx
ffffffff80000b90:	0f b7 15 31 a7 00 00 	movzwl 0xa731(%rip),%edx        # ffffffff8000b2c8 <fb_info+0x8>
ffffffff80000b97:	0f af d0             	imul   %eax,%edx
ffffffff80000b9a:	39 d1                	cmp    %edx,%ecx
ffffffff80000b9c:	7d 2c                	jge    ffffffff80000bca <console_exec+0x4a>
ffffffff80000b9e:	48 63 f9             	movslq %ecx,%rdi
        *((uint32_t*)fb_info.base + i) = console_info.background_color;
ffffffff80000ba1:	48 8b 35 18 a7 00 00 	mov    0xa718(%rip),%rsi        # ffffffff8000b2c0 <fb_info>
ffffffff80000ba8:	29 ca                	sub    %ecx,%edx
ffffffff80000baa:	48 01 fa             	add    %rdi,%rdx
ffffffff80000bad:	48 8d 04 be          	lea    (%rsi,%rdi,4),%rax
ffffffff80000bb1:	48 8d 0c 96          	lea    (%rsi,%rdx,4),%rcx
ffffffff80000bb5:	0f 1f 00             	nopl   (%rax)
ffffffff80000bb8:	8b 15 8e 95 00 00    	mov    0x958e(%rip),%edx        # ffffffff8000a14c <console_info+0xc>
    for(int i = console_info.start_pos + (fb_info.width * 2); i < (fb_info.height * fb_info.width); i++)
ffffffff80000bbe:	48 83 c0 04          	add    $0x4,%rax
        *((uint32_t*)fb_info.base + i) = console_info.background_color;
ffffffff80000bc2:	89 50 fc             	mov    %edx,-0x4(%rax)
    for(int i = console_info.start_pos + (fb_info.width * 2); i < (fb_info.height * fb_info.width); i++)
ffffffff80000bc5:	48 39 c8             	cmp    %rcx,%rax
ffffffff80000bc8:	75 ee                	jne    ffffffff80000bb8 <console_exec+0x38>
}
ffffffff80000bca:	c3                   	retq   
ffffffff80000bcb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80000bd0 <cpu_init>:
#include "cpu.h"

void cpu_init()
{
ffffffff80000bd0:	55                   	push   %rbp
    uint64_t a,b,c,d;
    __cpuid(0,a,b,c,d);
ffffffff80000bd1:	31 c0                	xor    %eax,%eax
{
ffffffff80000bd3:	48 89 e5             	mov    %rsp,%rbp
ffffffff80000bd6:	53                   	push   %rbx
    __cpuid(0,a,b,c,d);
ffffffff80000bd7:	0f a2                	cpuid  
ffffffff80000bd9:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
ffffffff80000bdd:	c9                   	leaveq 
ffffffff80000bde:	c3                   	retq   
ffffffff80000bdf:	90                   	nop

ffffffff80000be0 <fb_init>:

struct fb_info fb_info;

void fb_init()
{
    if(boot_info.type == STIVALE2)
ffffffff80000be0:	8b 05 da 84 00 00    	mov    0x84da(%rip),%eax        # ffffffff800090c0 <boot_info>
ffffffff80000be6:	85 c0                	test   %eax,%eax
ffffffff80000be8:	75 56                	jne    ffffffff80000c40 <fb_init+0x60>
    {
        fb_info.base = boot_info.tag_framebuffer->framebuffer_addr;
ffffffff80000bea:	48 8b 0d ef 84 00 00 	mov    0x84ef(%rip),%rcx        # ffffffff800090e0 <boot_info+0x20>
ffffffff80000bf1:	48 8b 41 10          	mov    0x10(%rcx),%rax
        fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
        fb_info.width = boot_info.tag_framebuffer->framebuffer_width;
ffffffff80000bf5:	44 0f b7 41 18       	movzwl 0x18(%rcx),%r8d
        fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
ffffffff80000bfa:	0f b7 79 1c          	movzwl 0x1c(%rcx),%edi
        fb_info.base = boot_info.tag_framebuffer->framebuffer_addr;
ffffffff80000bfe:	48 89 05 bb a6 00 00 	mov    %rax,0xa6bb(%rip)        # ffffffff8000b2c0 <fb_info>
        fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
ffffffff80000c05:	0f b7 41 1a          	movzwl 0x1a(%rcx),%eax
        fb_info.width = boot_info.tag_framebuffer->framebuffer_width;
ffffffff80000c09:	4c 89 c6             	mov    %r8,%rsi
        fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
ffffffff80000c0c:	49 c1 e0 10          	shl    $0x10,%r8
ffffffff80000c10:	0f b7 49 1e          	movzwl 0x1e(%rcx),%ecx
ffffffff80000c14:	48 c1 e7 20          	shl    $0x20,%rdi
ffffffff80000c18:	48 89 c2             	mov    %rax,%rdx
ffffffff80000c1b:	4c 09 c0             	or     %r8,%rax
        fb_info.pitch = boot_info.tag_framebuffer->framebuffer_pitch;
        fb_info.bpp = boot_info.tag_framebuffer->framebuffer_bpp;
        fb_info.max_pixels = fb_info.height * fb_info.width;
ffffffff80000c1e:	0f af d6             	imul   %esi,%edx
        fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
ffffffff80000c21:	48 c1 e1 30          	shl    $0x30,%rcx
ffffffff80000c25:	48 09 f8             	or     %rdi,%rax
ffffffff80000c28:	48 09 c8             	or     %rcx,%rax
ffffffff80000c2b:	48 89 05 96 a6 00 00 	mov    %rax,0xa696(%rip)        # ffffffff8000b2c8 <fb_info+0x8>
        fb_info.max_pixels = fb_info.height * fb_info.width;
ffffffff80000c32:	89 15 98 a6 00 00    	mov    %edx,0xa698(%rip)        # ffffffff8000b2d0 <fb_info+0x10>
ffffffff80000c38:	c3                   	retq   
ffffffff80000c39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    }
    else if(boot_info.type == LIMINE)
ffffffff80000c40:	83 f8 01             	cmp    $0x1,%eax
ffffffff80000c43:	74 06                	je     ffffffff80000c4b <fb_init+0x6b>
ffffffff80000c45:	0f 1f 00             	nopl   (%rax)
    }
    else
    {
        for(;;)
        {
            asm("hlt");
ffffffff80000c48:	f4                   	hlt    
        for(;;)
ffffffff80000c49:	eb fd                	jmp    ffffffff80000c48 <fb_init+0x68>
    //printf("FB Base: %p", fb_info.base);
    //printf("FB Height: %d  FB Width: %d\n", fb_info.height, fb_info.width);
    //printf("FB BPP: %d   FB Pitch: %d\n", fb_info.bpp, fb_info.pitch);

    //fb_putpixel(100,100,FB_COLOR_WHITE);
}
ffffffff80000c4b:	c3                   	retq   
ffffffff80000c4c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000c50 <fb_putpixel>:

void fb_putpixel(uint32_t x, uint32_t y, enum fb_color col)
{
    uint64_t index = y * (fb_info.pitch / (fb_info.bpp / 8)) + x;
ffffffff80000c50:	0f b7 0d 77 a6 00 00 	movzwl 0xa677(%rip),%ecx        # ffffffff8000b2ce <fb_info+0xe>
ffffffff80000c57:	0f b7 05 6e a6 00 00 	movzwl 0xa66e(%rip),%eax        # ffffffff8000b2cc <fb_info+0xc>
{
ffffffff80000c5e:	41 89 f0             	mov    %esi,%r8d
ffffffff80000c61:	89 d6                	mov    %edx,%esi
    uint64_t index = y * (fb_info.pitch / (fb_info.bpp / 8)) + x;
ffffffff80000c63:	31 d2                	xor    %edx,%edx
ffffffff80000c65:	66 c1 e9 03          	shr    $0x3,%cx
ffffffff80000c69:	66 f7 f1             	div    %cx
ffffffff80000c6c:	0f b7 c0             	movzwl %ax,%eax
ffffffff80000c6f:	41 0f af c0          	imul   %r8d,%eax
ffffffff80000c73:	8d 14 38             	lea    (%rax,%rdi,1),%edx
    //if(index > fb_info.max_pixels) return;
    *((uint32_t*)fb_info.base + index) = col;
ffffffff80000c76:	48 8b 05 43 a6 00 00 	mov    0xa643(%rip),%rax        # ffffffff8000b2c0 <fb_info>
ffffffff80000c7d:	89 34 90             	mov    %esi,(%rax,%rdx,4)
}
ffffffff80000c80:	c3                   	retq   
ffffffff80000c81:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000c88:	00 00 00 00 
ffffffff80000c8c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000c90 <fb_clearscreen>:

void fb_clearscreen(enum fb_color col)
{
    for (uint64_t i = 0; i < (fb_info.height*fb_info.width); i++)
ffffffff80000c90:	0f b7 05 31 a6 00 00 	movzwl 0xa631(%rip),%eax        # ffffffff8000b2c8 <fb_info+0x8>
ffffffff80000c97:	0f b7 15 2c a6 00 00 	movzwl 0xa62c(%rip),%edx        # ffffffff8000b2ca <fb_info+0xa>
ffffffff80000c9e:	0f af c2             	imul   %edx,%eax
ffffffff80000ca1:	48 63 c8             	movslq %eax,%rcx
ffffffff80000ca4:	85 c0                	test   %eax,%eax
ffffffff80000ca6:	74 1f                	je     ffffffff80000cc7 <fb_clearscreen+0x37>
    {
        *((uint32_t*)fb_info.base + i) = col;
ffffffff80000ca8:	48 8b 15 11 a6 00 00 	mov    0xa611(%rip),%rdx        # ffffffff8000b2c0 <fb_info>
    for (uint64_t i = 0; i < (fb_info.height*fb_info.width); i++)
ffffffff80000caf:	31 c0                	xor    %eax,%eax
ffffffff80000cb1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff80000cb8:	48 83 c0 01          	add    $0x1,%rax
        *((uint32_t*)fb_info.base + i) = col;
ffffffff80000cbc:	89 3a                	mov    %edi,(%rdx)
    for (uint64_t i = 0; i < (fb_info.height*fb_info.width); i++)
ffffffff80000cbe:	48 83 c2 04          	add    $0x4,%rdx
ffffffff80000cc2:	48 39 c8             	cmp    %rcx,%rax
ffffffff80000cc5:	75 f1                	jne    ffffffff80000cb8 <fb_clearscreen+0x28>
    }
}
ffffffff80000cc7:	c3                   	retq   
ffffffff80000cc8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80000ccf:	00 

ffffffff80000cd0 <fb_drawline>:

void fb_drawline(uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, enum fb_color col)
{

ffffffff80000cd0:	c3                   	retq   
ffffffff80000cd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80000cd8:	00 00 00 
ffffffff80000cdb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80000ce0 <kbd_init>:


void kbd_init()
{

}
ffffffff80000ce0:	c3                   	retq   
ffffffff80000ce1:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000ce8:	00 00 00 00 
ffffffff80000cec:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000cf0 <kbd_set_target>:

void kbd_set_target(void* handler)
{
    kbd_handler = handler;
ffffffff80000cf0:	48 89 3d 11 a7 00 00 	mov    %rdi,0xa711(%rip)        # ffffffff8000b408 <kbd_handler>
    kbd_active = 1;
ffffffff80000cf7:	c6 05 12 a7 00 00 01 	movb   $0x1,0xa712(%rip)        # ffffffff8000b410 <kbd_active>
}
ffffffff80000cfe:	c3                   	retq   
ffffffff80000cff:	90                   	nop

ffffffff80000d00 <kbd_translate>:

uint8_t kbd_translate(uint8_t scancode, uint8_t uppercase)
{
    if(scancode > 58) return 0;
ffffffff80000d00:	31 c0                	xor    %eax,%eax
ffffffff80000d02:	40 80 ff 3a          	cmp    $0x3a,%dil
ffffffff80000d06:	77 14                	ja     ffffffff80000d1c <kbd_translate+0x1c>

    if(uppercase) return kbd_table[scancode] - 32;
ffffffff80000d08:	40 0f b6 ff          	movzbl %dil,%edi
ffffffff80000d0c:	40 84 f6             	test   %sil,%sil
ffffffff80000d0f:	0f b6 87 20 56 00 80 	movzbl -0x7fffa9e0(%rdi),%eax
ffffffff80000d16:	8d 50 e0             	lea    -0x20(%rax),%edx
ffffffff80000d19:	0f 45 c2             	cmovne %edx,%eax

    return kbd_table[scancode];
}
ffffffff80000d1c:	c3                   	retq   
ffffffff80000d1d:	0f 1f 00             	nopl   (%rax)

ffffffff80000d20 <kbd_handle>:
void kbd_handle()
{
    uint8_t data;
    KEY_INFO_t key_info;

    if(!kbd_active) return;
ffffffff80000d20:	80 3d e9 a6 00 00 00 	cmpb   $0x0,0xa6e9(%rip)        # ffffffff8000b410 <kbd_active>
ffffffff80000d27:	75 07                	jne    ffffffff80000d30 <kbd_handle+0x10>
ffffffff80000d29:	c3                   	retq   
ffffffff80000d2a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
ffffffff80000d30:	55                   	push   %rbp

    data = inb(0x60);
ffffffff80000d31:	bf 60 00 00 00       	mov    $0x60,%edi
{
ffffffff80000d36:	48 89 e5             	mov    %rsp,%rbp
    data = inb(0x60);
ffffffff80000d39:	e8 42 0b 00 00       	callq  ffffffff80001880 <inb>

    uint8_t buffer[20];

    switch(data)
ffffffff80000d3e:	3c 36                	cmp    $0x36,%al
ffffffff80000d40:	74 4e                	je     ffffffff80000d90 <kbd_handle+0x70>
ffffffff80000d42:	77 14                	ja     ffffffff80000d58 <kbd_handle+0x38>
ffffffff80000d44:	3c 01                	cmp    $0x1,%al
ffffffff80000d46:	74 28                	je     ffffffff80000d70 <kbd_handle+0x50>
ffffffff80000d48:	3c 2a                	cmp    $0x2a,%al
ffffffff80000d4a:	75 53                	jne    ffffffff80000d9f <kbd_handle+0x7f>
    {
        case KBD_LEFT_SHIFT:
            lshift_status = 1;
ffffffff80000d4c:	c6 05 ae a6 00 00 01 	movb   $0x1,0xa6ae(%rip)        # ffffffff8000b401 <lshift_status>
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
    key_info.scancode = data;

    kbd_handler(key_info);

ffffffff80000d53:	5d                   	pop    %rbp
ffffffff80000d54:	c3                   	retq   
ffffffff80000d55:	0f 1f 00             	nopl   (%rax)
    switch(data)
ffffffff80000d58:	3c aa                	cmp    $0xaa,%al
ffffffff80000d5a:	74 74                	je     ffffffff80000dd0 <kbd_handle+0xb0>
ffffffff80000d5c:	3c b6                	cmp    $0xb6,%al
ffffffff80000d5e:	75 39                	jne    ffffffff80000d99 <kbd_handle+0x79>
            rshift_status = 0;
ffffffff80000d60:	c6 05 99 a6 00 00 00 	movb   $0x0,0xa699(%rip)        # ffffffff8000b400 <rshift_status>
ffffffff80000d67:	5d                   	pop    %rbp
ffffffff80000d68:	c3                   	retq   
ffffffff80000d69:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            printf("%d\n", pit_ticks);
ffffffff80000d70:	48 8b 35 a9 e8 00 00 	mov    0xe8a9(%rip),%rsi        # ffffffff8000f620 <pit_ticks>
ffffffff80000d77:	48 c7 c7 eb 5b 00 80 	mov    $0xffffffff80005beb,%rdi
ffffffff80000d7e:	31 c0                	xor    %eax,%eax
ffffffff80000d80:	5d                   	pop    %rbp
            printf("%d\n", pit_ticks);
ffffffff80000d81:	e9 3a 35 00 00       	jmpq   ffffffff800042c0 <printf_>
ffffffff80000d86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80000d8d:	00 00 00 
            rshift_status = 1;
ffffffff80000d90:	c6 05 69 a6 00 00 01 	movb   $0x1,0xa669(%rip)        # ffffffff8000b400 <rshift_status>
ffffffff80000d97:	5d                   	pop    %rbp
ffffffff80000d98:	c3                   	retq   
    if(scancode > 58) return 0;
ffffffff80000d99:	31 d2                	xor    %edx,%edx
ffffffff80000d9b:	3c 3a                	cmp    $0x3a,%al
ffffffff80000d9d:	77 21                	ja     ffffffff80000dc0 <kbd_handle+0xa0>
    if(uppercase) return kbd_table[scancode] - 32;
ffffffff80000d9f:	0f b6 d0             	movzbl %al,%edx
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
ffffffff80000da2:	0f b6 0d 58 a6 00 00 	movzbl 0xa658(%rip),%ecx        # ffffffff8000b401 <lshift_status>
ffffffff80000da9:	0f b6 35 50 a6 00 00 	movzbl 0xa650(%rip),%esi        # ffffffff8000b400 <rshift_status>
    if(uppercase) return kbd_table[scancode] - 32;
ffffffff80000db0:	0f b6 92 20 56 00 80 	movzbl -0x7fffa9e0(%rdx),%edx
ffffffff80000db7:	40 08 f1             	or     %sil,%cl
ffffffff80000dba:	8d 7a e0             	lea    -0x20(%rdx),%edi
ffffffff80000dbd:	0f 45 d7             	cmovne %edi,%edx
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
ffffffff80000dc0:	31 c9                	xor    %ecx,%ecx
ffffffff80000dc2:	5d                   	pop    %rbp
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
ffffffff80000dc3:	88 d5                	mov    %dl,%ch
    key_info.scancode = data;
ffffffff80000dc5:	88 c1                	mov    %al,%cl
    kbd_handler(key_info);
ffffffff80000dc7:	89 cf                	mov    %ecx,%edi
ffffffff80000dc9:	ff 25 39 a6 00 00    	jmpq   *0xa639(%rip)        # ffffffff8000b408 <kbd_handler>
ffffffff80000dcf:	90                   	nop
            lshift_status = 0;
ffffffff80000dd0:	c6 05 2a a6 00 00 00 	movb   $0x0,0xa62a(%rip)        # ffffffff8000b401 <lshift_status>
ffffffff80000dd7:	5d                   	pop    %rbp
ffffffff80000dd8:	c3                   	retq   
ffffffff80000dd9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80000de0 <pic_EOI>:

uint64_t ticks;

void pic_EOI(uint8_t IRQ)
{
    if(IRQ >= 8)
ffffffff80000de0:	40 80 ff 07          	cmp    $0x7,%dil
ffffffff80000de4:	77 12                	ja     ffffffff80000df8 <pic_EOI+0x18>
    {
        outb(PIC2_CMD, PIC_EOI);
    }
    
    outb(PIC1_CMD, PIC_EOI);
ffffffff80000de6:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff80000deb:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80000df0:	e9 7b 0a 00 00       	jmpq   ffffffff80001870 <outb>
ffffffff80000df5:	0f 1f 00             	nopl   (%rax)
{
ffffffff80000df8:	55                   	push   %rbp
        outb(PIC2_CMD, PIC_EOI);
ffffffff80000df9:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff80000dfe:	bf a0 00 00 00       	mov    $0xa0,%edi
{
ffffffff80000e03:	48 89 e5             	mov    %rsp,%rbp
        outb(PIC2_CMD, PIC_EOI);
ffffffff80000e06:	e8 65 0a 00 00       	callq  ffffffff80001870 <outb>
    outb(PIC1_CMD, PIC_EOI);
ffffffff80000e0b:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff80000e10:	bf 20 00 00 00       	mov    $0x20,%edi
}
ffffffff80000e15:	5d                   	pop    %rbp
    outb(PIC1_CMD, PIC_EOI);
ffffffff80000e16:	e9 55 0a 00 00       	jmpq   ffffffff80001870 <outb>
ffffffff80000e1b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80000e20 <pic_set_mask>:

void pic_set_mask(uint8_t IRQ)
{
ffffffff80000e20:	55                   	push   %rbp
ffffffff80000e21:	48 89 e5             	mov    %rsp,%rbp
ffffffff80000e24:	41 54                	push   %r12
ffffffff80000e26:	53                   	push   %rbx
    uint16_t port;
    uint8_t value;

    if(IRQ < 8)
ffffffff80000e27:	40 80 ff 07          	cmp    $0x7,%dil
ffffffff80000e2b:	76 33                	jbe    ffffffff80000e60 <pic_set_mask+0x40>
        port = PIC1_DATA;
    }
    else
    {
        port = PIC2_DATA;
        IRQ -= 8;
ffffffff80000e2d:	44 8d 67 f8          	lea    -0x8(%rdi),%r12d
ffffffff80000e31:	bb a1 00 00 00       	mov    $0xa1,%ebx
    }
    value = inb(port) | (1 << IRQ);
ffffffff80000e36:	89 df                	mov    %ebx,%edi
ffffffff80000e38:	e8 43 0a 00 00       	callq  ffffffff80001880 <inb>
ffffffff80000e3d:	44 89 e1             	mov    %r12d,%ecx
ffffffff80000e40:	ba 01 00 00 00       	mov    $0x1,%edx
    outb(port, value);
ffffffff80000e45:	89 df                	mov    %ebx,%edi
    value = inb(port) | (1 << IRQ);
ffffffff80000e47:	d3 e2                	shl    %cl,%edx
}
ffffffff80000e49:	5b                   	pop    %rbx
ffffffff80000e4a:	41 5c                	pop    %r12
    value = inb(port) | (1 << IRQ);
ffffffff80000e4c:	09 d0                	or     %edx,%eax
}
ffffffff80000e4e:	5d                   	pop    %rbp
    outb(port, value);
ffffffff80000e4f:	0f b6 f0             	movzbl %al,%esi
ffffffff80000e52:	e9 19 0a 00 00       	jmpq   ffffffff80001870 <outb>
ffffffff80000e57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80000e5e:	00 00 
ffffffff80000e60:	41 89 fc             	mov    %edi,%r12d
ffffffff80000e63:	bb 21 00 00 00       	mov    $0x21,%ebx
ffffffff80000e68:	eb cc                	jmp    ffffffff80000e36 <pic_set_mask+0x16>
ffffffff80000e6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80000e70 <pic_clear_mask>:

void pic_clear_mask(uint8_t IRQ)
{
ffffffff80000e70:	55                   	push   %rbp
ffffffff80000e71:	48 89 e5             	mov    %rsp,%rbp
ffffffff80000e74:	41 54                	push   %r12
ffffffff80000e76:	53                   	push   %rbx
    uint16_t port;
    uint8_t value;

    if(IRQ < 8)
ffffffff80000e77:	40 80 ff 07          	cmp    $0x7,%dil
ffffffff80000e7b:	76 23                	jbe    ffffffff80000ea0 <pic_clear_mask+0x30>
        port = PIC1_DATA;
    }
    else
    {
        port = PIC2_DATA;
        IRQ -= 8;
ffffffff80000e7d:	44 8d 67 f8          	lea    -0x8(%rdi),%r12d
ffffffff80000e81:	bb a1 00 00 00       	mov    $0xa1,%ebx
    }
    value = inb(port) & ~(1 << IRQ);
ffffffff80000e86:	89 df                	mov    %ebx,%edi
ffffffff80000e88:	e8 f3 09 00 00       	callq  ffffffff80001880 <inb>
    outb(port, value);
ffffffff80000e8d:	89 df                	mov    %ebx,%edi
}
ffffffff80000e8f:	5b                   	pop    %rbx
    value = inb(port) & ~(1 << IRQ);
ffffffff80000e90:	44 0f b3 e0          	btr    %r12d,%eax
}
ffffffff80000e94:	41 5c                	pop    %r12
ffffffff80000e96:	5d                   	pop    %rbp
    outb(port, value);
ffffffff80000e97:	0f b6 f0             	movzbl %al,%esi
ffffffff80000e9a:	e9 d1 09 00 00       	jmpq   ffffffff80001870 <outb>
ffffffff80000e9f:	90                   	nop
ffffffff80000ea0:	41 89 fc             	mov    %edi,%r12d
ffffffff80000ea3:	bb 21 00 00 00       	mov    $0x21,%ebx
ffffffff80000ea8:	eb dc                	jmp    ffffffff80000e86 <pic_clear_mask+0x16>
ffffffff80000eaa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80000eb0 <pic_disable>:

void pic_disable()
{
ffffffff80000eb0:	55                   	push   %rbp
    outb(PIC2_DATA, 0xff);
ffffffff80000eb1:	be ff 00 00 00       	mov    $0xff,%esi
ffffffff80000eb6:	bf a1 00 00 00       	mov    $0xa1,%edi
{
ffffffff80000ebb:	48 89 e5             	mov    %rsp,%rbp
    outb(PIC2_DATA, 0xff);
ffffffff80000ebe:	e8 ad 09 00 00       	callq  ffffffff80001870 <outb>
    outb(PIC1_DATA, 0xff);
ffffffff80000ec3:	be ff 00 00 00       	mov    $0xff,%esi
ffffffff80000ec8:	bf 21 00 00 00       	mov    $0x21,%edi
}
ffffffff80000ecd:	5d                   	pop    %rbp
    outb(PIC1_DATA, 0xff);
ffffffff80000ece:	e9 9d 09 00 00       	jmpq   ffffffff80001870 <outb>
ffffffff80000ed3:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000eda:	00 00 00 00 
ffffffff80000ede:	66 90                	xchg   %ax,%ax

ffffffff80000ee0 <pic_remap>:

void pic_remap()
{
ffffffff80000ee0:	55                   	push   %rbp
    uint8_t mask1 = inb(PIC1_DATA);
ffffffff80000ee1:	bf 21 00 00 00       	mov    $0x21,%edi
{
ffffffff80000ee6:	48 89 e5             	mov    %rsp,%rbp
ffffffff80000ee9:	41 54                	push   %r12
ffffffff80000eeb:	53                   	push   %rbx
    uint8_t mask1 = inb(PIC1_DATA);
ffffffff80000eec:	e8 8f 09 00 00       	callq  ffffffff80001880 <inb>
    uint8_t mask2 = inb(PIC2_DATA);
ffffffff80000ef1:	bf a1 00 00 00       	mov    $0xa1,%edi
    uint8_t mask1 = inb(PIC1_DATA);
ffffffff80000ef6:	41 89 c4             	mov    %eax,%r12d
    uint8_t mask2 = inb(PIC2_DATA);
ffffffff80000ef9:	e8 82 09 00 00       	callq  ffffffff80001880 <inb>

    outb(PIC1_CMD, 0x11);
ffffffff80000efe:	be 11 00 00 00       	mov    $0x11,%esi
ffffffff80000f03:	bf 20 00 00 00       	mov    $0x20,%edi
    uint8_t mask2 = inb(PIC2_DATA);
ffffffff80000f08:	89 c3                	mov    %eax,%ebx
    outb(PIC1_CMD, 0x11);
ffffffff80000f0a:	e8 61 09 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
ffffffff80000f0f:	31 c0                	xor    %eax,%eax
ffffffff80000f11:	e8 7a 09 00 00       	callq  ffffffff80001890 <io_wait>
    outb(PIC2_CMD, 0x11);
ffffffff80000f16:	be 11 00 00 00       	mov    $0x11,%esi
ffffffff80000f1b:	bf a0 00 00 00       	mov    $0xa0,%edi
ffffffff80000f20:	e8 4b 09 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
ffffffff80000f25:	31 c0                	xor    %eax,%eax
ffffffff80000f27:	e8 64 09 00 00       	callq  ffffffff80001890 <io_wait>

    outb(PIC1_DATA, 0x20);
ffffffff80000f2c:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff80000f31:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff80000f36:	e8 35 09 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
ffffffff80000f3b:	31 c0                	xor    %eax,%eax
ffffffff80000f3d:	e8 4e 09 00 00       	callq  ffffffff80001890 <io_wait>
    outb(PIC2_DATA, 0x20);
ffffffff80000f42:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff80000f47:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff80000f4c:	e8 1f 09 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
ffffffff80000f51:	31 c0                	xor    %eax,%eax
ffffffff80000f53:	e8 38 09 00 00       	callq  ffffffff80001890 <io_wait>

    outb(PIC1_DATA, 0x04);
ffffffff80000f58:	be 04 00 00 00       	mov    $0x4,%esi
ffffffff80000f5d:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff80000f62:	e8 09 09 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
ffffffff80000f67:	31 c0                	xor    %eax,%eax
ffffffff80000f69:	e8 22 09 00 00       	callq  ffffffff80001890 <io_wait>
    outb(PIC2_DATA, 0x02);
ffffffff80000f6e:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff80000f73:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff80000f78:	e8 f3 08 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
ffffffff80000f7d:	31 c0                	xor    %eax,%eax
ffffffff80000f7f:	e8 0c 09 00 00       	callq  ffffffff80001890 <io_wait>

    outb(PIC1_DATA, 0x01);
ffffffff80000f84:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff80000f89:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff80000f8e:	e8 dd 08 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
ffffffff80000f93:	31 c0                	xor    %eax,%eax
ffffffff80000f95:	e8 f6 08 00 00       	callq  ffffffff80001890 <io_wait>
    outb(PIC2_DATA, 0x01);
ffffffff80000f9a:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff80000f9f:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff80000fa4:	e8 c7 08 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
ffffffff80000fa9:	31 c0                	xor    %eax,%eax
ffffffff80000fab:	e8 e0 08 00 00       	callq  ffffffff80001890 <io_wait>

    outb(PIC1_DATA, mask1);
ffffffff80000fb0:	41 0f b6 f4          	movzbl %r12b,%esi
ffffffff80000fb4:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff80000fb9:	e8 b2 08 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
ffffffff80000fbe:	31 c0                	xor    %eax,%eax
ffffffff80000fc0:	e8 cb 08 00 00       	callq  ffffffff80001890 <io_wait>
    outb(PIC2_DATA, mask2);
ffffffff80000fc5:	0f b6 f3             	movzbl %bl,%esi
ffffffff80000fc8:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff80000fcd:	e8 9e 08 00 00       	callq  ffffffff80001870 <outb>
    io_wait();
}
ffffffff80000fd2:	5b                   	pop    %rbx
    io_wait();
ffffffff80000fd3:	31 c0                	xor    %eax,%eax
}
ffffffff80000fd5:	41 5c                	pop    %r12
ffffffff80000fd7:	5d                   	pop    %rbp
    io_wait();
ffffffff80000fd8:	e9 b3 08 00 00       	jmpq   ffffffff80001890 <io_wait>
ffffffff80000fdd:	0f 1f 00             	nopl   (%rax)

ffffffff80000fe0 <pit_init>:



void pit_init(uint64_t freq)
{
ffffffff80000fe0:	55                   	push   %rbp
    uint64_t working_freq = freq;
    if(freq < 10000)
        working_freq = 10000;
    
    if(freq > 1193181)
ffffffff80000fe1:	b8 dd 34 12 00       	mov    $0x1234dd,%eax
        working_freq = 1193181;

    uint32_t divisor = 1193180 / working_freq;

    outb(0x43, 0x36);
ffffffff80000fe6:	be 36 00 00 00       	mov    $0x36,%esi
{
ffffffff80000feb:	48 89 e5             	mov    %rsp,%rbp
ffffffff80000fee:	53                   	push   %rbx
ffffffff80000fef:	48 83 ec 08          	sub    $0x8,%rsp
    if(freq > 1193181)
ffffffff80000ff3:	48 39 c7             	cmp    %rax,%rdi
ffffffff80000ff6:	48 0f 47 f8          	cmova  %rax,%rdi
    uint32_t divisor = 1193180 / working_freq;
ffffffff80000ffa:	b8 10 27 00 00       	mov    $0x2710,%eax
ffffffff80000fff:	48 39 c7             	cmp    %rax,%rdi
ffffffff80001002:	48 0f 42 f8          	cmovb  %rax,%rdi
ffffffff80001006:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
ffffffff8000100b:	31 d2                	xor    %edx,%edx
ffffffff8000100d:	48 f7 f7             	div    %rdi
    outb(0x43, 0x36);
ffffffff80001010:	bf 43 00 00 00       	mov    $0x43,%edi
    uint32_t divisor = 1193180 / working_freq;
ffffffff80001015:	48 89 c3             	mov    %rax,%rbx
    outb(0x43, 0x36);
ffffffff80001018:	e8 53 08 00 00       	callq  ffffffff80001870 <outb>
    outb(0x40, divisor & 0xff);
ffffffff8000101d:	89 de                	mov    %ebx,%esi
ffffffff8000101f:	bf 40 00 00 00       	mov    $0x40,%edi
ffffffff80001024:	e8 47 08 00 00       	callq  ffffffff80001870 <outb>
    outb(0x40, divisor >> 8);
ffffffff80001029:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
    outb(0x40, divisor >> 8);
ffffffff8000102d:	31 f6                	xor    %esi,%esi
ffffffff8000102f:	bf 40 00 00 00       	mov    $0x40,%edi
ffffffff80001034:	c9                   	leaveq 
    outb(0x40, divisor >> 8);
ffffffff80001035:	e9 36 08 00 00       	jmpq   ffffffff80001870 <outb>
ffffffff8000103a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80001040 <serial_init>:
#include <io.h>

char serial_buffer[256];

uint64_t serial_init(uint16_t port)
{
ffffffff80001040:	55                   	push   %rbp
    outb(port + 1, 0x00);
ffffffff80001041:	31 f6                	xor    %esi,%esi
{
ffffffff80001043:	48 89 e5             	mov    %rsp,%rbp
ffffffff80001046:	41 56                	push   %r14
ffffffff80001048:	41 55                	push   %r13
    outb(port + 1, 0x00);
ffffffff8000104a:	44 8d 6f 01          	lea    0x1(%rdi),%r13d
{
ffffffff8000104e:	41 54                	push   %r12
    outb(port + 1, 0x00);
ffffffff80001050:	45 0f b7 ed          	movzwl %r13w,%r13d
{
ffffffff80001054:	53                   	push   %rbx
ffffffff80001055:	89 fb                	mov    %edi,%ebx
    outb(port + 1, 0x00);
ffffffff80001057:	44 89 ef             	mov    %r13d,%edi
    outb(port + 3, 0x80);
ffffffff8000105a:	44 8d 63 03          	lea    0x3(%rbx),%r12d
    outb(port + 0, 0x00);
ffffffff8000105e:	44 0f b7 f3          	movzwl %bx,%r14d
    outb(port + 3, 0x80);
ffffffff80001062:	45 0f b7 e4          	movzwl %r12w,%r12d
    outb(port + 1, 0x00);
ffffffff80001066:	e8 05 08 00 00       	callq  ffffffff80001870 <outb>
    outb(port + 3, 0x80);
ffffffff8000106b:	be 80 00 00 00       	mov    $0x80,%esi
ffffffff80001070:	44 89 e7             	mov    %r12d,%edi
ffffffff80001073:	e8 f8 07 00 00       	callq  ffffffff80001870 <outb>
    outb(port + 0, 0x00);
ffffffff80001078:	31 f6                	xor    %esi,%esi
ffffffff8000107a:	44 89 f7             	mov    %r14d,%edi
ffffffff8000107d:	e8 ee 07 00 00       	callq  ffffffff80001870 <outb>
    outb(port + 1, 0x00);
ffffffff80001082:	31 f6                	xor    %esi,%esi
ffffffff80001084:	44 89 ef             	mov    %r13d,%edi
ffffffff80001087:	e8 e4 07 00 00       	callq  ffffffff80001870 <outb>
    outb(port + 3, 0x03);
ffffffff8000108c:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff80001091:	44 89 e7             	mov    %r12d,%edi
ffffffff80001094:	e8 d7 07 00 00       	callq  ffffffff80001870 <outb>
    outb(port + 2, 0xC7);
ffffffff80001099:	8d 7b 02             	lea    0x2(%rbx),%edi
    outb(port + 4, 0x0B);
ffffffff8000109c:	83 c3 04             	add    $0x4,%ebx
    outb(port + 2, 0xC7);
ffffffff8000109f:	be c7 00 00 00       	mov    $0xc7,%esi
ffffffff800010a4:	0f b7 ff             	movzwl %di,%edi
    outb(port + 4, 0x0B);
ffffffff800010a7:	0f b7 db             	movzwl %bx,%ebx
    outb(port + 2, 0xC7);
ffffffff800010aa:	e8 c1 07 00 00       	callq  ffffffff80001870 <outb>
    outb(port + 4, 0x0B);
ffffffff800010af:	be 0b 00 00 00       	mov    $0xb,%esi
ffffffff800010b4:	89 df                	mov    %ebx,%edi
ffffffff800010b6:	e8 b5 07 00 00       	callq  ffffffff80001870 <outb>

    if(inb(port + 0) != 0xAE)
ffffffff800010bb:	44 89 f7             	mov    %r14d,%edi
ffffffff800010be:	e8 bd 07 00 00       	callq  ffffffff80001880 <inb>
ffffffff800010c3:	89 c2                	mov    %eax,%edx
ffffffff800010c5:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff800010ca:	80 fa ae             	cmp    $0xae,%dl
ffffffff800010cd:	74 11                	je     ffffffff800010e0 <serial_init+0xa0>
        return 1;
    }

    outb(port + 4, 0x0F);
    return 0;
}
ffffffff800010cf:	5b                   	pop    %rbx
ffffffff800010d0:	41 5c                	pop    %r12
ffffffff800010d2:	41 5d                	pop    %r13
ffffffff800010d4:	41 5e                	pop    %r14
ffffffff800010d6:	5d                   	pop    %rbp
ffffffff800010d7:	c3                   	retq   
ffffffff800010d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff800010df:	00 
    outb(port + 4, 0x0F);
ffffffff800010e0:	89 df                	mov    %ebx,%edi
ffffffff800010e2:	be 0f 00 00 00       	mov    $0xf,%esi
ffffffff800010e7:	e8 84 07 00 00       	callq  ffffffff80001870 <outb>
}
ffffffff800010ec:	5b                   	pop    %rbx
    return 0;
ffffffff800010ed:	31 c0                	xor    %eax,%eax
}
ffffffff800010ef:	41 5c                	pop    %r12
ffffffff800010f1:	41 5d                	pop    %r13
ffffffff800010f3:	41 5e                	pop    %r14
ffffffff800010f5:	5d                   	pop    %rbp
ffffffff800010f6:	c3                   	retq   
ffffffff800010f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800010fe:	00 00 

ffffffff80001100 <serial_received>:

uint64_t serial_received(uint16_t port)
{
ffffffff80001100:	55                   	push   %rbp
    return inb(port + 5) & 1;
ffffffff80001101:	83 c7 05             	add    $0x5,%edi
ffffffff80001104:	0f b7 ff             	movzwl %di,%edi
{
ffffffff80001107:	48 89 e5             	mov    %rsp,%rbp
    return inb(port + 5) & 1;
ffffffff8000110a:	e8 71 07 00 00       	callq  ffffffff80001880 <inb>
}
ffffffff8000110f:	5d                   	pop    %rbp
    return inb(port + 5) & 1;
ffffffff80001110:	83 e0 01             	and    $0x1,%eax
}
ffffffff80001113:	c3                   	retq   
ffffffff80001114:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000111b:	00 00 00 00 
ffffffff8000111f:	90                   	nop

ffffffff80001120 <serial_read>:

uint8_t serial_read(uint16_t port)
{
ffffffff80001120:	55                   	push   %rbp
ffffffff80001121:	48 89 e5             	mov    %rsp,%rbp
ffffffff80001124:	41 54                	push   %r12
    while(serial_received(port) == 0);
ffffffff80001126:	44 0f b7 e7          	movzwl %di,%r12d
    return inb(port + 5) & 1;
ffffffff8000112a:	83 c7 05             	add    $0x5,%edi
{
ffffffff8000112d:	53                   	push   %rbx
    return inb(port + 5) & 1;
ffffffff8000112e:	0f b7 df             	movzwl %di,%ebx
ffffffff80001131:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff80001138:	89 df                	mov    %ebx,%edi
ffffffff8000113a:	e8 41 07 00 00       	callq  ffffffff80001880 <inb>
    while(serial_received(port) == 0);
ffffffff8000113f:	a8 01                	test   $0x1,%al
ffffffff80001141:	74 f5                	je     ffffffff80001138 <serial_read+0x18>

    return inb(port);
}
ffffffff80001143:	5b                   	pop    %rbx
    return inb(port);
ffffffff80001144:	44 89 e7             	mov    %r12d,%edi
}
ffffffff80001147:	41 5c                	pop    %r12
ffffffff80001149:	5d                   	pop    %rbp
    return inb(port);
ffffffff8000114a:	e9 31 07 00 00       	jmpq   ffffffff80001880 <inb>
ffffffff8000114f:	90                   	nop

ffffffff80001150 <serial_is_tx_empty>:

uint64_t serial_is_tx_empty(uint16_t port)
{
ffffffff80001150:	55                   	push   %rbp
    return inb(port + 5) & 0x20;
ffffffff80001151:	83 c7 05             	add    $0x5,%edi
ffffffff80001154:	0f b7 ff             	movzwl %di,%edi
{
ffffffff80001157:	48 89 e5             	mov    %rsp,%rbp
    return inb(port + 5) & 0x20;
ffffffff8000115a:	e8 21 07 00 00       	callq  ffffffff80001880 <inb>
}
ffffffff8000115f:	5d                   	pop    %rbp
    return inb(port + 5) & 0x20;
ffffffff80001160:	83 e0 20             	and    $0x20,%eax
}
ffffffff80001163:	c3                   	retq   
ffffffff80001164:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000116b:	00 00 00 00 
ffffffff8000116f:	90                   	nop

ffffffff80001170 <serial_write>:

void serial_write(uint16_t port, uint8_t data)
{
ffffffff80001170:	55                   	push   %rbp
ffffffff80001171:	48 89 e5             	mov    %rsp,%rbp
ffffffff80001174:	41 55                	push   %r13
    while(serial_is_tx_empty(port) == 0);
ffffffff80001176:	44 0f b7 ef          	movzwl %di,%r13d
    return inb(port + 5) & 0x20;
ffffffff8000117a:	83 c7 05             	add    $0x5,%edi
{
ffffffff8000117d:	41 54                	push   %r12
ffffffff8000117f:	41 89 f4             	mov    %esi,%r12d
ffffffff80001182:	53                   	push   %rbx
    return inb(port + 5) & 0x20;
ffffffff80001183:	0f b7 df             	movzwl %di,%ebx
{
ffffffff80001186:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff8000118a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    return inb(port + 5) & 0x20;
ffffffff80001190:	89 df                	mov    %ebx,%edi
ffffffff80001192:	e8 e9 06 00 00       	callq  ffffffff80001880 <inb>
    while(serial_is_tx_empty(port) == 0);
ffffffff80001197:	a8 20                	test   $0x20,%al
ffffffff80001199:	74 f5                	je     ffffffff80001190 <serial_write+0x20>
    outb(port, data);
}
ffffffff8000119b:	48 83 c4 08          	add    $0x8,%rsp
    outb(port, data);
ffffffff8000119f:	41 0f b6 f4          	movzbl %r12b,%esi
ffffffff800011a3:	44 89 ef             	mov    %r13d,%edi
}
ffffffff800011a6:	5b                   	pop    %rbx
ffffffff800011a7:	41 5c                	pop    %r12
ffffffff800011a9:	41 5d                	pop    %r13
ffffffff800011ab:	5d                   	pop    %rbp
    outb(port, data);
ffffffff800011ac:	e9 bf 06 00 00       	jmpq   ffffffff80001870 <outb>
ffffffff800011b1:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800011b8:	00 00 00 00 
ffffffff800011bc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff800011c0 <serial_write_str>:

void serial_write_str(uint16_t port, char* data)
{
ffffffff800011c0:	55                   	push   %rbp
ffffffff800011c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff800011c4:	41 57                	push   %r15
ffffffff800011c6:	41 56                	push   %r14
ffffffff800011c8:	41 55                	push   %r13
ffffffff800011ca:	41 54                	push   %r12
ffffffff800011cc:	53                   	push   %rbx
ffffffff800011cd:	48 83 ec 08          	sub    $0x8,%rsp
    uint8_t i = 0;
    while(data[i] != 0)
ffffffff800011d1:	44 0f b6 26          	movzbl (%rsi),%r12d
ffffffff800011d5:	45 84 e4             	test   %r12b,%r12b
ffffffff800011d8:	74 3e                	je     ffffffff80001218 <serial_write_str+0x58>
    {
        serial_write(port, data[i]);
ffffffff800011da:	44 0f b7 ff          	movzwl %di,%r15d
    return inb(port + 5) & 0x20;
ffffffff800011de:	83 c7 05             	add    $0x5,%edi
ffffffff800011e1:	49 89 f6             	mov    %rsi,%r14
    uint8_t i = 0;
ffffffff800011e4:	45 31 ed             	xor    %r13d,%r13d
    return inb(port + 5) & 0x20;
ffffffff800011e7:	0f b7 df             	movzwl %di,%ebx
ffffffff800011ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff800011f0:	89 df                	mov    %ebx,%edi
ffffffff800011f2:	e8 89 06 00 00       	callq  ffffffff80001880 <inb>
    while(serial_is_tx_empty(port) == 0);
ffffffff800011f7:	a8 20                	test   $0x20,%al
ffffffff800011f9:	74 f5                	je     ffffffff800011f0 <serial_write_str+0x30>
    outb(port, data);
ffffffff800011fb:	44 89 e6             	mov    %r12d,%esi
ffffffff800011fe:	44 89 ff             	mov    %r15d,%edi
        //if(data[i] == '\n') serial_write(port, '\r');
        i++;
ffffffff80001201:	41 83 c5 01          	add    $0x1,%r13d
    outb(port, data);
ffffffff80001205:	e8 66 06 00 00       	callq  ffffffff80001870 <outb>
    while(data[i] != 0)
ffffffff8000120a:	41 0f b6 c5          	movzbl %r13b,%eax
ffffffff8000120e:	45 0f b6 24 06       	movzbl (%r14,%rax,1),%r12d
ffffffff80001213:	45 84 e4             	test   %r12b,%r12b
ffffffff80001216:	75 d8                	jne    ffffffff800011f0 <serial_write_str+0x30>
    }
ffffffff80001218:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8000121c:	5b                   	pop    %rbx
ffffffff8000121d:	41 5c                	pop    %r12
ffffffff8000121f:	41 5d                	pop    %r13
ffffffff80001221:	41 5e                	pop    %r14
ffffffff80001223:	41 5f                	pop    %r15
ffffffff80001225:	5d                   	pop    %rbp
ffffffff80001226:	c3                   	retq   
ffffffff80001227:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000122e:	00 00 

ffffffff80001230 <stty_sendcmd>:
#include <serial.h>



void stty_sendcmd(uint16_t cmd)
{
ffffffff80001230:	55                   	push   %rbp
    serial_write(SERIAL_PORT1, 0x1B);
ffffffff80001231:	be 1b 00 00 00       	mov    $0x1b,%esi
ffffffff80001236:	bf f8 03 00 00       	mov    $0x3f8,%edi
{
ffffffff8000123b:	48 89 e5             	mov    %rsp,%rbp
    serial_write(SERIAL_PORT1, 0x1B);
ffffffff8000123e:	e8 2d ff ff ff       	callq  ffffffff80001170 <serial_write>
    serial_write(SERIAL_PORT1, 0x5B);
ffffffff80001243:	be 5b 00 00 00       	mov    $0x5b,%esi
ffffffff80001248:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000124d:	e8 1e ff ff ff       	callq  ffffffff80001170 <serial_write>
    serial_write(SERIAL_PORT1, '[');
ffffffff80001252:	be 5b 00 00 00       	mov    $0x5b,%esi
ffffffff80001257:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000125c:	e8 0f ff ff ff       	callq  ffffffff80001170 <serial_write>
    serial_write(SERIAL_PORT1, 'H');
ffffffff80001261:	be 48 00 00 00       	mov    $0x48,%esi
ffffffff80001266:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000126b:	e8 00 ff ff ff       	callq  ffffffff80001170 <serial_write>
    serial_write(SERIAL_PORT1, '~');
ffffffff80001270:	be 7e 00 00 00       	mov    $0x7e,%esi
ffffffff80001275:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000127a:	5d                   	pop    %rbp
    serial_write(SERIAL_PORT1, '~');
ffffffff8000127b:	e9 f0 fe ff ff       	jmpq   ffffffff80001170 <serial_write>

ffffffff80001280 <load_elf>:
//#include <memory.h>

uint64_t load_elf(void* ptr)
{

ffffffff80001280:	c3                   	retq   
ffffffff80001281:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001288:	00 00 00 
ffffffff8000128b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80001290 <oct2bin>:

uint64_t oct2bin(uint8_t* str, uint16_t size)
{
    uint64_t n = 0;
    uint8_t* c = str;
    while (size-- > 0)
ffffffff80001290:	8d 46 ff             	lea    -0x1(%rsi),%eax
ffffffff80001293:	66 85 f6             	test   %si,%si
ffffffff80001296:	74 30                	je     ffffffff800012c8 <oct2bin+0x38>
ffffffff80001298:	0f b7 c0             	movzwl %ax,%eax
    uint64_t n = 0;
ffffffff8000129b:	31 d2                	xor    %edx,%edx
ffffffff8000129d:	48 8d 4c 07 01       	lea    0x1(%rdi,%rax,1),%rcx
ffffffff800012a2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    {
        n *= 8;
        n += *c - '0';
ffffffff800012a8:	0f b6 07             	movzbl (%rdi),%eax
        c++;
ffffffff800012ab:	48 83 c7 01          	add    $0x1,%rdi
        n += *c - '0';
ffffffff800012af:	83 e8 30             	sub    $0x30,%eax
ffffffff800012b2:	48 98                	cltq   
ffffffff800012b4:	48 8d 14 d0          	lea    (%rax,%rdx,8),%rdx
    while (size-- > 0)
ffffffff800012b8:	48 39 cf             	cmp    %rcx,%rdi
ffffffff800012bb:	75 eb                	jne    ffffffff800012a8 <oct2bin+0x18>
    }
    return n;
}
ffffffff800012bd:	48 89 d0             	mov    %rdx,%rax
ffffffff800012c0:	c3                   	retq   
ffffffff800012c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    uint64_t n = 0;
ffffffff800012c8:	31 d2                	xor    %edx,%edx
}
ffffffff800012ca:	48 89 d0             	mov    %rdx,%rax
ffffffff800012cd:	c3                   	retq   
ffffffff800012ce:	66 90                	xchg   %ax,%ax

ffffffff800012d0 <gdt_init>:
uint8_t ist2[4096];

void gdt_init()
{
    gdt.null0.raw = 0x00;
    gdt.kcode.raw = 0x00AF9A000000FFFF;
ffffffff800012d0:	48 b8 ff ff 00 00 00 	movabs $0xaf9a000000ffff,%rax
ffffffff800012d7:	9a af 00 
    tss.ist1 = (uint64_t)ist1 + sizeof(ist1);

    gdtr.base = (uint64_t)&gdt;
    gdtr.limit = sizeof(gdt);

    gdt_load((uint64_t*)&gdtr, 0x50);
ffffffff800012da:	be 50 00 00 00       	mov    $0x50,%esi
ffffffff800012df:	48 c7 c7 20 f5 00 80 	mov    $0xffffffff8000f520,%rdi
    gdt.null0.raw = 0x00;
ffffffff800012e6:	48 c7 05 cf e2 00 00 	movq   $0x0,0xe2cf(%rip)        # ffffffff8000f5c0 <gdt>
ffffffff800012ed:	00 00 00 00 
    gdt.kcode.raw = 0x00AF9A000000FFFF;
ffffffff800012f1:	48 89 05 d0 e2 00 00 	mov    %rax,0xe2d0(%rip)        # ffffffff8000f5c8 <gdt+0x8>
    gdt.kdata.raw = 0x00AF92000000FFFF;
ffffffff800012f8:	48 b8 ff ff 00 00 00 	movabs $0xaf92000000ffff,%rax
ffffffff800012ff:	92 af 00 
ffffffff80001302:	48 89 05 c7 e2 00 00 	mov    %rax,0xe2c7(%rip)        # ffffffff8000f5d0 <gdt+0x10>
    gdt.ucode.raw = 0x00AFFA000000FFFF;
ffffffff80001309:	48 b8 ff ff 00 00 00 	movabs $0xaffa000000ffff,%rax
ffffffff80001310:	fa af 00 
ffffffff80001313:	48 89 05 ce e2 00 00 	mov    %rax,0xe2ce(%rip)        # ffffffff8000f5e8 <gdt+0x28>
    gdt.udata.raw = 0x00AFF2000000FFFF;
ffffffff8000131a:	48 b8 ff ff 00 00 00 	movabs $0xaff2000000ffff,%rax
ffffffff80001321:	f2 af 00 
ffffffff80001324:	48 89 05 b5 e2 00 00 	mov    %rax,0xe2b5(%rip)        # ffffffff8000f5e0 <gdt+0x20>
    gdt.tss_entry.base0 = (uint64_t)&tss & 0xFFFF;
ffffffff8000132b:	48 c7 c0 40 f5 00 80 	mov    $0xffffffff8000f540,%rax
    gdt.tss_entry.base16 = ((uint64_t)&tss >> 16) & 0xFF;
ffffffff80001332:	48 89 c2             	mov    %rax,%rdx
    gdt.tss_entry.base0 = (uint64_t)&tss & 0xFFFF;
ffffffff80001335:	66 89 05 d6 e2 00 00 	mov    %ax,0xe2d6(%rip)        # ffffffff8000f612 <gdt+0x52>
    gdt.null1.raw = 0x00;
ffffffff8000133c:	48 c7 05 91 e2 00 00 	movq   $0x0,0xe291(%rip)        # ffffffff8000f5d8 <gdt+0x18>
ffffffff80001343:	00 00 00 00 
    gdt.tss_entry.base16 = ((uint64_t)&tss >> 16) & 0xFF;
ffffffff80001347:	48 c1 ea 10          	shr    $0x10,%rdx
ffffffff8000134b:	88 15 c3 e2 00 00    	mov    %dl,0xe2c3(%rip)        # ffffffff8000f614 <gdt+0x54>
    gdt.tss_entry.base24 = ((uint64_t)&tss >> 24) & 0xFF;
ffffffff80001351:	48 89 c2             	mov    %rax,%rdx
    gdt.tss_entry.base32 = ((uint64_t)&tss >> 32) & 0xFFFFFFFF;
ffffffff80001354:	48 c1 e8 20          	shr    $0x20,%rax
    gdt.tss_entry.base24 = ((uint64_t)&tss >> 24) & 0xFF;
ffffffff80001358:	48 c1 ea 18          	shr    $0x18,%rdx
    gdt.tss_entry.base32 = ((uint64_t)&tss >> 32) & 0xFFFFFFFF;
ffffffff8000135c:	89 05 b6 e2 00 00    	mov    %eax,0xe2b6(%rip)        # ffffffff8000f618 <gdt+0x58>
    gdt.tss_entry.limit0 = sizeof(tss);
ffffffff80001362:	b8 68 00 00 00       	mov    $0x68,%eax
    gdt.tss_entry.base24 = ((uint64_t)&tss >> 24) & 0xFF;
ffffffff80001367:	88 15 aa e2 00 00    	mov    %dl,0xe2aa(%rip)        # ffffffff8000f617 <gdt+0x57>
    gdtr.limit = sizeof(gdt);
ffffffff8000136d:	ba 60 00 00 00       	mov    $0x60,%edx
    gdt.tss_entry.limit0 = sizeof(tss);
ffffffff80001372:	66 89 05 97 e2 00 00 	mov    %ax,0xe297(%rip)        # ffffffff8000f610 <gdt+0x50>
    gdt.tss_entry.segment_type = 0x09;      //64 bit TSS
ffffffff80001379:	8b 05 95 e2 00 00    	mov    0xe295(%rip),%eax        # ffffffff8000f614 <gdt+0x54>
    gdt.null2.raw = 0x00;
ffffffff8000137f:	48 c7 05 66 e2 00 00 	movq   $0x0,0xe266(%rip)        # ffffffff8000f5f0 <gdt+0x30>
ffffffff80001386:	00 00 00 00 
    gdt.tss_entry.segment_type = 0x09;      //64 bit TSS
ffffffff8000138a:	25 ff 00 40 ff       	and    $0xff4000ff,%eax
    gdt.null3.raw = 0x00;
ffffffff8000138f:	48 c7 05 5e e2 00 00 	movq   $0x0,0xe25e(%rip)        # ffffffff8000f5f8 <gdt+0x38>
ffffffff80001396:	00 00 00 00 
    gdt.tss_entry.segment_type = 0x09;      //64 bit TSS
ffffffff8000139a:	80 cc 89             	or     $0x89,%ah
    gdt.null4.raw = 0x00;
ffffffff8000139d:	48 c7 05 58 e2 00 00 	movq   $0x0,0xe258(%rip)        # ffffffff8000f600 <gdt+0x40>
ffffffff800013a4:	00 00 00 00 
    gdt.null5.raw = 0x00;
ffffffff800013a8:	48 c7 05 55 e2 00 00 	movq   $0x0,0xe255(%rip)        # ffffffff8000f608 <gdt+0x48>
ffffffff800013af:	00 00 00 00 
    gdt.tss_entry.segment_type = 0x09;      //64 bit TSS
ffffffff800013b3:	89 05 5b e2 00 00    	mov    %eax,0xe25b(%rip)        # ffffffff8000f614 <gdt+0x54>
    gdt.tss_entry.reserved1 = 0;
ffffffff800013b9:	c7 05 59 e2 00 00 00 	movl   $0x0,0xe259(%rip)        # ffffffff8000f61c <gdt+0x5c>
ffffffff800013c0:	00 00 00 
    tss.reserved0 = 0x00;
ffffffff800013c3:	c7 05 73 e1 00 00 00 	movl   $0x0,0xe173(%rip)        # ffffffff8000f540 <tss>
ffffffff800013ca:	00 00 00 
    tss.RSP0 = (uint64_t)stack + sizeof(stack);
ffffffff800013cd:	48 c7 05 6c e1 00 00 	movq   $0xffffffff8000a120,0xe16c(%rip)        # ffffffff8000f544 <tss+0x4>
ffffffff800013d4:	20 a1 00 80 
    tss.RSP2 = (uint64_t)rsp2stack + sizeof(rsp2stack);
ffffffff800013d8:	48 c7 05 71 e1 00 00 	movq   $0xffffffff8000f520,0xe171(%rip)        # ffffffff8000f554 <tss+0x14>
ffffffff800013df:	20 f5 00 80 
    tss.ist1 = (uint64_t)ist1 + sizeof(ist1);
ffffffff800013e3:	48 c7 05 76 e1 00 00 	movq   $0xffffffff8000d520,0xe176(%rip)        # ffffffff8000f564 <tss+0x24>
ffffffff800013ea:	20 d5 00 80 
    gdtr.base = (uint64_t)&gdt;
ffffffff800013ee:	48 c7 05 29 e1 00 00 	movq   $0xffffffff8000f5c0,0xe129(%rip)        # ffffffff8000f522 <gdtr+0x2>
ffffffff800013f5:	c0 f5 00 80 
    gdtr.limit = sizeof(gdt);
ffffffff800013f9:	66 89 15 20 e1 00 00 	mov    %dx,0xe120(%rip)        # ffffffff8000f520 <gdtr>
    gdt_load((uint64_t*)&gdtr, 0x50);
ffffffff80001400:	e9 fb eb ff ff       	jmpq   ffffffff80000000 <gdt_load>
ffffffff80001405:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000140c:	00 00 00 
ffffffff8000140f:	90                   	nop

ffffffff80001410 <create_descriptor>:

void create_descriptor(uint16_t index, void* isr, uint8_t ist, uint8_t cs, uint8_t attr)
{
    struct idt_entry* entry = &idt[index];

    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80001410:	0f b7 ff             	movzwl %di,%edi
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
    entry->ist = ist;
    entry->kernel_cs = cs;
ffffffff80001413:	0f b6 c9             	movzbl %cl,%ecx
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80001416:	48 c1 e7 04          	shl    $0x4,%rdi
ffffffff8000141a:	48 8d 87 40 f6 00 80 	lea    -0x7fff09c0(%rdi),%rax
ffffffff80001421:	66 89 b7 40 f6 00 80 	mov    %si,-0x7fff09c0(%rdi)
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80001428:	48 89 f7             	mov    %rsi,%rdi
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff8000142b:	48 c1 ee 20          	shr    $0x20,%rsi
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff8000142f:	48 c1 ef 10          	shr    $0x10,%rdi
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80001433:	89 70 08             	mov    %esi,0x8(%rax)
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80001436:	66 89 78 06          	mov    %di,0x6(%rax)
    entry->ist = ist;
ffffffff8000143a:	88 50 04             	mov    %dl,0x4(%rax)
    entry->kernel_cs = cs;
ffffffff8000143d:	66 89 48 02          	mov    %cx,0x2(%rax)
    entry->attributes = attr;
ffffffff80001441:	44 88 40 05          	mov    %r8b,0x5(%rax)
    entry->reserved = 0;
ffffffff80001445:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
}
ffffffff8000144c:	c3                   	retq   
ffffffff8000144d:	0f 1f 00             	nopl   (%rax)

ffffffff80001450 <idt_init>:

void idt_init()
{
ffffffff80001450:	55                   	push   %rbp
    //uint64_t idt_ptr = hh_code_to_phys((uint64_t)&idt[0]);
    idtr.base = (uint64_t)&idt[0];
    idtr.limit = (uint16_t)(sizeof(idt) - 1);
ffffffff80001451:	b9 ff 0f 00 00       	mov    $0xfff,%ecx
ffffffff80001456:	0f b7 3d e3 45 00 00 	movzwl 0x45e3(%rip),%edi        # ffffffff80005a40 <_page_fault_errors+0x40>
ffffffff8000145d:	49 c7 c0 30 f9 00 80 	mov    $0xffffffff8000f930,%r8
ffffffff80001464:	66 89 0d bd e1 00 00 	mov    %cx,0xe1bd(%rip)        # ffffffff8000f628 <idtr>
ffffffff8000146b:	48 c7 c0 40 f6 00 80 	mov    $0xffffffff8000f640,%rax
ffffffff80001472:	48 c7 c1 08 02 00 80 	mov    $0xffffffff80000208,%rcx
    idtr.base = (uint64_t)&idt[0];
ffffffff80001479:	48 c7 05 a6 e1 00 00 	movq   $0xffffffff8000f640,0xe1a6(%rip)        # ffffffff8000f62a <idtr+0x2>
ffffffff80001480:	40 f6 00 80 
{
ffffffff80001484:	48 89 e5             	mov    %rsp,%rbp
ffffffff80001487:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000148e:	00 00 

    for(uint8_t index = 0; index < 47; index++)
    {
        create_descriptor(index, isr_stub_table[index], 0x00, 0x08, 0x8E);
ffffffff80001490:	48 8b 11             	mov    (%rcx),%rdx
    entry->ist = ist;
ffffffff80001493:	66 89 78 04          	mov    %di,0x4(%rax)
    for(uint8_t index = 0; index < 47; index++)
ffffffff80001497:	48 83 c0 10          	add    $0x10,%rax
ffffffff8000149b:	48 83 c1 08          	add    $0x8,%rcx
    entry->reserved = 0;
ffffffff8000149f:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%rax)
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800014a6:	48 89 d6             	mov    %rdx,%rsi
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff800014a9:	66 89 50 f0          	mov    %dx,-0x10(%rax)
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff800014ad:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff800014b1:	89 50 f8             	mov    %edx,-0x8(%rax)
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800014b4:	48 c1 ee 10          	shr    $0x10,%rsi
    entry->kernel_cs = cs;
ffffffff800014b8:	ba 08 00 00 00       	mov    $0x8,%edx
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800014bd:	66 89 70 f6          	mov    %si,-0xa(%rax)
    entry->kernel_cs = cs;
ffffffff800014c1:	66 89 50 f2          	mov    %dx,-0xe(%rax)
    for(uint8_t index = 0; index < 47; index++)
ffffffff800014c5:	49 39 c0             	cmp    %rax,%r8
ffffffff800014c8:	75 c6                	jne    ffffffff80001490 <idt_init+0x40>
    }

    create_descriptor(127, isr_stub_table[48], 0x00, 0x08, 0x8E);
ffffffff800014ca:	48 8b 05 b7 ee ff ff 	mov    -0x1149(%rip),%rax        # ffffffff80000388 <isr_stub_table+0x180>
    entry->kernel_cs = cs;
ffffffff800014d1:	c7 05 57 e9 00 00 08 	movl   $0x8e000008,0xe957(%rip)        # ffffffff8000fe32 <idt+0x7f2>
ffffffff800014d8:	00 00 8e 
    entry->reserved = 0;
ffffffff800014db:	c7 05 57 e9 00 00 00 	movl   $0x0,0xe957(%rip)        # ffffffff8000fe3c <idt+0x7fc>
ffffffff800014e2:	00 00 00 
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff800014e5:	66 89 05 44 e9 00 00 	mov    %ax,0xe944(%rip)        # ffffffff8000fe30 <idt+0x7f0>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800014ec:	48 89 c2             	mov    %rax,%rdx
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff800014ef:	48 c1 e8 20          	shr    $0x20,%rax
ffffffff800014f3:	89 05 3f e9 00 00    	mov    %eax,0xe93f(%rip)        # ffffffff8000fe38 <idt+0x7f8>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800014f9:	48 c1 ea 10          	shr    $0x10,%rdx
    create_descriptor(128, isr_stub_table[49], 0x00, 0x08, 0x8E);
ffffffff800014fd:	48 8b 05 8c ee ff ff 	mov    -0x1174(%rip),%rax        # ffffffff80000390 <isr_stub_table+0x188>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80001504:	66 89 15 2b e9 00 00 	mov    %dx,0xe92b(%rip)        # ffffffff8000fe36 <idt+0x7f6>
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff8000150b:	66 89 05 2e e9 00 00 	mov    %ax,0xe92e(%rip)        # ffffffff8000fe40 <idt+0x800>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80001512:	48 89 c2             	mov    %rax,%rdx
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80001515:	48 c1 e8 20          	shr    $0x20,%rax
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80001519:	48 c1 ea 10          	shr    $0x10,%rdx
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff8000151d:	89 05 25 e9 00 00    	mov    %eax,0xe925(%rip)        # ffffffff8000fe48 <idt+0x808>

    pic_remap();
ffffffff80001523:	31 c0                	xor    %eax,%eax
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80001525:	66 89 15 1a e9 00 00 	mov    %dx,0xe91a(%rip)        # ffffffff8000fe46 <idt+0x806>
    entry->kernel_cs = cs;
ffffffff8000152c:	c7 05 0c e9 00 00 08 	movl   $0x8e000008,0xe90c(%rip)        # ffffffff8000fe42 <idt+0x802>
ffffffff80001533:	00 00 8e 
    entry->reserved = 0;
ffffffff80001536:	c7 05 0c e9 00 00 00 	movl   $0x0,0xe90c(%rip)        # ffffffff8000fe4c <idt+0x80c>
ffffffff8000153d:	00 00 00 
    pic_remap();
ffffffff80001540:	e8 9b f9 ff ff       	callq  ffffffff80000ee0 <pic_remap>
    pic_disable();
ffffffff80001545:	31 c0                	xor    %eax,%eax
ffffffff80001547:	e8 64 f9 ff ff       	callq  ffffffff80000eb0 <pic_disable>

    

    idt_load(&idtr);
ffffffff8000154c:	48 c7 c7 28 f6 00 80 	mov    $0xffffffff8000f628,%rdi
ffffffff80001553:	e8 40 ee ff ff       	callq  ffffffff80000398 <idt_load>

    pit_init(10000);
ffffffff80001558:	bf 10 27 00 00       	mov    $0x2710,%edi
ffffffff8000155d:	e8 7e fa ff ff       	callq  ffffffff80000fe0 <pit_init>

    pic_clear_mask(1);
ffffffff80001562:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff80001567:	e8 04 f9 ff ff       	callq  ffffffff80000e70 <pic_clear_mask>
    pic_clear_mask(0);
ffffffff8000156c:	31 ff                	xor    %edi,%edi
ffffffff8000156e:	e8 fd f8 ff ff       	callq  ffffffff80000e70 <pic_clear_mask>

    serial_printf(SERIAL_PORT1, "IDT: %p\n", (uint64_t)&idt);
ffffffff80001573:	48 c7 c2 40 f6 00 80 	mov    $0xffffffff8000f640,%rdx
ffffffff8000157a:	31 c0                	xor    %eax,%eax

    //__asm__ volatile ("lidt %0" : : "m"(idtr));
    //__asm__ volatile ("sti");
}
ffffffff8000157c:	5d                   	pop    %rbp
    serial_printf(SERIAL_PORT1, "IDT: %p\n", (uint64_t)&idt);
ffffffff8000157d:	48 c7 c6 5a 56 00 80 	mov    $0xffffffff8000565a,%rsi
ffffffff80001584:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80001589:	e9 f2 2e 00 00       	jmpq   ffffffff80004480 <serial_printf>
ffffffff8000158e:	66 90                	xchg   %ax,%ax

ffffffff80001590 <interrupt_handler>:

uint64_t interrupt_handler(uint64_t rsp)
{
ffffffff80001590:	55                   	push   %rbp
ffffffff80001591:	48 89 e5             	mov    %rsp,%rbp
ffffffff80001594:	41 54                	push   %r12
ffffffff80001596:	53                   	push   %rbx
    struct interrupt_stack_frame* frame = (struct interrupt_stack_frame*)rsp;
    
    if(frame->int_no < 32)
ffffffff80001597:	48 8b 77 78          	mov    0x78(%rdi),%rsi
{
ffffffff8000159b:	48 89 fb             	mov    %rdi,%rbx
    if(frame->int_no < 32)
ffffffff8000159e:	48 83 fe 1f          	cmp    $0x1f,%rsi
ffffffff800015a2:	77 1c                	ja     ffffffff800015c0 <interrupt_handler+0x30>
    {
        if(frame->cs == 0x08)
ffffffff800015a4:	48 83 bf 90 00 00 00 	cmpq   $0x8,0x90(%rdi)
ffffffff800015ab:	08 
ffffffff800015ac:	74 32                	je     ffffffff800015e0 <interrupt_handler+0x50>
    {
        printf("Syscall 127\n");
        return rsp;
    }
    return rsp;
ffffffff800015ae:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
ffffffff800015b2:	48 89 d8             	mov    %rbx,%rax
ffffffff800015b5:	5b                   	pop    %rbx
ffffffff800015b6:	41 5c                	pop    %r12
ffffffff800015b8:	5d                   	pop    %rbp
ffffffff800015b9:	c3                   	retq   
ffffffff800015ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    else if (frame->int_no < 48)
ffffffff800015c0:	48 83 fe 2f          	cmp    $0x2f,%rsi
ffffffff800015c4:	0f 86 06 02 00 00    	jbe    ffffffff800017d0 <interrupt_handler+0x240>
    else if (frame->int_no == 127)
ffffffff800015ca:	48 83 fe 7f          	cmp    $0x7f,%rsi
ffffffff800015ce:	75 de                	jne    ffffffff800015ae <interrupt_handler+0x1e>
        printf("Syscall 127\n");
ffffffff800015d0:	48 c7 c7 89 56 00 80 	mov    $0xffffffff80005689,%rdi
ffffffff800015d7:	31 c0                	xor    %eax,%eax
ffffffff800015d9:	e8 e2 2c 00 00       	callq  ffffffff800042c0 <printf_>
        return rsp;
ffffffff800015de:	eb ce                	jmp    ffffffff800015ae <interrupt_handler+0x1e>
            uint64_t cr2 = read_cr2();
ffffffff800015e0:	31 c0                	xor    %eax,%eax
ffffffff800015e2:	e8 49 ea ff ff       	callq  ffffffff80000030 <read_cr2>
            serial_printf(SERIAL_PORT1, "CPU Exception: %d  ERR %x  CR2 %p\r\n", frame->int_no, frame->err_no, cr2);
ffffffff800015e7:	48 8b 8b 80 00 00 00 	mov    0x80(%rbx),%rcx
ffffffff800015ee:	48 8b 53 78          	mov    0x78(%rbx),%rdx
ffffffff800015f2:	48 c7 c6 08 58 00 80 	mov    $0xffffffff80005808,%rsi
ffffffff800015f9:	49 89 c0             	mov    %rax,%r8
ffffffff800015fc:	bf f8 03 00 00       	mov    $0x3f8,%edi
            uint64_t cr2 = read_cr2();
ffffffff80001601:	49 89 c4             	mov    %rax,%r12
            serial_printf(SERIAL_PORT1, "CPU Exception: %d  ERR %x  CR2 %p\r\n", frame->int_no, frame->err_no, cr2);
ffffffff80001604:	31 c0                	xor    %eax,%eax
ffffffff80001606:	e8 75 2e 00 00       	callq  ffffffff80004480 <serial_printf>
            serial_printf(SERIAL_PORT1, _exception_messages[frame->int_no]);
ffffffff8000160b:	48 8b 43 78          	mov    0x78(%rbx),%rax
ffffffff8000160f:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80001614:	48 8b 34 c5 00 59 00 	mov    -0x7fffa700(,%rax,8),%rsi
ffffffff8000161b:	80 
ffffffff8000161c:	31 c0                	xor    %eax,%eax
ffffffff8000161e:	e8 5d 2e 00 00       	callq  ffffffff80004480 <serial_printf>
            serial_printf(SERIAL_PORT1, "\n");
ffffffff80001623:	31 c0                	xor    %eax,%eax
ffffffff80001625:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000162a:	48 c7 c6 d1 5b 00 80 	mov    $0xffffffff80005bd1,%rsi
ffffffff80001631:	e8 4a 2e 00 00       	callq  ffffffff80004480 <serial_printf>
            if (frame->int_no == 0xE) 
ffffffff80001636:	48 83 7b 78 0e       	cmpq   $0xe,0x78(%rbx)
ffffffff8000163b:	0f 84 fc 01 00 00    	je     ffffffff8000183d <interrupt_handler+0x2ad>
            serial_printf(SERIAL_PORT1, "SS: %x  RSP: %x  RFLAGS: %x  CS: %x  RIP: %x\n", frame->ss, frame->rsp, frame->rflags, frame->cs, frame->rip);
ffffffff80001641:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80001645:	48 8b 8b a0 00 00 00 	mov    0xa0(%rbx),%rcx
ffffffff8000164c:	31 c0                	xor    %eax,%eax
ffffffff8000164e:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80001653:	48 8b 93 a8 00 00 00 	mov    0xa8(%rbx),%rdx
ffffffff8000165a:	ff b3 88 00 00 00    	pushq  0x88(%rbx)
ffffffff80001660:	48 c7 c6 30 58 00 80 	mov    $0xffffffff80005830,%rsi
ffffffff80001667:	4c 8b 8b 90 00 00 00 	mov    0x90(%rbx),%r9
ffffffff8000166e:	4c 8b 83 98 00 00 00 	mov    0x98(%rbx),%r8
ffffffff80001675:	e8 06 2e 00 00       	callq  ffffffff80004480 <serial_printf>
            serial_printf(SERIAL_PORT1, "rax: %x  rbx: %x  rcx: %x  rdx: %x  rsi: %x  rdi: %x\n", frame->rax, frame->rbx, frame->rcx, frame->rdx, frame->rsi, frame->rdi);
ffffffff8000167a:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff8000167e:	48 8b 53 70          	mov    0x70(%rbx),%rdx
ffffffff80001682:	ff 73 48             	pushq  0x48(%rbx)
ffffffff80001685:	ff 73 50             	pushq  0x50(%rbx)
ffffffff80001688:	31 c0                	xor    %eax,%eax
ffffffff8000168a:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000168f:	48 c7 c6 60 58 00 80 	mov    $0xffffffff80005860,%rsi
ffffffff80001696:	4c 8b 4b 58          	mov    0x58(%rbx),%r9
ffffffff8000169a:	4c 8b 43 60          	mov    0x60(%rbx),%r8
ffffffff8000169e:	e8 dd 2d 00 00       	callq  ffffffff80004480 <serial_printf>
            serial_printf(SERIAL_PORT1, "r8: %x  r9: %x  r10: %x  r11: %x  r12: %x  r13: %x\n", frame->r8, frame->r9, frame->r10, frame->r11, frame->r12, frame->r13);
ffffffff800016a3:	48 83 c4 20          	add    $0x20,%rsp
ffffffff800016a7:	48 8b 4b 30          	mov    0x30(%rbx),%rcx
ffffffff800016ab:	31 c0                	xor    %eax,%eax
ffffffff800016ad:	48 8b 53 38          	mov    0x38(%rbx),%rdx
ffffffff800016b1:	ff 73 10             	pushq  0x10(%rbx)
ffffffff800016b4:	48 c7 c6 98 58 00 80 	mov    $0xffffffff80005898,%rsi
ffffffff800016bb:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800016c0:	ff 73 18             	pushq  0x18(%rbx)
ffffffff800016c3:	4c 8b 4b 20          	mov    0x20(%rbx),%r9
ffffffff800016c7:	4c 8b 43 28          	mov    0x28(%rbx),%r8
ffffffff800016cb:	e8 b0 2d 00 00       	callq  ffffffff80004480 <serial_printf>
            serial_printf(SERIAL_PORT1, "r14: %x  r15: %x\n", frame->r14, frame->r15);
ffffffff800016d0:	48 8b 0b             	mov    (%rbx),%rcx
ffffffff800016d3:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff800016d7:	31 c0                	xor    %eax,%eax
ffffffff800016d9:	48 c7 c6 63 56 00 80 	mov    $0xffffffff80005663,%rsi
ffffffff800016e0:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800016e5:	e8 96 2d 00 00       	callq  ffffffff80004480 <serial_printf>
            printf("\nCPU Exception! INT %d   ERR %x  CR2 %p\n", frame->int_no, frame->err_no, cr2);
ffffffff800016ea:	48 8b 73 78          	mov    0x78(%rbx),%rsi
ffffffff800016ee:	4c 89 e1             	mov    %r12,%rcx
ffffffff800016f1:	31 c0                	xor    %eax,%eax
ffffffff800016f3:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
ffffffff800016fa:	48 c7 c7 d0 58 00 80 	mov    $0xffffffff800058d0,%rdi
ffffffff80001701:	e8 ba 2b 00 00       	callq  ffffffff800042c0 <printf_>
            printf(_exception_messages[frame->int_no]);
ffffffff80001706:	48 8b 43 78          	mov    0x78(%rbx),%rax
ffffffff8000170a:	48 8b 3c c5 00 59 00 	mov    -0x7fffa700(,%rax,8),%rdi
ffffffff80001711:	80 
ffffffff80001712:	31 c0                	xor    %eax,%eax
ffffffff80001714:	e8 a7 2b 00 00       	callq  ffffffff800042c0 <printf_>
            printf("\n");
ffffffff80001719:	48 c7 c7 d1 5b 00 80 	mov    $0xffffffff80005bd1,%rdi
ffffffff80001720:	31 c0                	xor    %eax,%eax
ffffffff80001722:	e8 99 2b 00 00       	callq  ffffffff800042c0 <printf_>
            if (frame->int_no == 0xE) 
ffffffff80001727:	48 83 7b 78 0e       	cmpq   $0xe,0x78(%rbx)
ffffffff8000172c:	5e                   	pop    %rsi
ffffffff8000172d:	5f                   	pop    %rdi
ffffffff8000172e:	0f 84 e0 00 00 00    	je     ffffffff80001814 <interrupt_handler+0x284>
            printf("SS: %x  RSP: %x  RFLAGS: %x  CS: %x  RIP: %x\n", frame->ss, frame->rsp, frame->rflags, frame->cs, frame->rip);
ffffffff80001734:	48 8b 8b 98 00 00 00 	mov    0x98(%rbx),%rcx
ffffffff8000173b:	48 8b 93 a0 00 00 00 	mov    0xa0(%rbx),%rdx
ffffffff80001742:	31 c0                	xor    %eax,%eax
ffffffff80001744:	48 c7 c7 30 58 00 80 	mov    $0xffffffff80005830,%rdi
ffffffff8000174b:	48 8b b3 a8 00 00 00 	mov    0xa8(%rbx),%rsi
ffffffff80001752:	4c 8b 8b 88 00 00 00 	mov    0x88(%rbx),%r9
ffffffff80001759:	4c 8b 83 90 00 00 00 	mov    0x90(%rbx),%r8
ffffffff80001760:	e8 5b 2b 00 00       	callq  ffffffff800042c0 <printf_>
            printf("rax: %x  rbx: %x  rcx: %x  rdx: %x  rsi: %x  rdi: %x\n", frame->rax, frame->rbx, frame->rcx, frame->rdx, frame->rsi, frame->rdi);
ffffffff80001765:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80001769:	48 8b 4b 60          	mov    0x60(%rbx),%rcx
ffffffff8000176d:	31 c0                	xor    %eax,%eax
ffffffff8000176f:	48 8b 53 68          	mov    0x68(%rbx),%rdx
ffffffff80001773:	48 8b 73 70          	mov    0x70(%rbx),%rsi
ffffffff80001777:	ff 73 48             	pushq  0x48(%rbx)
ffffffff8000177a:	48 c7 c7 60 58 00 80 	mov    $0xffffffff80005860,%rdi
ffffffff80001781:	4c 8b 4b 50          	mov    0x50(%rbx),%r9
ffffffff80001785:	4c 8b 43 58          	mov    0x58(%rbx),%r8
ffffffff80001789:	e8 32 2b 00 00       	callq  ffffffff800042c0 <printf_>
            printf("r8: %x  r9: %x  r10: %x  r11: %x  r12: %x  r13: %x\n", frame->r8, frame->r9, frame->r10, frame->r11, frame->r12, frame->r13);
ffffffff8000178e:	58                   	pop    %rax
ffffffff8000178f:	48 8b 4b 28          	mov    0x28(%rbx),%rcx
ffffffff80001793:	31 c0                	xor    %eax,%eax
ffffffff80001795:	48 8b 53 30          	mov    0x30(%rbx),%rdx
ffffffff80001799:	48 8b 73 38          	mov    0x38(%rbx),%rsi
ffffffff8000179d:	ff 73 10             	pushq  0x10(%rbx)
ffffffff800017a0:	48 c7 c7 98 58 00 80 	mov    $0xffffffff80005898,%rdi
ffffffff800017a7:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff800017ab:	4c 8b 43 20          	mov    0x20(%rbx),%r8
ffffffff800017af:	e8 0c 2b 00 00       	callq  ffffffff800042c0 <printf_>
            printf("r14: %x  r15: %x\n", frame->r14, frame->r15);
ffffffff800017b4:	48 8b 13             	mov    (%rbx),%rdx
ffffffff800017b7:	48 8b 73 08          	mov    0x8(%rbx),%rsi
ffffffff800017bb:	31 c0                	xor    %eax,%eax
ffffffff800017bd:	48 c7 c7 63 56 00 80 	mov    $0xffffffff80005663,%rdi
ffffffff800017c4:	e8 f7 2a 00 00       	callq  ffffffff800042c0 <printf_>
            asm("cli");
ffffffff800017c9:	fa                   	cli    
            asm("hlt");
ffffffff800017ca:	f4                   	hlt    
ffffffff800017cb:	5a                   	pop    %rdx
ffffffff800017cc:	59                   	pop    %rcx
            for(;;);
ffffffff800017cd:	eb fe                	jmp    ffffffff800017cd <interrupt_handler+0x23d>
ffffffff800017cf:	90                   	nop
        uint64_t irq = frame->int_no - 32;
ffffffff800017d0:	4c 8d 66 e0          	lea    -0x20(%rsi),%r12
        if(irq > 1)
ffffffff800017d4:	49 83 fc 01          	cmp    $0x1,%r12
ffffffff800017d8:	77 27                	ja     ffffffff80001801 <interrupt_handler+0x271>
        switch(irq)
ffffffff800017da:	74 1c                	je     ffffffff800017f8 <interrupt_handler+0x268>
                pit_ticks++;
ffffffff800017dc:	48 83 05 3c de 00 00 	addq   $0x1,0xde3c(%rip)        # ffffffff8000f620 <pit_ticks>
ffffffff800017e3:	01 
        pic_EOI(irq);
ffffffff800017e4:	44 89 e7             	mov    %r12d,%edi
ffffffff800017e7:	e8 f4 f5 ff ff       	callq  ffffffff80000de0 <pic_EOI>
ffffffff800017ec:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
ffffffff800017f0:	48 89 d8             	mov    %rbx,%rax
ffffffff800017f3:	5b                   	pop    %rbx
ffffffff800017f4:	41 5c                	pop    %r12
ffffffff800017f6:	5d                   	pop    %rbp
ffffffff800017f7:	c3                   	retq   
                kbd_handle();
ffffffff800017f8:	31 c0                	xor    %eax,%eax
ffffffff800017fa:	e8 21 f5 ff ff       	callq  ffffffff80000d20 <kbd_handle>
                break;
ffffffff800017ff:	eb e3                	jmp    ffffffff800017e4 <interrupt_handler+0x254>
            printf("INT: %d  IRQ: %d  \n", frame->int_no, irq);
ffffffff80001801:	4c 89 e2             	mov    %r12,%rdx
ffffffff80001804:	48 c7 c7 75 56 00 80 	mov    $0xffffffff80005675,%rdi
ffffffff8000180b:	31 c0                	xor    %eax,%eax
ffffffff8000180d:	e8 ae 2a 00 00       	callq  ffffffff800042c0 <printf_>
        switch(irq)
ffffffff80001812:	eb d0                	jmp    ffffffff800017e4 <interrupt_handler+0x254>
                printf(_page_fault_errors[frame->err_no]);
ffffffff80001814:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
ffffffff8000181b:	48 8b 3c c5 00 5a 00 	mov    -0x7fffa600(,%rax,8),%rdi
ffffffff80001822:	80 
ffffffff80001823:	31 c0                	xor    %eax,%eax
ffffffff80001825:	e8 96 2a 00 00       	callq  ffffffff800042c0 <printf_>
                printf("\n");
ffffffff8000182a:	48 c7 c7 d1 5b 00 80 	mov    $0xffffffff80005bd1,%rdi
ffffffff80001831:	31 c0                	xor    %eax,%eax
ffffffff80001833:	e8 88 2a 00 00       	callq  ffffffff800042c0 <printf_>
ffffffff80001838:	e9 f7 fe ff ff       	jmpq   ffffffff80001734 <interrupt_handler+0x1a4>
                serial_printf(SERIAL_PORT1, _page_fault_errors[frame->err_no]);
ffffffff8000183d:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
ffffffff80001844:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80001849:	48 8b 34 c5 00 5a 00 	mov    -0x7fffa600(,%rax,8),%rsi
ffffffff80001850:	80 
ffffffff80001851:	31 c0                	xor    %eax,%eax
ffffffff80001853:	e8 28 2c 00 00       	callq  ffffffff80004480 <serial_printf>
                serial_printf(SERIAL_PORT1, "\n");
ffffffff80001858:	48 c7 c6 d1 5b 00 80 	mov    $0xffffffff80005bd1,%rsi
ffffffff8000185f:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80001864:	31 c0                	xor    %eax,%eax
ffffffff80001866:	e8 15 2c 00 00       	callq  ffffffff80004480 <serial_printf>
ffffffff8000186b:	e9 d1 fd ff ff       	jmpq   ffffffff80001641 <interrupt_handler+0xb1>

ffffffff80001870 <outb>:
#include <stdint.h>
#include <stddef.h>

void outb(uint16_t port, uint8_t val)
{
    asm volatile ( "outb %0, %1" : : "a"(val), "Nd"(port) );
ffffffff80001870:	89 f0                	mov    %esi,%eax
ffffffff80001872:	89 fa                	mov    %edi,%edx
ffffffff80001874:	ee                   	out    %al,(%dx)
}
ffffffff80001875:	c3                   	retq   
ffffffff80001876:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000187d:	00 00 00 

ffffffff80001880 <inb>:

uint8_t inb(uint16_t port)
{
    uint8_t ret;
    asm volatile ( "inb %1, %0"
ffffffff80001880:	89 fa                	mov    %edi,%edx
ffffffff80001882:	ec                   	in     (%dx),%al
                   : "=a"(ret)
                   : "Nd"(port) );
    return ret;
}
ffffffff80001883:	c3                   	retq   
ffffffff80001884:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000188b:	00 00 00 00 
ffffffff8000188f:	90                   	nop

ffffffff80001890 <io_wait>:
    asm volatile ( "inb %1, %0"
ffffffff80001890:	e4 80                	in     $0x80,%al

void io_wait()
{
    inb(0x80);
ffffffff80001892:	c3                   	retq   
ffffffff80001893:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000189a:	00 00 00 
ffffffff8000189d:	0f 1f 00             	nopl   (%rax)

ffffffff800018a0 <kernel>:
#include <cpuid.h>

uint32_t test = 0xdeadbeef;

void kernel()
{
ffffffff800018a0:	55                   	push   %rbp
    //printf("Kernel Now\n");
    serial_init(0x3F8);     //COM1
ffffffff800018a1:	bf f8 03 00 00       	mov    $0x3f8,%edi
{
ffffffff800018a6:	48 89 e5             	mov    %rsp,%rbp
ffffffff800018a9:	41 54                	push   %r12
ffffffff800018ab:	53                   	push   %rbx
    serial_init(0x3F8);     //COM1
ffffffff800018ac:	e8 8f f7 ff ff       	callq  ffffffff80001040 <serial_init>
    gdt_init();
ffffffff800018b1:	31 c0                	xor    %eax,%eax
ffffffff800018b3:	e8 18 fa ff ff       	callq  ffffffff800012d0 <gdt_init>
    idt_init();
ffffffff800018b8:	31 c0                	xor    %eax,%eax
ffffffff800018ba:	e8 91 fb ff ff       	callq  ffffffff80001450 <idt_init>
    fb_init();
ffffffff800018bf:	31 c0                	xor    %eax,%eax
ffffffff800018c1:	e8 1a f3 ff ff       	callq  ffffffff80000be0 <fb_init>
    console_init();
ffffffff800018c6:	31 c0                	xor    %eax,%eax
ffffffff800018c8:	e8 b3 f1 ff ff       	callq  ffffffff80000a80 <console_init>

    pmm_init();
ffffffff800018cd:	31 c0                	xor    %eax,%eax
ffffffff800018cf:	e8 7c 08 00 00       	callq  ffffffff80002150 <pmm_init>
    vmm_init();
ffffffff800018d4:	31 c0                	xor    %eax,%eax
ffffffff800018d6:	e8 a5 15 00 00       	callq  ffffffff80002e80 <vmm_init>

    //user_init();
    

    uint64_t a,b,c,d;
    __cpuid(0x80000000, a, b, c, d);
ffffffff800018db:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff800018e0:	0f a2                	cpuid  

    printf("80000000: %x\n", a);
ffffffff800018e2:	48 c7 c7 42 5a 00 80 	mov    $0xffffffff80005a42,%rdi
    __cpuid(0x80000000, a, b, c, d);
ffffffff800018e9:	49 89 d4             	mov    %rdx,%r12
    printf("80000000: %x\n", a);
ffffffff800018ec:	48 89 c6             	mov    %rax,%rsi
ffffffff800018ef:	31 c0                	xor    %eax,%eax
ffffffff800018f1:	e8 ca 29 00 00       	callq  ffffffff800042c0 <printf_>

    uint64_t pagesize_1g = d && (1 << 26);
ffffffff800018f6:	31 f6                	xor    %esi,%esi
ffffffff800018f8:	4d 85 e4             	test   %r12,%r12
    printf("1GB Pages: %x\n", pagesize_1g);
ffffffff800018fb:	48 c7 c7 50 5a 00 80 	mov    $0xffffffff80005a50,%rdi
    uint64_t pagesize_1g = d && (1 << 26);
ffffffff80001902:	40 0f 95 c6          	setne  %sil
    printf("1GB Pages: %x\n", pagesize_1g);
ffffffff80001906:	31 c0                	xor    %eax,%eax
ffffffff80001908:	e8 b3 29 00 00       	callq  ffffffff800042c0 <printf_>

    __cpuid(0x80000001, a, b, c, d);
ffffffff8000190d:	b8 01 00 00 80       	mov    $0x80000001,%eax
ffffffff80001912:	0f a2                	cpuid  
    printf("a: %x  b: %x  c: %x  d: %x\n", a,b,c,d);
ffffffff80001914:	48 c7 c7 5f 5a 00 80 	mov    $0xffffffff80005a5f,%rdi
    __cpuid(0x80000001, a, b, c, d);
ffffffff8000191b:	49 89 d0             	mov    %rdx,%r8
    printf("a: %x  b: %x  c: %x  d: %x\n", a,b,c,d);
ffffffff8000191e:	48 89 c6             	mov    %rax,%rsi
    __cpuid(0x80000001, a, b, c, d);
ffffffff80001921:	49 89 c4             	mov    %rax,%r12
    printf("a: %x  b: %x  c: %x  d: %x\n", a,b,c,d);
ffffffff80001924:	48 89 da             	mov    %rbx,%rdx
ffffffff80001927:	31 c0                	xor    %eax,%eax
ffffffff80001929:	e8 92 29 00 00       	callq  ffffffff800042c0 <printf_>
    uint64_t phys_addr_width = (a & 0xFF);
    printf("Phys Addr Width: %x\n", phys_addr_width);
ffffffff8000192e:	48 c7 c7 7b 5a 00 80 	mov    $0xffffffff80005a7b,%rdi
    uint64_t phys_addr_width = (a & 0xFF);
ffffffff80001935:	41 0f b6 f4          	movzbl %r12b,%esi
    printf("Phys Addr Width: %x\n", phys_addr_width);
ffffffff80001939:	31 c0                	xor    %eax,%eax
ffffffff8000193b:	e8 80 29 00 00       	callq  ffffffff800042c0 <printf_>

    



    printf("Kernel Done!\n"); 
ffffffff80001940:	48 c7 c7 90 5a 00 80 	mov    $0xffffffff80005a90,%rdi
ffffffff80001947:	31 c0                	xor    %eax,%eax
ffffffff80001949:	e8 72 29 00 00       	callq  ffffffff800042c0 <printf_>

    while(true)
ffffffff8000194e:	eb fe                	jmp    ffffffff8000194e <kernel+0xae>

ffffffff80001950 <allocate_new_page>:


// ***************************************************************

static struct liballoc_major *allocate_new_page( unsigned int size )
{
ffffffff80001950:	55                   	push   %rbp
	unsigned int st;
	struct liballoc_major *maj;

		// This is how much space is required.
		st  = size + sizeof(struct liballoc_major);
		st += sizeof(struct liballoc_minor);
ffffffff80001951:	83 c7 50             	add    $0x50,%edi

				// Perfect amount of space?
		if ( (st % l_pageSize) == 0 )
ffffffff80001954:	ba 10 00 00 00       	mov    $0x10,%edx
			st  = st / (l_pageSize);
ffffffff80001959:	89 f8                	mov    %edi,%eax
		if ( (st % l_pageSize) == 0 )
ffffffff8000195b:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
			st  = st / (l_pageSize);
ffffffff80001961:	c1 e8 0c             	shr    $0xc,%eax
{
ffffffff80001964:	48 89 e5             	mov    %rsp,%rbp
ffffffff80001967:	53                   	push   %rbx
ffffffff80001968:	48 83 ec 08          	sub    $0x8,%rsp
		else
			st  = st / (l_pageSize) + 1;
ffffffff8000196c:	83 ff 01             	cmp    $0x1,%edi
ffffffff8000196f:	83 d8 ff             	sbb    $0xffffffff,%eax
							// No, add the buffer. 

		
		// Make sure it's >= the minimum size.
		if ( st < l_pageCount ) st = l_pageCount;
ffffffff80001972:	39 d0                	cmp    %edx,%eax
ffffffff80001974:	0f 43 d0             	cmovae %eax,%edx
ffffffff80001977:	89 d7                	mov    %edx,%edi
ffffffff80001979:	48 89 fb             	mov    %rdi,%rbx
		
		maj = (struct liballoc_major*)liballoc_alloc( st );
ffffffff8000197c:	e8 3f 07 00 00       	callq  ffffffff800020c0 <liballoc_alloc>

		if ( maj == NULL ) 
ffffffff80001981:	48 85 c0             	test   %rax,%rax
ffffffff80001984:	74 3a                	je     ffffffff800019c0 <allocate_new_page+0x70>
			return NULL;	// uh oh, we ran out of memory.
		}
		
		maj->prev 	= NULL;
		maj->next 	= NULL;
		maj->pages 	= st;
ffffffff80001986:	89 58 10             	mov    %ebx,0x10(%rax)
		maj->size 	= st * l_pageSize;
ffffffff80001989:	c1 e3 0c             	shl    $0xc,%ebx
		maj->usage 	= sizeof(struct liballoc_major);
		maj->first 	= NULL;

		l_allocated += maj->size;
ffffffff8000198c:	48 01 1d cd ec 00 00 	add    %rbx,0xeccd(%rip)        # ffffffff80010660 <l_allocated>
		maj->prev 	= NULL;
ffffffff80001993:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		maj->next 	= NULL;
ffffffff8000199a:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff800019a1:	00 
		maj->size 	= st * l_pageSize;
ffffffff800019a2:	89 58 14             	mov    %ebx,0x14(%rax)
		maj->usage 	= sizeof(struct liballoc_major);
ffffffff800019a5:	c7 40 18 28 00 00 00 	movl   $0x28,0x18(%rax)
		maj->first 	= NULL;
ffffffff800019ac:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff800019b3:	00 
		FLUSH();
		#endif
	
		
      return maj;
}
ffffffff800019b4:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
ffffffff800019b8:	c9                   	leaveq 
ffffffff800019b9:	c3                   	retq   
ffffffff800019ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			l_warningCount += 1;
ffffffff800019c0:	48 83 05 88 ec 00 00 	addq   $0x1,0xec88(%rip)        # ffffffff80010650 <l_warningCount>
ffffffff800019c7:	01 
			return NULL;	// uh oh, we ran out of memory.
ffffffff800019c8:	eb ea                	jmp    ffffffff800019b4 <allocate_new_page+0x64>
ffffffff800019ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff800019d0 <kmalloc>:

	


void *PREFIX(malloc)(size_t req_size)
{
ffffffff800019d0:	55                   	push   %rbp
		size += ALIGNMENT + ALIGN_INFO;
	}
				// So, ideally, we really want an alignment of 0 or 1 in order
				// to save space.
	
	liballoc_lock();
ffffffff800019d1:	31 c0                	xor    %eax,%eax
{
ffffffff800019d3:	48 89 e5             	mov    %rsp,%rbp
ffffffff800019d6:	41 57                	push   %r15
ffffffff800019d8:	41 56                	push   %r14
		size += ALIGNMENT + ALIGN_INFO;
ffffffff800019da:	4c 8d 77 20          	lea    0x20(%rdi),%r14
{
ffffffff800019de:	41 55                	push   %r13
ffffffff800019e0:	49 89 fd             	mov    %rdi,%r13
ffffffff800019e3:	41 54                	push   %r12
ffffffff800019e5:	53                   	push   %rbx
ffffffff800019e6:	48 83 ec 18          	sub    $0x18,%rsp
	liballoc_lock();
ffffffff800019ea:	e8 a1 06 00 00       	callq  ffffffff80002090 <liballoc_lock>

	if ( size == 0 )
ffffffff800019ef:	4d 85 f6             	test   %r14,%r14
ffffffff800019f2:	75 22                	jne    ffffffff80001a16 <kmalloc+0x46>
		#if defined DEBUG || defined INFO
		printf( "liballoc: WARNING: alloc( 0 ) called from %x\n",
							__builtin_return_address(0) );
		FLUSH();
		#endif
		liballoc_unlock();
ffffffff800019f4:	31 c0                	xor    %eax,%eax
		l_warningCount += 1;
ffffffff800019f6:	48 83 05 52 ec 00 00 	addq   $0x1,0xec52(%rip)        # ffffffff80010650 <l_warningCount>
ffffffff800019fd:	01 
		size += ALIGNMENT + ALIGN_INFO;
ffffffff800019fe:	41 be 21 00 00 00    	mov    $0x21,%r14d
		return PREFIX(malloc)(1);
ffffffff80001a04:	41 bd 01 00 00 00    	mov    $0x1,%r13d
		liballoc_unlock();
ffffffff80001a0a:	e8 91 06 00 00       	callq  ffffffff800020a0 <liballoc_unlock>
	liballoc_lock();
ffffffff80001a0f:	31 c0                	xor    %eax,%eax
ffffffff80001a11:	e8 7a 06 00 00       	callq  ffffffff80002090 <liballoc_lock>
	}
	

	if ( l_memRoot == NULL )
ffffffff80001a16:	48 8b 05 53 ec 00 00 	mov    0xec53(%rip),%rax        # ffffffff80010670 <l_memRoot>
ffffffff80001a1d:	48 85 c0             	test   %rax,%rax
ffffffff80001a20:	0f 84 49 02 00 00    	je     ffffffff80001c6f <kmalloc+0x29f>

	maj = l_memRoot;
	startedBet = 0;
	
	// Start at the best bet....
	if ( l_bestBet != NULL )
ffffffff80001a26:	48 8b 1d 3b ec 00 00 	mov    0xec3b(%rip),%rbx        # ffffffff80010668 <l_bestBet>
	{
		bestSize = l_bestBet->size - l_bestBet->usage;

		if ( bestSize > (size + sizeof(struct liballoc_minor)))
ffffffff80001a2d:	4d 8d 65 48          	lea    0x48(%r13),%r12
	if ( l_bestBet != NULL )
ffffffff80001a31:	48 85 db             	test   %rbx,%rbx
ffffffff80001a34:	0f 84 ee 01 00 00    	je     ffffffff80001c28 <kmalloc+0x258>
		bestSize = l_bestBet->size - l_bestBet->usage;
ffffffff80001a3a:	8b 53 14             	mov    0x14(%rbx),%edx
ffffffff80001a3d:	8b 4b 18             	mov    0x18(%rbx),%ecx
		{
			maj = l_bestBet;
			startedBet = 1;
ffffffff80001a40:	41 b8 01 00 00 00    	mov    $0x1,%r8d
		bestSize = l_bestBet->size - l_bestBet->usage;
ffffffff80001a46:	41 89 d7             	mov    %edx,%r15d
ffffffff80001a49:	41 29 cf             	sub    %ecx,%r15d
		if ( bestSize > (size + sizeof(struct liballoc_minor)))
ffffffff80001a4c:	4d 39 fc             	cmp    %r15,%r12
ffffffff80001a4f:	0f 83 bb 01 00 00    	jae    ffffffff80001c10 <kmalloc+0x240>
		}
	}
	
	while ( maj != NULL )
	{
		diff  = maj->size - maj->usage;	
ffffffff80001a55:	89 d0                	mov    %edx,%eax
ffffffff80001a57:	29 c8                	sub    %ecx,%eax
										// free memory in the block

		if ( bestSize < diff )
ffffffff80001a59:	49 39 c7             	cmp    %rax,%r15
ffffffff80001a5c:	73 0a                	jae    ffffffff80001a68 <kmalloc+0x98>
		{
			// Hmm.. this one has more memory then our bestBet. Remember!
			l_bestBet = maj;
ffffffff80001a5e:	48 89 1d 03 ec 00 00 	mov    %rbx,0xec03(%rip)        # ffffffff80010668 <l_bestBet>
ffffffff80001a65:	49 89 c7             	mov    %rax,%r15
		
		
#ifdef USE_CASE1
			
		// CASE 1:  There is not enough space in this major block.
		if ( diff < (size + sizeof( struct liballoc_minor )) )
ffffffff80001a68:	4c 39 e0             	cmp    %r12,%rax
ffffffff80001a6b:	73 24                	jae    ffffffff80001a91 <kmalloc+0xc1>
			printf( "CASE 1: Insufficient space in block %x\n", maj);
			FLUSH();
			#endif
				
				// Another major block next to this one?
			if ( maj->next != NULL ) 
ffffffff80001a6d:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff80001a71:	48 85 c0             	test   %rax,%rax
ffffffff80001a74:	0f 84 26 01 00 00    	je     ffffffff80001ba0 <kmalloc+0x1d0>
		diff  = maj->size - maj->usage;	
ffffffff80001a7a:	8b 50 14             	mov    0x14(%rax),%edx
ffffffff80001a7d:	8b 48 18             	mov    0x18(%rax),%ecx
ffffffff80001a80:	48 89 c3             	mov    %rax,%rbx
ffffffff80001a83:	89 d0                	mov    %edx,%eax
ffffffff80001a85:	29 c8                	sub    %ecx,%eax
		if ( bestSize < diff )
ffffffff80001a87:	49 39 c7             	cmp    %rax,%r15
ffffffff80001a8a:	72 d2                	jb     ffffffff80001a5e <kmalloc+0x8e>
		if ( diff < (size + sizeof( struct liballoc_minor )) )
ffffffff80001a8c:	4c 39 e0             	cmp    %r12,%rax
ffffffff80001a8f:	72 dc                	jb     ffffffff80001a6d <kmalloc+0x9d>
#endif

#ifdef USE_CASE2
		
		// CASE 2: It's a brand new block.
		if ( maj->first == NULL )
ffffffff80001a91:	48 8b 43 20          	mov    0x20(%rbx),%rax
ffffffff80001a95:	48 85 c0             	test   %rax,%rax
ffffffff80001a98:	0f 84 f7 01 00 00    	je     ffffffff80001c95 <kmalloc+0x2c5>
				
#ifdef USE_CASE3

		// CASE 3: Block in use and enough space at the start of the block.
		diff =  (uintptr_t)(maj->first);
		diff -= (uintptr_t)maj;
ffffffff80001a9e:	48 89 c2             	mov    %rax,%rdx
ffffffff80001aa1:	48 29 da             	sub    %rbx,%rdx
		diff -= sizeof(struct liballoc_major);
ffffffff80001aa4:	48 83 ea 28          	sub    $0x28,%rdx

		if ( diff >= (size + sizeof(struct liballoc_minor)) )
ffffffff80001aa8:	4c 39 e2             	cmp    %r12,%rdx
ffffffff80001aab:	0f 83 40 02 00 00    	jae    ffffffff80001cf1 <kmalloc+0x321>
ffffffff80001ab1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		
			// Looping within the block now...
		while ( min != NULL )
		{
				// CASE 4.1: End of minors in a block. Space from last and end?
				if ( min->next == NULL )
ffffffff80001ab8:	48 89 c1             	mov    %rax,%rcx
ffffffff80001abb:	48 8b 40 08          	mov    0x8(%rax),%rax
				{
					// the rest of this block is free...  is it big enough?
					diff = (uintptr_t)(maj) + maj->size;
					diff -= (uintptr_t)min;
					diff -= sizeof( struct liballoc_minor );
					diff -= min->size; 
ffffffff80001abf:	8b 71 1c             	mov    0x1c(%rcx),%esi
				if ( min->next == NULL )
ffffffff80001ac2:	48 85 c0             	test   %rax,%rax
ffffffff80001ac5:	0f 84 85 00 00 00    	je     ffffffff80001b50 <kmalloc+0x180>
				// CASE 4.2: Is there space between two minors?
				if ( min->next != NULL )
				{
					// is the difference between here and next big enough?
					diff  = (uintptr_t)(min->next);
					diff -= (uintptr_t)min;
ffffffff80001acb:	48 89 c2             	mov    %rax,%rdx
ffffffff80001ace:	48 29 ca             	sub    %rcx,%rdx
					diff -= sizeof( struct liballoc_minor );
ffffffff80001ad1:	48 83 ea 28          	sub    $0x28,%rdx
					diff -= min->size;
ffffffff80001ad5:	48 29 f2             	sub    %rsi,%rdx
										// minus our existing usage.

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
ffffffff80001ad8:	4c 39 e2             	cmp    %r12,%rdx
ffffffff80001adb:	72 db                	jb     ffffffff80001ab8 <kmalloc+0xe8>
					{
						// yay......
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff80001add:	48 01 ce             	add    %rcx,%rsi

						new_min->magic = LIBALLOC_MAGIC;
						new_min->next = min->next;
ffffffff80001ae0:	48 89 46 30          	mov    %rax,0x30(%rsi)
						new_min->prev = min;
						new_min->size = size;
						new_min->req_size = req_size;
						new_min->block = maj;
						min->next->prev = new_min;
ffffffff80001ae4:	48 8b 41 08          	mov    0x8(%rcx),%rax
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff80001ae8:	48 8d 56 28          	lea    0x28(%rsi),%rdx
						new_min->magic = LIBALLOC_MAGIC;
ffffffff80001aec:	c7 46 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rsi)
						new_min->prev = min;
ffffffff80001af3:	48 89 4e 28          	mov    %rcx,0x28(%rsi)
						new_min->size = size;
ffffffff80001af7:	44 89 76 44          	mov    %r14d,0x44(%rsi)
						new_min->req_size = req_size;
ffffffff80001afb:	44 89 6e 48          	mov    %r13d,0x48(%rsi)
						new_min->block = maj;
ffffffff80001aff:	48 89 5e 38          	mov    %rbx,0x38(%rsi)
						min->next->prev = new_min;
ffffffff80001b03:	48 89 10             	mov    %rdx,(%rax)
						min->next = new_min;
ffffffff80001b06:	48 89 51 08          	mov    %rdx,0x8(%rcx)
						maj->usage += size + sizeof( struct liballoc_minor );
ffffffff80001b0a:	41 8d 46 28          	lea    0x28(%r14),%eax
						
						l_inuse += size;
ffffffff80001b0e:	4c 01 35 43 eb 00 00 	add    %r14,0xeb43(%rip)        # ffffffff80010658 <l_inuse>
						
						p = (void*)((uintptr_t)new_min + sizeof( struct liballoc_minor ));
						ALIGN( p );
ffffffff80001b15:	48 8d 56 60          	lea    0x60(%rsi),%rdx
						maj->usage += size + sizeof( struct liballoc_minor );
ffffffff80001b19:	01 43 18             	add    %eax,0x18(%rbx)
						ALIGN( p );
ffffffff80001b1c:	83 e6 0f             	and    $0xf,%esi
ffffffff80001b1f:	0f 85 cb 00 00 00    	jne    ffffffff80001bf0 <kmalloc+0x220>
ffffffff80001b25:	48 89 d3             	mov    %rdx,%rbx
ffffffff80001b28:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80001b2d:	88 42 f0             	mov    %al,-0x10(%rdx)
						#ifdef DEBUG
						printf( "CASE 4.2: returning %x\n", p); 
						FLUSH();
						#endif
						
						liballoc_unlock();		// release the lock
ffffffff80001b30:	31 c0                	xor    %eax,%eax
ffffffff80001b32:	e8 69 05 00 00       	callq  ffffffff800020a0 <liballoc_unlock>
	printf( "liballoc: WARNING: PREFIX(malloc)( %i ) returning NULL.\n", size);
	liballoc_dump();
	FLUSH();
	#endif
	return NULL;
}
ffffffff80001b37:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80001b3b:	48 89 d8             	mov    %rbx,%rax
ffffffff80001b3e:	5b                   	pop    %rbx
ffffffff80001b3f:	41 5c                	pop    %r12
ffffffff80001b41:	41 5d                	pop    %r13
ffffffff80001b43:	41 5e                	pop    %r14
ffffffff80001b45:	41 5f                	pop    %r15
ffffffff80001b47:	5d                   	pop    %rbp
ffffffff80001b48:	c3                   	retq   
ffffffff80001b49:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
					diff = (uintptr_t)(maj) + maj->size;
ffffffff80001b50:	8b 43 14             	mov    0x14(%rbx),%eax
					diff -= sizeof( struct liballoc_minor );
ffffffff80001b53:	48 8d 44 03 d8       	lea    -0x28(%rbx,%rax,1),%rax
ffffffff80001b58:	48 29 c8             	sub    %rcx,%rax
					diff -= min->size; 
ffffffff80001b5b:	48 29 f0             	sub    %rsi,%rax
					if ( diff >= (size + sizeof( struct liballoc_minor )) )
ffffffff80001b5e:	4c 39 e0             	cmp    %r12,%rax
ffffffff80001b61:	0f 83 d9 00 00 00    	jae    ffffffff80001c40 <kmalloc+0x270>
		if ( maj->next == NULL ) 
ffffffff80001b67:	48 8b 43 08          	mov    0x8(%rbx),%rax
ffffffff80001b6b:	48 85 c0             	test   %rax,%rax
ffffffff80001b6e:	0f 85 06 ff ff ff    	jne    ffffffff80001a7a <kmalloc+0xaa>
			if ( startedBet == 1 )
ffffffff80001b74:	41 83 f8 01          	cmp    $0x1,%r8d
ffffffff80001b78:	74 2c                	je     ffffffff80001ba6 <kmalloc+0x1d6>
			maj->next = allocate_new_page( size );		// next one guaranteed to be okay
ffffffff80001b7a:	44 89 f7             	mov    %r14d,%edi
ffffffff80001b7d:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
ffffffff80001b81:	e8 ca fd ff ff       	callq  ffffffff80001950 <allocate_new_page>
ffffffff80001b86:	48 89 43 08          	mov    %rax,0x8(%rbx)
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
ffffffff80001b8a:	48 85 c0             	test   %rax,%rax
ffffffff80001b8d:	0f 84 f4 00 00 00    	je     ffffffff80001c87 <kmalloc+0x2b7>
			maj->next->prev = maj;
ffffffff80001b93:	48 89 18             	mov    %rbx,(%rax)
	while ( maj != NULL )
ffffffff80001b96:	44 8b 45 cc          	mov    -0x34(%rbp),%r8d
ffffffff80001b9a:	e9 db fe ff ff       	jmpq   ffffffff80001a7a <kmalloc+0xaa>
ffffffff80001b9f:	90                   	nop
			if ( startedBet == 1 )		// If we started at the best bet,
ffffffff80001ba0:	41 83 f8 01          	cmp    $0x1,%r8d
ffffffff80001ba4:	75 1a                	jne    ffffffff80001bc0 <kmalloc+0x1f0>
				maj = l_memRoot;
ffffffff80001ba6:	48 8b 05 c3 ea 00 00 	mov    0xeac3(%rip),%rax        # ffffffff80010670 <l_memRoot>
	while ( maj != NULL )
ffffffff80001bad:	48 85 c0             	test   %rax,%rax
ffffffff80001bb0:	0f 84 d1 00 00 00    	je     ffffffff80001c87 <kmalloc+0x2b7>
ffffffff80001bb6:	45 31 c0             	xor    %r8d,%r8d
ffffffff80001bb9:	e9 bc fe ff ff       	jmpq   ffffffff80001a7a <kmalloc+0xaa>
ffffffff80001bbe:	66 90                	xchg   %ax,%ax
			maj->next = allocate_new_page( size );	// next one will be okay.
ffffffff80001bc0:	44 89 f7             	mov    %r14d,%edi
ffffffff80001bc3:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
ffffffff80001bc7:	e8 84 fd ff ff       	callq  ffffffff80001950 <allocate_new_page>
ffffffff80001bcc:	48 89 43 08          	mov    %rax,0x8(%rbx)
			if ( maj->next == NULL ) break;			// no more memory.
ffffffff80001bd0:	48 85 c0             	test   %rax,%rax
ffffffff80001bd3:	0f 84 ae 00 00 00    	je     ffffffff80001c87 <kmalloc+0x2b7>
			maj->next->prev = maj;
ffffffff80001bd9:	48 89 18             	mov    %rbx,(%rax)
ffffffff80001bdc:	44 8b 45 cc          	mov    -0x34(%rbp),%r8d
ffffffff80001be0:	48 89 c3             	mov    %rax,%rbx
ffffffff80001be3:	e9 a9 fe ff ff       	jmpq   ffffffff80001a91 <kmalloc+0xc1>
ffffffff80001be8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80001bef:	00 
						ALIGN( p );
ffffffff80001bf0:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80001bf5:	48 29 f0             	sub    %rsi,%rax
ffffffff80001bf8:	48 01 c2             	add    %rax,%rdx
ffffffff80001bfb:	83 c0 10             	add    $0x10,%eax
ffffffff80001bfe:	48 89 d3             	mov    %rdx,%rbx
ffffffff80001c01:	e9 27 ff ff ff       	jmpq   ffffffff80001b2d <kmalloc+0x15d>
ffffffff80001c06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001c0d:	00 00 00 
		diff  = maj->size - maj->usage;	
ffffffff80001c10:	8b 50 14             	mov    0x14(%rax),%edx
ffffffff80001c13:	8b 48 18             	mov    0x18(%rax),%ecx
	maj = l_memRoot;
ffffffff80001c16:	48 89 c3             	mov    %rax,%rbx
		diff  = maj->size - maj->usage;	
ffffffff80001c19:	45 31 c0             	xor    %r8d,%r8d
ffffffff80001c1c:	e9 34 fe ff ff       	jmpq   ffffffff80001a55 <kmalloc+0x85>
ffffffff80001c21:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff80001c28:	8b 50 14             	mov    0x14(%rax),%edx
ffffffff80001c2b:	8b 48 18             	mov    0x18(%rax),%ecx
	maj = l_memRoot;
ffffffff80001c2e:	48 89 c3             	mov    %rax,%rbx
	unsigned long long bestSize = 0;
ffffffff80001c31:	45 31 ff             	xor    %r15d,%r15d
		diff  = maj->size - maj->usage;	
ffffffff80001c34:	45 31 c0             	xor    %r8d,%r8d
ffffffff80001c37:	e9 19 fe ff ff       	jmpq   ffffffff80001a55 <kmalloc+0x85>
ffffffff80001c3c:	0f 1f 40 00          	nopl   0x0(%rax)
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff80001c40:	48 01 ce             	add    %rcx,%rsi
ffffffff80001c43:	48 8d 46 28          	lea    0x28(%rsi),%rax
ffffffff80001c47:	48 89 41 08          	mov    %rax,0x8(%rcx)
						min->next->prev = min;
ffffffff80001c4b:	48 89 4e 28          	mov    %rcx,0x28(%rsi)
						min->next = NULL;
ffffffff80001c4f:	48 c7 46 30 00 00 00 	movq   $0x0,0x30(%rsi)
ffffffff80001c56:	00 
						min->magic = LIBALLOC_MAGIC;
ffffffff80001c57:	c7 46 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rsi)
						min->block = maj;
ffffffff80001c5e:	48 89 5e 38          	mov    %rbx,0x38(%rsi)
						min->size = size;
ffffffff80001c62:	44 89 76 44          	mov    %r14d,0x44(%rsi)
						min->req_size = req_size;
ffffffff80001c66:	44 89 6e 48          	mov    %r13d,0x48(%rsi)
						maj->usage += size + sizeof( struct liballoc_minor );
ffffffff80001c6a:	e9 9b fe ff ff       	jmpq   ffffffff80001b0a <kmalloc+0x13a>
		l_memRoot = allocate_new_page( size );
ffffffff80001c6f:	44 89 f7             	mov    %r14d,%edi
ffffffff80001c72:	e8 d9 fc ff ff       	callq  ffffffff80001950 <allocate_new_page>
ffffffff80001c77:	48 89 05 f2 e9 00 00 	mov    %rax,0xe9f2(%rip)        # ffffffff80010670 <l_memRoot>
		if ( l_memRoot == NULL )
ffffffff80001c7e:	48 85 c0             	test   %rax,%rax
ffffffff80001c81:	0f 85 9f fd ff ff    	jne    ffffffff80001a26 <kmalloc+0x56>
		  liballoc_unlock();
ffffffff80001c87:	31 c0                	xor    %eax,%eax
		  return NULL;
ffffffff80001c89:	31 db                	xor    %ebx,%ebx
		  liballoc_unlock();
ffffffff80001c8b:	e8 10 04 00 00       	callq  ffffffff800020a0 <liballoc_unlock>
		  return NULL;
ffffffff80001c90:	e9 a2 fe ff ff       	jmpq   ffffffff80001b37 <kmalloc+0x167>
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
ffffffff80001c95:	48 8d 43 28          	lea    0x28(%rbx),%rax
			maj->first->magic 		= LIBALLOC_MAGIC;
ffffffff80001c99:	c7 43 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rbx)
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
ffffffff80001ca0:	48 89 43 20          	mov    %rax,0x20(%rbx)
			maj->first->prev 		= NULL;
ffffffff80001ca4:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
ffffffff80001cab:	00 
			maj->first->next 		= NULL;
ffffffff80001cac:	48 c7 43 30 00 00 00 	movq   $0x0,0x30(%rbx)
ffffffff80001cb3:	00 
			maj->first->block 	= maj;
ffffffff80001cb4:	48 89 5b 38          	mov    %rbx,0x38(%rbx)
			maj->usage 			+= size + sizeof( struct liballoc_minor );
ffffffff80001cb8:	41 8d 46 28          	lea    0x28(%r14),%eax
			ALIGN( p );
ffffffff80001cbc:	48 8d 53 60          	lea    0x60(%rbx),%rdx
			maj->first->size 	= size;
ffffffff80001cc0:	44 89 73 44          	mov    %r14d,0x44(%rbx)
			maj->first->req_size 	= req_size;
ffffffff80001cc4:	44 89 6b 48          	mov    %r13d,0x48(%rbx)
			maj->usage 			+= size + sizeof( struct liballoc_minor );
ffffffff80001cc8:	01 43 18             	add    %eax,0x18(%rbx)
			l_inuse += size;
ffffffff80001ccb:	4c 01 35 86 e9 00 00 	add    %r14,0xe986(%rip)        # ffffffff80010658 <l_inuse>
			ALIGN( p );
ffffffff80001cd2:	83 e3 0f             	and    $0xf,%ebx
ffffffff80001cd5:	0f 84 4a fe ff ff    	je     ffffffff80001b25 <kmalloc+0x155>
ffffffff80001cdb:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80001ce0:	48 29 d8             	sub    %rbx,%rax
ffffffff80001ce3:	48 01 c2             	add    %rax,%rdx
ffffffff80001ce6:	83 c0 10             	add    $0x10,%eax
ffffffff80001ce9:	48 89 d3             	mov    %rdx,%rbx
ffffffff80001cec:	e9 3c fe ff ff       	jmpq   ffffffff80001b2d <kmalloc+0x15d>
			maj->first->prev = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
ffffffff80001cf1:	48 8d 53 28          	lea    0x28(%rbx),%rdx
ffffffff80001cf5:	48 89 10             	mov    %rdx,(%rax)
			maj->first->prev->next = maj->first;
ffffffff80001cf8:	48 89 43 30          	mov    %rax,0x30(%rbx)
			maj->first = maj->first->prev;
ffffffff80001cfc:	48 89 53 20          	mov    %rdx,0x20(%rbx)
			maj->first->magic 	= LIBALLOC_MAGIC;
ffffffff80001d00:	c7 43 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rbx)
			maj->first->prev 	= NULL;
ffffffff80001d07:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
ffffffff80001d0e:	00 
ffffffff80001d0f:	eb a3                	jmp    ffffffff80001cb4 <kmalloc+0x2e4>
ffffffff80001d11:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001d18:	00 00 00 00 
ffffffff80001d1c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001d20 <kfree>:
void PREFIX(free)(void *ptr)
{
	struct liballoc_minor *min;
	struct liballoc_major *maj;

	if ( ptr == NULL ) 
ffffffff80001d20:	48 85 ff             	test   %rdi,%rdi
ffffffff80001d23:	0f 84 5f 01 00 00    	je     ffffffff80001e88 <kfree+0x168>
{
ffffffff80001d29:	55                   	push   %rbp
		FLUSH();
		#endif
		return;
	}

	UNALIGN( ptr );
ffffffff80001d2a:	48 89 f8             	mov    %rdi,%rax
{
ffffffff80001d2d:	48 89 e5             	mov    %rsp,%rbp
ffffffff80001d30:	53                   	push   %rbx
	UNALIGN( ptr );
ffffffff80001d31:	48 89 fb             	mov    %rdi,%rbx
{
ffffffff80001d34:	48 83 ec 08          	sub    $0x8,%rsp
	UNALIGN( ptr );
ffffffff80001d38:	48 0f be 57 f0       	movsbq -0x10(%rdi),%rdx
ffffffff80001d3d:	48 29 d0             	sub    %rdx,%rax
ffffffff80001d40:	48 83 fa 20          	cmp    $0x20,%rdx
ffffffff80001d44:	48 0f 42 d8          	cmovb  %rax,%rbx

	liballoc_lock();		// lockit
ffffffff80001d48:	31 c0                	xor    %eax,%eax
ffffffff80001d4a:	e8 41 03 00 00       	callq  ffffffff80002090 <liballoc_lock>


	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));

	
	if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff80001d4f:	8b 53 f0             	mov    -0x10(%rbx),%edx
	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
ffffffff80001d52:	48 8d 43 d8          	lea    -0x28(%rbx),%rax
	if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff80001d56:	81 fa de c0 01 c0    	cmp    $0xc001c0de,%edx
ffffffff80001d5c:	0f 85 86 00 00 00    	jne    ffffffff80001de8 <kfree+0xc8>
	#endif
	

		maj = min->block;

		l_inuse -= min->size;
ffffffff80001d62:	8b 50 1c             	mov    0x1c(%rax),%edx
		maj = min->block;
ffffffff80001d65:	48 8b 78 10          	mov    0x10(%rax),%rdi
		l_inuse -= min->size;
ffffffff80001d69:	48 29 15 e8 e8 00 00 	sub    %rdx,0xe8e8(%rip)        # ffffffff80010658 <l_inuse>
ffffffff80001d70:	48 89 d1             	mov    %rdx,%rcx

		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
ffffffff80001d73:	8b 57 18             	mov    0x18(%rdi),%edx
ffffffff80001d76:	29 ca                	sub    %ecx,%edx
		min->magic  = LIBALLOC_DEAD;		// No mojo.

		if ( min->next != NULL ) min->next->prev = min->prev;
ffffffff80001d78:	48 8b 48 08          	mov    0x8(%rax),%rcx
		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
ffffffff80001d7c:	83 ea 28             	sub    $0x28,%edx
ffffffff80001d7f:	89 57 18             	mov    %edx,0x18(%rdi)
		min->magic  = LIBALLOC_DEAD;		// No mojo.
ffffffff80001d82:	c7 40 18 ad de ad de 	movl   $0xdeaddead,0x18(%rax)
		if ( min->next != NULL ) min->next->prev = min->prev;
ffffffff80001d89:	48 85 c9             	test   %rcx,%rcx
ffffffff80001d8c:	0f 84 8e 00 00 00    	je     ffffffff80001e20 <kfree+0x100>
ffffffff80001d92:	48 8b 30             	mov    (%rax),%rsi
ffffffff80001d95:	48 89 31             	mov    %rsi,(%rcx)
		if ( min->prev != NULL ) min->prev->next = min->next;
ffffffff80001d98:	48 8b 00             	mov    (%rax),%rax
ffffffff80001d9b:	48 85 c0             	test   %rax,%rax
ffffffff80001d9e:	0f 84 f4 00 00 00    	je     ffffffff80001e98 <kfree+0x178>
							// minor.


	// We need to clean up after the majors now....

	if ( maj->first == NULL )	// Block completely unused.
ffffffff80001da4:	48 83 7f 20 00       	cmpq   $0x0,0x20(%rdi)
		if ( min->prev != NULL ) min->prev->next = min->next;
ffffffff80001da9:	48 89 48 08          	mov    %rcx,0x8(%rax)
	{
		if ( l_memRoot == maj ) l_memRoot = maj->next;
		if ( l_bestBet == maj ) l_bestBet = NULL;
ffffffff80001dad:	48 8b 05 b4 e8 00 00 	mov    0xe8b4(%rip),%rax        # ffffffff80010668 <l_bestBet>
	if ( maj->first == NULL )	// Block completely unused.
ffffffff80001db4:	0f 84 81 00 00 00    	je     ffffffff80001e3b <kfree+0x11b>

		liballoc_free( maj, maj->pages );
	}
	else
	{
		if ( l_bestBet != NULL )
ffffffff80001dba:	48 85 c0             	test   %rax,%rax
ffffffff80001dbd:	74 16                	je     ffffffff80001dd5 <kfree+0xb5>
		{
			int bestSize = l_bestBet->size  - l_bestBet->usage;
ffffffff80001dbf:	8b 48 14             	mov    0x14(%rax),%ecx
ffffffff80001dc2:	2b 48 18             	sub    0x18(%rax),%ecx
			int majSize = maj->size - maj->usage;
ffffffff80001dc5:	8b 47 14             	mov    0x14(%rdi),%eax
ffffffff80001dc8:	29 d0                	sub    %edx,%eax

			if ( majSize > bestSize ) l_bestBet = maj;
ffffffff80001dca:	39 c1                	cmp    %eax,%ecx
ffffffff80001dcc:	7d 07                	jge    ffffffff80001dd5 <kfree+0xb5>
ffffffff80001dce:	48 89 3d 93 e8 00 00 	mov    %rdi,0xe893(%rip)        # ffffffff80010668 <l_bestBet>
	printf( "OK\n");
	FLUSH();
	#endif
	
	liballoc_unlock();		// release the lock
}
ffffffff80001dd5:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
		liballoc_unlock();		// release the lock
ffffffff80001dd9:	31 c0                	xor    %eax,%eax
}
ffffffff80001ddb:	c9                   	leaveq 
		liballoc_unlock();		// release the lock
ffffffff80001ddc:	e9 bf 02 00 00       	jmpq   ffffffff800020a0 <liballoc_unlock>
ffffffff80001de1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80001de8:	89 d0                	mov    %edx,%eax
		l_errorCount += 1;
ffffffff80001dea:	48 83 05 56 e8 00 00 	addq   $0x1,0xe856(%rip)        # ffffffff80010648 <l_errorCount>
ffffffff80001df1:	01 
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80001df2:	25 ff ff ff 00       	and    $0xffffff,%eax
		if ( 
ffffffff80001df7:	3d de c0 01 00       	cmp    $0x1c0de,%eax
ffffffff80001dfc:	74 0c                	je     ffffffff80001e0a <kfree+0xea>
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80001dfe:	66 81 fa de c0       	cmp    $0xc0de,%dx
ffffffff80001e03:	74 05                	je     ffffffff80001e0a <kfree+0xea>
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
ffffffff80001e05:	80 fa de             	cmp    $0xde,%dl
ffffffff80001e08:	75 cb                	jne    ffffffff80001dd5 <kfree+0xb5>
			l_possibleOverruns += 1;
ffffffff80001e0a:	48 83 05 2e e8 00 00 	addq   $0x1,0xe82e(%rip)        # ffffffff80010640 <l_possibleOverruns>
ffffffff80001e11:	01 
}
ffffffff80001e12:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
		liballoc_unlock();		// release the lock
ffffffff80001e16:	31 c0                	xor    %eax,%eax
}
ffffffff80001e18:	c9                   	leaveq 
		liballoc_unlock();		// release the lock
ffffffff80001e19:	e9 82 02 00 00       	jmpq   ffffffff800020a0 <liballoc_unlock>
ffffffff80001e1e:	66 90                	xchg   %ax,%ax
		if ( min->prev != NULL ) min->prev->next = min->next;
ffffffff80001e20:	48 8b 00             	mov    (%rax),%rax
ffffffff80001e23:	48 85 c0             	test   %rax,%rax
ffffffff80001e26:	0f 85 78 ff ff ff    	jne    ffffffff80001da4 <kfree+0x84>
		if ( min->prev == NULL ) maj->first = min->next;	
ffffffff80001e2c:	48 c7 47 20 00 00 00 	movq   $0x0,0x20(%rdi)
ffffffff80001e33:	00 
		if ( l_bestBet == maj ) l_bestBet = NULL;
ffffffff80001e34:	48 8b 05 2d e8 00 00 	mov    0xe82d(%rip),%rax        # ffffffff80010668 <l_bestBet>
		if ( l_memRoot == maj ) l_memRoot = maj->next;
ffffffff80001e3b:	48 39 3d 2e e8 00 00 	cmp    %rdi,0xe82e(%rip)        # ffffffff80010670 <l_memRoot>
ffffffff80001e42:	48 8b 57 08          	mov    0x8(%rdi),%rdx
ffffffff80001e46:	74 78                	je     ffffffff80001ec0 <kfree+0x1a0>
		if ( l_bestBet == maj ) l_bestBet = NULL;
ffffffff80001e48:	48 39 f8             	cmp    %rdi,%rax
ffffffff80001e4b:	74 63                	je     ffffffff80001eb0 <kfree+0x190>
		if ( maj->prev != NULL ) maj->prev->next = maj->next;
ffffffff80001e4d:	48 8b 07             	mov    (%rdi),%rax
ffffffff80001e50:	48 85 c0             	test   %rax,%rax
ffffffff80001e53:	74 08                	je     ffffffff80001e5d <kfree+0x13d>
ffffffff80001e55:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if ( maj->next != NULL ) maj->next->prev = maj->prev;
ffffffff80001e59:	48 8b 57 08          	mov    0x8(%rdi),%rdx
ffffffff80001e5d:	48 85 d2             	test   %rdx,%rdx
ffffffff80001e60:	74 03                	je     ffffffff80001e65 <kfree+0x145>
ffffffff80001e62:	48 89 02             	mov    %rax,(%rdx)
		liballoc_free( maj, maj->pages );
ffffffff80001e65:	8b 77 10             	mov    0x10(%rdi),%esi
		l_allocated -= maj->size;
ffffffff80001e68:	8b 47 14             	mov    0x14(%rdi),%eax
ffffffff80001e6b:	48 29 05 ee e7 00 00 	sub    %rax,0xe7ee(%rip)        # ffffffff80010660 <l_allocated>
		liballoc_free( maj, maj->pages );
ffffffff80001e72:	e8 39 02 00 00       	callq  ffffffff800020b0 <liballoc_free>
}
ffffffff80001e77:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
		liballoc_unlock();		// release the lock
ffffffff80001e7b:	31 c0                	xor    %eax,%eax
}
ffffffff80001e7d:	c9                   	leaveq 
		liballoc_unlock();		// release the lock
ffffffff80001e7e:	e9 1d 02 00 00       	jmpq   ffffffff800020a0 <liballoc_unlock>
ffffffff80001e83:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		l_warningCount += 1;
ffffffff80001e88:	48 83 05 c0 e7 00 00 	addq   $0x1,0xe7c0(%rip)        # ffffffff80010650 <l_warningCount>
ffffffff80001e8f:	01 
		return;
ffffffff80001e90:	c3                   	retq   
ffffffff80001e91:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		if ( min->prev == NULL ) maj->first = min->next;	
ffffffff80001e98:	48 89 4f 20          	mov    %rcx,0x20(%rdi)
		if ( l_bestBet == maj ) l_bestBet = NULL;
ffffffff80001e9c:	48 8b 05 c5 e7 00 00 	mov    0xe7c5(%rip),%rax        # ffffffff80010668 <l_bestBet>
ffffffff80001ea3:	e9 12 ff ff ff       	jmpq   ffffffff80001dba <kfree+0x9a>
ffffffff80001ea8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80001eaf:	00 
ffffffff80001eb0:	48 c7 05 ad e7 00 00 	movq   $0x0,0xe7ad(%rip)        # ffffffff80010668 <l_bestBet>
ffffffff80001eb7:	00 00 00 00 
ffffffff80001ebb:	eb 90                	jmp    ffffffff80001e4d <kfree+0x12d>
ffffffff80001ebd:	0f 1f 00             	nopl   (%rax)
		if ( l_memRoot == maj ) l_memRoot = maj->next;
ffffffff80001ec0:	48 89 15 a9 e7 00 00 	mov    %rdx,0xe7a9(%rip)        # ffffffff80010670 <l_memRoot>
ffffffff80001ec7:	e9 7c ff ff ff       	jmpq   ffffffff80001e48 <kfree+0x128>
ffffffff80001ecc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001ed0 <kcalloc>:




void* PREFIX(calloc)(size_t nobj, size_t size)
{
ffffffff80001ed0:	55                   	push   %rbp
       int real_size;
       void *p;

       real_size = nobj * size;
ffffffff80001ed1:	0f af fe             	imul   %esi,%edi
{
ffffffff80001ed4:	48 89 e5             	mov    %rsp,%rbp
ffffffff80001ed7:	53                   	push   %rbx
       
       p = PREFIX(malloc)( real_size );
ffffffff80001ed8:	48 63 df             	movslq %edi,%rbx
ffffffff80001edb:	48 89 df             	mov    %rbx,%rdi
{
ffffffff80001ede:	48 83 ec 08          	sub    $0x8,%rsp
       p = PREFIX(malloc)( real_size );
ffffffff80001ee2:	e8 e9 fa ff ff       	callq  ffffffff800019d0 <kmalloc>
	for ( i = 0; i < n ; i++)
ffffffff80001ee7:	48 85 db             	test   %rbx,%rbx
ffffffff80001eea:	74 13                	je     ffffffff80001eff <kcalloc+0x2f>
ffffffff80001eec:	31 c9                	xor    %ecx,%ecx
ffffffff80001eee:	31 d2                	xor    %edx,%edx
		((char*)s)[i] = c;
ffffffff80001ef0:	c6 04 10 00          	movb   $0x0,(%rax,%rdx,1)
	for ( i = 0; i < n ; i++)
ffffffff80001ef4:	8d 51 01             	lea    0x1(%rcx),%edx
ffffffff80001ef7:	48 89 d1             	mov    %rdx,%rcx
ffffffff80001efa:	48 39 da             	cmp    %rbx,%rdx
ffffffff80001efd:	72 f1                	jb     ffffffff80001ef0 <kcalloc+0x20>

       liballoc_memset( p, 0, real_size );

       return p;
}
ffffffff80001eff:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
ffffffff80001f03:	c9                   	leaveq 
ffffffff80001f04:	c3                   	retq   
ffffffff80001f05:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001f0c:	00 00 00 00 

ffffffff80001f10 <krealloc>:



void*   PREFIX(realloc)(void *p, size_t size)
{
ffffffff80001f10:	55                   	push   %rbp
ffffffff80001f11:	48 89 e5             	mov    %rsp,%rbp
ffffffff80001f14:	41 56                	push   %r14
ffffffff80001f16:	41 55                	push   %r13
ffffffff80001f18:	41 54                	push   %r12
ffffffff80001f1a:	53                   	push   %rbx
ffffffff80001f1b:	48 89 fb             	mov    %rdi,%rbx
	void *ptr;
	struct liballoc_minor *min;
	unsigned int real_size;
	
	// Honour the case of size == 0 => free old and return NULL
	if ( size == 0 )
ffffffff80001f1e:	48 85 f6             	test   %rsi,%rsi
ffffffff80001f21:	0f 84 39 01 00 00    	je     ffffffff80002060 <krealloc+0x150>
ffffffff80001f27:	49 89 f5             	mov    %rsi,%r13
		PREFIX(free)( p );
		return NULL;
	}

	// In the case of a NULL pointer, return a simple malloc.
	if ( p == NULL ) return PREFIX(malloc)( size );
ffffffff80001f2a:	48 85 ff             	test   %rdi,%rdi
ffffffff80001f2d:	0f 84 3d 01 00 00    	je     ffffffff80002070 <krealloc+0x160>

	// Unalign the pointer if required.
	ptr = p;
	UNALIGN(ptr);
ffffffff80001f33:	48 0f be 57 f0       	movsbq -0x10(%rdi),%rdx
ffffffff80001f38:	48 89 f8             	mov    %rdi,%rax
ffffffff80001f3b:	48 29 d0             	sub    %rdx,%rax
ffffffff80001f3e:	48 83 fa 20          	cmp    $0x20,%rdx
ffffffff80001f42:	48 0f 43 c7          	cmovae %rdi,%rax
ffffffff80001f46:	49 89 c4             	mov    %rax,%r12

	liballoc_lock();		// lockit
ffffffff80001f49:	31 c0                	xor    %eax,%eax
ffffffff80001f4b:	e8 40 01 00 00       	callq  ffffffff80002090 <liballoc_lock>

		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));

		// Ensure it is a valid structure.
		if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff80001f50:	41 8b 54 24 f0       	mov    -0x10(%r12),%edx
		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
ffffffff80001f55:	49 8d 44 24 d8       	lea    -0x28(%r12),%rax
		if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff80001f5a:	81 fa de c0 01 c0    	cmp    $0xc001c0de,%edx
ffffffff80001f60:	0f 85 92 00 00 00    	jne    ffffffff80001ff8 <krealloc+0xe8>
		
		// Definitely a memory block.
		
		real_size = min->req_size;

		if ( real_size >= size ) 
ffffffff80001f66:	44 8b 70 20          	mov    0x20(%rax),%r14d
ffffffff80001f6a:	4d 39 ee             	cmp    %r13,%r14
ffffffff80001f6d:	0f 83 bd 00 00 00    	jae    ffffffff80002030 <krealloc+0x120>
			min->req_size = size;
			liballoc_unlock();
			return p;
		}

	liballoc_unlock();
ffffffff80001f73:	31 c0                	xor    %eax,%eax
ffffffff80001f75:	e8 26 01 00 00       	callq  ffffffff800020a0 <liballoc_unlock>

	// If we got here then we're reallocating to a block bigger than us.
	ptr = PREFIX(malloc)( size );					// We need to allocate new memory
ffffffff80001f7a:	4c 89 ef             	mov    %r13,%rdi
ffffffff80001f7d:	e8 4e fa ff ff       	callq  ffffffff800019d0 <kmalloc>
ffffffff80001f82:	49 89 c4             	mov    %rax,%r12
  while ( n >= sizeof(unsigned int) )
ffffffff80001f85:	49 83 fe 03          	cmp    $0x3,%r14
ffffffff80001f89:	0f 86 f1 00 00 00    	jbe    ffffffff80002080 <krealloc+0x170>
ffffffff80001f8f:	49 83 ee 04          	sub    $0x4,%r14
ffffffff80001f93:	31 d2                	xor    %edx,%edx
ffffffff80001f95:	4c 89 f6             	mov    %r14,%rsi
ffffffff80001f98:	48 c1 ee 02          	shr    $0x2,%rsi
ffffffff80001f9c:	48 8d 04 b5 04 00 00 	lea    0x4(,%rsi,4),%rax
ffffffff80001fa3:	00 
ffffffff80001fa4:	0f 1f 40 00          	nopl   0x0(%rax)
      *ldest++ = *lsrc++;
ffffffff80001fa8:	8b 0c 13             	mov    (%rbx,%rdx,1),%ecx
ffffffff80001fab:	41 89 0c 14          	mov    %ecx,(%r12,%rdx,1)
  while ( n >= sizeof(unsigned int) )
ffffffff80001faf:	48 83 c2 04          	add    $0x4,%rdx
ffffffff80001fb3:	48 39 c2             	cmp    %rax,%rdx
ffffffff80001fb6:	75 f0                	jne    ffffffff80001fa8 <krealloc+0x98>
	  n -= sizeof(unsigned int);
ffffffff80001fb8:	48 f7 de             	neg    %rsi
      *ldest++ = *lsrc++;
ffffffff80001fbb:	48 8d 3c 13          	lea    (%rbx,%rdx,1),%rdi
ffffffff80001fbf:	4c 01 e2             	add    %r12,%rdx
	  n -= sizeof(unsigned int);
ffffffff80001fc2:	4d 8d 34 b6          	lea    (%r14,%rsi,4),%r14
  while ( n > 0 )
ffffffff80001fc6:	31 c9                	xor    %ecx,%ecx
ffffffff80001fc8:	4d 85 f6             	test   %r14,%r14
ffffffff80001fcb:	74 10                	je     ffffffff80001fdd <krealloc+0xcd>
      *cdest++ = *csrc++;
ffffffff80001fcd:	0f b6 04 0f          	movzbl (%rdi,%rcx,1),%eax
ffffffff80001fd1:	88 04 0a             	mov    %al,(%rdx,%rcx,1)
  while ( n > 0 )
ffffffff80001fd4:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80001fd8:	49 39 ce             	cmp    %rcx,%r14
ffffffff80001fdb:	75 f0                	jne    ffffffff80001fcd <krealloc+0xbd>
	liballoc_memcpy( ptr, p, real_size );
	PREFIX(free)( p );
ffffffff80001fdd:	48 89 df             	mov    %rbx,%rdi
ffffffff80001fe0:	e8 3b fd ff ff       	callq  ffffffff80001d20 <kfree>

	return ptr;
}
ffffffff80001fe5:	5b                   	pop    %rbx
ffffffff80001fe6:	4c 89 e0             	mov    %r12,%rax
ffffffff80001fe9:	41 5c                	pop    %r12
ffffffff80001feb:	41 5d                	pop    %r13
ffffffff80001fed:	41 5e                	pop    %r14
ffffffff80001fef:	5d                   	pop    %rbp
ffffffff80001ff0:	c3                   	retq   
ffffffff80001ff1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80001ff8:	89 d0                	mov    %edx,%eax
			l_errorCount += 1;
ffffffff80001ffa:	48 83 05 46 e6 00 00 	addq   $0x1,0xe646(%rip)        # ffffffff80010648 <l_errorCount>
ffffffff80002001:	01 
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80002002:	25 ff ff ff 00       	and    $0xffffff,%eax
			if ( 
ffffffff80002007:	3d de c0 01 00       	cmp    $0x1c0de,%eax
ffffffff8000200c:	74 42                	je     ffffffff80002050 <krealloc+0x140>
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff8000200e:	66 81 fa de c0       	cmp    $0xc0de,%dx
ffffffff80002013:	74 3b                	je     ffffffff80002050 <krealloc+0x140>
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
ffffffff80002015:	80 fa de             	cmp    $0xde,%dl
ffffffff80002018:	74 36                	je     ffffffff80002050 <krealloc+0x140>
			liballoc_unlock();		// release the lock
ffffffff8000201a:	31 c0                	xor    %eax,%eax
ffffffff8000201c:	e8 7f 00 00 00       	callq  ffffffff800020a0 <liballoc_unlock>
		return NULL;
ffffffff80002021:	45 31 e4             	xor    %r12d,%r12d
}
ffffffff80002024:	5b                   	pop    %rbx
ffffffff80002025:	4c 89 e0             	mov    %r12,%rax
ffffffff80002028:	41 5c                	pop    %r12
ffffffff8000202a:	41 5d                	pop    %r13
ffffffff8000202c:	41 5e                	pop    %r14
ffffffff8000202e:	5d                   	pop    %rbp
ffffffff8000202f:	c3                   	retq   
			min->req_size = size;
ffffffff80002030:	44 89 68 20          	mov    %r13d,0x20(%rax)
			return p;
ffffffff80002034:	49 89 dc             	mov    %rbx,%r12
			liballoc_unlock();
ffffffff80002037:	31 c0                	xor    %eax,%eax
ffffffff80002039:	e8 62 00 00 00       	callq  ffffffff800020a0 <liballoc_unlock>
}
ffffffff8000203e:	5b                   	pop    %rbx
ffffffff8000203f:	4c 89 e0             	mov    %r12,%rax
ffffffff80002042:	41 5c                	pop    %r12
ffffffff80002044:	41 5d                	pop    %r13
ffffffff80002046:	41 5e                	pop    %r14
ffffffff80002048:	5d                   	pop    %rbp
ffffffff80002049:	c3                   	retq   
ffffffff8000204a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
				l_possibleOverruns += 1;
ffffffff80002050:	48 83 05 e8 e5 00 00 	addq   $0x1,0xe5e8(%rip)        # ffffffff80010640 <l_possibleOverruns>
ffffffff80002057:	01 
ffffffff80002058:	eb c0                	jmp    ffffffff8000201a <krealloc+0x10a>
ffffffff8000205a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
		PREFIX(free)( p );
ffffffff80002060:	e8 bb fc ff ff       	callq  ffffffff80001d20 <kfree>
		return NULL;
ffffffff80002065:	eb ba                	jmp    ffffffff80002021 <krealloc+0x111>
ffffffff80002067:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000206e:	00 00 
}
ffffffff80002070:	5b                   	pop    %rbx
	if ( p == NULL ) return PREFIX(malloc)( size );
ffffffff80002071:	48 89 f7             	mov    %rsi,%rdi
}
ffffffff80002074:	41 5c                	pop    %r12
ffffffff80002076:	41 5d                	pop    %r13
ffffffff80002078:	41 5e                	pop    %r14
ffffffff8000207a:	5d                   	pop    %rbp
	if ( p == NULL ) return PREFIX(malloc)( size );
ffffffff8000207b:	e9 50 f9 ff ff       	jmpq   ffffffff800019d0 <kmalloc>
  unsigned int *ldest = (unsigned int*)s1;
ffffffff80002080:	48 89 c2             	mov    %rax,%rdx
  while ( n >= sizeof(unsigned int) )
ffffffff80002083:	48 89 df             	mov    %rbx,%rdi
ffffffff80002086:	e9 3b ff ff ff       	jmpq   ffffffff80001fc6 <krealloc+0xb6>
ffffffff8000208b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80002090 <liballoc_lock>:



int liballoc_lock()
{
    asm("cli");
ffffffff80002090:	fa                   	cli    
    return 0;
}
ffffffff80002091:	31 c0                	xor    %eax,%eax
ffffffff80002093:	c3                   	retq   
ffffffff80002094:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000209b:	00 00 00 00 
ffffffff8000209f:	90                   	nop

ffffffff800020a0 <liballoc_unlock>:


int liballoc_unlock()
{
    asm("sti");
ffffffff800020a0:	fb                   	sti    
    return 0;
}
ffffffff800020a1:	31 c0                	xor    %eax,%eax
ffffffff800020a3:	c3                   	retq   
ffffffff800020a4:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800020ab:	00 00 00 00 
ffffffff800020af:	90                   	nop

ffffffff800020b0 <liballoc_free>:

int liballoc_free(void* page, size_t count)
{
    return 0;
}
ffffffff800020b0:	31 c0                	xor    %eax,%eax
ffffffff800020b2:	c3                   	retq   
ffffffff800020b3:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800020ba:	00 00 00 00 
ffffffff800020be:	66 90                	xchg   %ax,%ax

ffffffff800020c0 <liballoc_alloc>:

void* liballoc_alloc(size_t count)
{
    for(uint64_t i = 0; i < count; i++)
ffffffff800020c0:	48 85 ff             	test   %rdi,%rdi
ffffffff800020c3:	74 6b                	je     ffffffff80002130 <liballoc_alloc+0x70>
{
ffffffff800020c5:	55                   	push   %rbp
ffffffff800020c6:	48 89 e5             	mov    %rsp,%rbp
ffffffff800020c9:	41 54                	push   %r12
    for(uint64_t i = 0; i < count; i++)
ffffffff800020cb:	45 31 e4             	xor    %r12d,%r12d
{
ffffffff800020ce:	53                   	push   %rbx
ffffffff800020cf:	48 89 fb             	mov    %rdi,%rbx
ffffffff800020d2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    {
        vmm_map_4Kpage(RootPageDirectory, (kernel_heap_top + 4096), (uint64_t)pmm_allocpage(), PTE_PRESENT | PTE_READWRITE);
ffffffff800020d8:	31 c0                	xor    %eax,%eax
    for(uint64_t i = 0; i < count; i++)
ffffffff800020da:	49 83 c4 01          	add    $0x1,%r12
        vmm_map_4Kpage(RootPageDirectory, (kernel_heap_top + 4096), (uint64_t)pmm_allocpage(), PTE_PRESENT | PTE_READWRITE);
ffffffff800020de:	e8 ad 02 00 00       	callq  ffffffff80002390 <pmm_allocpage>
ffffffff800020e3:	48 8b 3d e6 e5 00 00 	mov    0xe5e6(%rip),%rdi        # ffffffff800106d0 <RootPageDirectory>
ffffffff800020ea:	b9 03 00 00 00       	mov    $0x3,%ecx
ffffffff800020ef:	48 89 c2             	mov    %rax,%rdx
ffffffff800020f2:	48 8b 05 8f 5a 00 00 	mov    0x5a8f(%rip),%rax        # ffffffff80007b88 <kernel_heap_top>
ffffffff800020f9:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff80002100:	e8 0b 08 00 00       	callq  ffffffff80002910 <vmm_map_4Kpage>
        kernel_heap_top += 4096;
ffffffff80002105:	48 8b 05 7c 5a 00 00 	mov    0x5a7c(%rip),%rax        # ffffffff80007b88 <kernel_heap_top>
ffffffff8000210c:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff80002112:	48 89 05 6f 5a 00 00 	mov    %rax,0x5a6f(%rip)        # ffffffff80007b88 <kernel_heap_top>
    for(uint64_t i = 0; i < count; i++)
ffffffff80002119:	4c 39 e3             	cmp    %r12,%rbx
ffffffff8000211c:	75 ba                	jne    ffffffff800020d8 <liballoc_alloc+0x18>
    return addr - 0xFFFF800000000000;
}

static inline uint64_t phys_to_hh_data(uint64_t addr)
{
    return 0xFFFF800000000000 + addr;
ffffffff8000211e:	48 ba 00 00 00 00 00 	movabs $0xffff800000000000,%rdx
ffffffff80002125:	80 ff ff 
    }
    return (void*)(phys_to_hh_data((uint64_t)kernel_heap_top));
ffffffff80002128:	5b                   	pop    %rbx
ffffffff80002129:	41 5c                	pop    %r12
ffffffff8000212b:	48 01 d0             	add    %rdx,%rax
ffffffff8000212e:	5d                   	pop    %rbp
ffffffff8000212f:	c3                   	retq   
    return (void*)(phys_to_hh_data((uint64_t)kernel_heap_top));
ffffffff80002130:	48 8b 05 51 5a 00 00 	mov    0x5a51(%rip),%rax        # ffffffff80007b88 <kernel_heap_top>
ffffffff80002137:	48 ba 00 00 00 00 00 	movabs $0xffff800000000000,%rdx
ffffffff8000213e:	80 ff ff 
ffffffff80002141:	48 01 d0             	add    %rdx,%rax
ffffffff80002144:	c3                   	retq   
ffffffff80002145:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000214c:	00 00 00 
ffffffff8000214f:	90                   	nop

ffffffff80002150 <pmm_init>:
    return NULL;
}*/

//Initialize the Physical Memory Manager
void pmm_init()
{
ffffffff80002150:	55                   	push   %rbp
ffffffff80002151:	48 89 e5             	mov    %rsp,%rbp
ffffffff80002154:	41 55                	push   %r13
ffffffff80002156:	41 54                	push   %r12
ffffffff80002158:	53                   	push   %rbx
ffffffff80002159:	48 83 ec 08          	sub    $0x8,%rsp
    //memory map helper variables
    uint64_t mmap_entries = boot_info.tag_memmap->entries;
ffffffff8000215d:	4c 8b 1d 74 6f 00 00 	mov    0x6f74(%rip),%r11        # ffffffff800090d8 <boot_info+0x18>
            mmap_largest_segment_size = current_entry->length;
        }
    };

    //Populate the PMM state variables
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff80002164:	48 8b 3d 35 e5 00 00 	mov    0xe535(%rip),%rdi        # ffffffff800106a0 <pmm_info>
    uint64_t mmap_entries = boot_info.tag_memmap->entries;
ffffffff8000216b:	49 8b 5b 10          	mov    0x10(%r11),%rbx
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff8000216f:	48 85 db             	test   %rbx,%rbx
ffffffff80002172:	0f 84 34 04 00 00    	je     ffffffff800025ac <pmm_init.cold>
ffffffff80002178:	49 8d 43 18          	lea    0x18(%r11),%rax
ffffffff8000217c:	45 31 c9             	xor    %r9d,%r9d
ffffffff8000217f:	31 d2                	xor    %edx,%edx
    uint64_t mmap_largest_segment_size = 0;     //Size of the largest segment
ffffffff80002181:	45 31 c0             	xor    %r8d,%r8d
    uint64_t mmap_largest_segment_base = 0;     //Address of the largest segment
ffffffff80002184:	45 31 d2             	xor    %r10d,%r10d
ffffffff80002187:	eb 20                	jmp    ffffffff800021a9 <pmm_init+0x59>
ffffffff80002189:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        if(current_entry->length > mmap_largest_segment_size)
ffffffff80002190:	83 fe 01             	cmp    $0x1,%esi
ffffffff80002193:	75 0b                	jne    ffffffff800021a0 <pmm_init+0x50>
ffffffff80002195:	49 39 c8             	cmp    %rcx,%r8
ffffffff80002198:	73 06                	jae    ffffffff800021a0 <pmm_init+0x50>
            mmap_largest_segment_base = current_entry->base;
ffffffff8000219a:	4c 8b 10             	mov    (%rax),%r10
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff8000219d:	49 89 c8             	mov    %rcx,%r8
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800021a0:	48 83 c0 18          	add    $0x18,%rax
ffffffff800021a4:	48 39 d3             	cmp    %rdx,%rbx
ffffffff800021a7:	74 2b                	je     ffffffff800021d4 <pmm_init+0x84>
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff800021a9:	48 8b 48 08          	mov    0x8(%rax),%rcx
        if(current_entry->type == 0x1002)
ffffffff800021ad:	8b 70 10             	mov    0x10(%rax),%esi
ffffffff800021b0:	48 83 c2 01          	add    $0x1,%rdx
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff800021b4:	48 01 cf             	add    %rcx,%rdi
        if(current_entry->type == 0x1002)
ffffffff800021b7:	81 fe 02 10 00 00    	cmp    $0x1002,%esi
ffffffff800021bd:	75 d1                	jne    ffffffff80002190 <pmm_init+0x40>
            pmm_vmm_info.fb_base = current_entry->base;
ffffffff800021bf:	4c 8b 20             	mov    (%rax),%r12
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff800021c2:	49 89 cd             	mov    %rcx,%r13
            pmm_vmm_info.fb_base = current_entry->base;
ffffffff800021c5:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800021cb:	48 83 c0 18          	add    $0x18,%rax
ffffffff800021cf:	48 39 d3             	cmp    %rdx,%rbx
ffffffff800021d2:	75 d5                	jne    ffffffff800021a9 <pmm_init+0x59>
ffffffff800021d4:	48 89 3d c5 e4 00 00 	mov    %rdi,0xe4c5(%rip)        # ffffffff800106a0 <pmm_info>
ffffffff800021db:	45 84 c9             	test   %r9b,%r9b
ffffffff800021de:	74 0e                	je     ffffffff800021ee <pmm_init+0x9e>
ffffffff800021e0:	4c 89 2d a9 e4 00 00 	mov    %r13,0xe4a9(%rip)        # ffffffff80010690 <pmm_vmm_info+0x10>
ffffffff800021e7:	4c 89 25 9a e4 00 00 	mov    %r12,0xe49a(%rip)        # ffffffff80010688 <pmm_vmm_info+0x8>
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff800021ee:	48 89 f8             	mov    %rdi,%rax
    pmm_info.usedpages = pmm_info.totalpages;
    pmm_info.bitmap_size = (pmm_info.totalpages / 8) + 1;
    
    if(pmm_info.bitmap_size > current_entry->length) 
ffffffff800021f1:	48 8d 14 5b          	lea    (%rbx,%rbx,2),%rdx
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff800021f5:	48 c1 e8 0c          	shr    $0xc,%rax
ffffffff800021f9:	48 89 05 b0 e4 00 00 	mov    %rax,0xe4b0(%rip)        # ffffffff800106b0 <pmm_info+0x10>
    pmm_info.usedpages = pmm_info.totalpages;
ffffffff80002200:	48 89 05 a1 e4 00 00 	mov    %rax,0xe4a1(%rip)        # ffffffff800106a8 <pmm_info+0x8>
    pmm_info.bitmap_size = (pmm_info.totalpages / 8) + 1;
ffffffff80002207:	48 89 f8             	mov    %rdi,%rax
ffffffff8000220a:	48 c1 e8 0f          	shr    $0xf,%rax
ffffffff8000220e:	48 83 c0 01          	add    $0x1,%rax
ffffffff80002212:	48 89 05 a7 e4 00 00 	mov    %rax,0xe4a7(%rip)        # ffffffff800106c0 <pmm_info+0x20>
    if(pmm_info.bitmap_size > current_entry->length) 
ffffffff80002219:	49 39 44 d3 08       	cmp    %rax,0x8(%r11,%rdx,8)
ffffffff8000221e:	73 10                	jae    ffffffff80002230 <pmm_init+0xe0>
        {
            printf("Bitmap too large");
ffffffff80002220:	48 c7 c7 9e 5a 00 80 	mov    $0xffffffff80005a9e,%rdi
ffffffff80002227:	31 c0                	xor    %eax,%eax
ffffffff80002229:	e8 92 20 00 00       	callq  ffffffff800042c0 <printf_>
            for(;;){}   //hang
ffffffff8000222e:	eb fe                	jmp    ffffffff8000222e <pmm_init+0xde>
ffffffff80002230:	48 b8 00 00 00 00 00 	movabs $0xffff800000000000,%rax
ffffffff80002237:	80 ff ff 
        }
    
    pmm_info.bitmap = (uint8_t*)phys_to_hh_data(mmap_largest_segment_base); 

    printf("Total Memory: %d\n", (pmm_info.totalmem));
ffffffff8000223a:	48 89 fe             	mov    %rdi,%rsi
ffffffff8000223d:	48 c7 c7 af 5a 00 80 	mov    $0xffffffff80005aaf,%rdi
ffffffff80002244:	49 01 c2             	add    %rax,%r10
ffffffff80002247:	31 c0                	xor    %eax,%eax
ffffffff80002249:	4c 89 15 68 e4 00 00 	mov    %r10,0xe468(%rip)        # ffffffff800106b8 <pmm_info+0x18>
ffffffff80002250:	e8 6b 20 00 00       	callq  ffffffff800042c0 <printf_>
    printf("Total Pages: %d   Used Pages: %d\n", pmm_info.totalpages, pmm_info.usedpages);
ffffffff80002255:	48 8b 15 4c e4 00 00 	mov    0xe44c(%rip),%rdx        # ffffffff800106a8 <pmm_info+0x8>
ffffffff8000225c:	48 8b 35 4d e4 00 00 	mov    0xe44d(%rip),%rsi        # ffffffff800106b0 <pmm_info+0x10>
ffffffff80002263:	31 c0                	xor    %eax,%eax
ffffffff80002265:	48 c7 c7 e8 5a 00 80 	mov    $0xffffffff80005ae8,%rdi
ffffffff8000226c:	e8 4f 20 00 00       	callq  ffffffff800042c0 <printf_>
    printf("Bitmap Addr: %p  Bitmap Size (bytes): %d\n", pmm_info.bitmap, pmm_info.bitmap_size);
ffffffff80002271:	48 8b 15 48 e4 00 00 	mov    0xe448(%rip),%rdx        # ffffffff800106c0 <pmm_info+0x20>
ffffffff80002278:	31 c0                	xor    %eax,%eax
ffffffff8000227a:	48 8b 35 37 e4 00 00 	mov    0xe437(%rip),%rsi        # ffffffff800106b8 <pmm_info+0x18>
ffffffff80002281:	48 c7 c7 10 5b 00 80 	mov    $0xffffffff80005b10,%rdi
ffffffff80002288:	e8 33 20 00 00       	callq  ffffffff800042c0 <printf_>

    //Set all bitmap bits to 1
    for (uint64_t i = 0; i < pmm_info.bitmap_size; i++)
ffffffff8000228d:	31 c0                	xor    %eax,%eax
ffffffff8000228f:	48 83 3d 29 e4 00 00 	cmpq   $0x0,0xe429(%rip)        # ffffffff800106c0 <pmm_info+0x20>
ffffffff80002296:	00 
ffffffff80002297:	74 1f                	je     ffffffff800022b8 <pmm_init+0x168>
ffffffff80002299:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        {
        pmm_info.bitmap[i] = 0xff;
ffffffff800022a0:	48 8b 15 11 e4 00 00 	mov    0xe411(%rip),%rdx        # ffffffff800106b8 <pmm_info+0x18>
ffffffff800022a7:	c6 04 02 ff          	movb   $0xff,(%rdx,%rax,1)
    for (uint64_t i = 0; i < pmm_info.bitmap_size; i++)
ffffffff800022ab:	48 83 c0 01          	add    $0x1,%rax
ffffffff800022af:	48 3b 05 0a e4 00 00 	cmp    0xe40a(%rip),%rax        # ffffffff800106c0 <pmm_info+0x20>
ffffffff800022b6:	72 e8                	jb     ffffffff800022a0 <pmm_init+0x150>
    

    //printf("Number of MMAP Entries: %d\n", mmap_entries);

    //Iterate through the memory map again, unset bitmap for available memory
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800022b8:	31 f6                	xor    %esi,%esi
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800022ba:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff800022bf:	eb 10                	jmp    ffffffff800022d1 <pmm_init+0x181>
ffffffff800022c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800022c8:	48 83 c6 01          	add    $0x1,%rsi
ffffffff800022cc:	48 39 f3             	cmp    %rsi,%rbx
ffffffff800022cf:	74 69                	je     ffffffff8000233a <pmm_init+0x1ea>
    {
        current_entry = &boot_info.tag_memmap->memmap[i];

        if(current_entry->type == 1)
ffffffff800022d1:	48 8b 15 00 6e 00 00 	mov    0x6e00(%rip),%rdx        # ffffffff800090d8 <boot_info+0x18>
ffffffff800022d8:	48 8d 04 76          	lea    (%rsi,%rsi,2),%rax
ffffffff800022dc:	48 8d 04 c2          	lea    (%rdx,%rax,8),%rax
ffffffff800022e0:	83 78 28 01          	cmpl   $0x1,0x28(%rax)
ffffffff800022e4:	75 e2                	jne    ffffffff800022c8 <pmm_init+0x178>
        {
            uint64_t pages = current_entry->length / 4096;
ffffffff800022e6:	4c 8b 40 20          	mov    0x20(%rax),%r8
            uint64_t align = current_entry->base / 4096;
ffffffff800022ea:	48 8b 40 18          	mov    0x18(%rax),%rax
ffffffff800022ee:	48 c1 e8 0c          	shr    $0xc,%rax
            //printf("Index: %d  Pages: %d\n", align, pages);

            for(uint64_t j = 0; j < pages; j++)
ffffffff800022f2:	49 c1 e8 0c          	shr    $0xc,%r8
ffffffff800022f6:	74 d0                	je     ffffffff800022c8 <pmm_init+0x178>
ffffffff800022f8:	49 01 c0             	add    %rax,%r8
ffffffff800022fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80002300:	89 c1                	mov    %eax,%ecx
ffffffff80002302:	41 89 fb             	mov    %edi,%r11d
ffffffff80002305:	48 89 c2             	mov    %rax,%rdx
                //uint64_t bitindex = align % 8;
                //pmm_info.bitmap[byteindex] &= ~(1 << bitindex);
                
                bitmap_unset(pmm_info.bitmap, align);

                align++;                    //increment page index
ffffffff80002308:	48 83 c0 01          	add    $0x1,%rax
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff8000230c:	83 e1 07             	and    $0x7,%ecx
ffffffff8000230f:	48 c1 ea 03          	shr    $0x3,%rdx
ffffffff80002313:	48 03 15 9e e3 00 00 	add    0xe39e(%rip),%rdx        # ffffffff800106b8 <pmm_info+0x18>
ffffffff8000231a:	41 d3 e3             	shl    %cl,%r11d
ffffffff8000231d:	44 89 d9             	mov    %r11d,%ecx
ffffffff80002320:	f7 d1                	not    %ecx
ffffffff80002322:	20 0a                	and    %cl,(%rdx)
                pmm_info.usedpages--;       //decrement used page counter
ffffffff80002324:	48 83 2d 7c e3 00 00 	subq   $0x1,0xe37c(%rip)        # ffffffff800106a8 <pmm_info+0x8>
ffffffff8000232b:	01 
            for(uint64_t j = 0; j < pages; j++)
ffffffff8000232c:	4c 39 c0             	cmp    %r8,%rax
ffffffff8000232f:	75 cf                	jne    ffffffff80002300 <pmm_init+0x1b0>
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80002331:	48 83 c6 01          	add    $0x1,%rsi
ffffffff80002335:	48 39 f3             	cmp    %rsi,%rbx
ffffffff80002338:	75 97                	jne    ffffffff800022d1 <pmm_init+0x181>
            }
        }
    }

    //Make certain the NULL page is unavailable
    bitmap_set(pmm_info.bitmap, 0);
ffffffff8000233a:	48 8b 05 77 e3 00 00 	mov    0xe377(%rip),%rax        # ffffffff800106b8 <pmm_info+0x18>
    pmm_info.usedpages++;

    printf("Available Pages: %d\n", (pmm_info.totalpages - pmm_info.usedpages));
ffffffff80002341:	48 c7 c7 c1 5a 00 80 	mov    $0xffffffff80005ac1,%rdi
    bitmap[bit / 8] |= (1 << (bit % 8));
ffffffff80002348:	80 08 01             	orb    $0x1,(%rax)
    pmm_info.usedpages++;
ffffffff8000234b:	48 8b 05 56 e3 00 00 	mov    0xe356(%rip),%rax        # ffffffff800106a8 <pmm_info+0x8>
    printf("Available Pages: %d\n", (pmm_info.totalpages - pmm_info.usedpages));
ffffffff80002352:	48 8b 35 57 e3 00 00 	mov    0xe357(%rip),%rsi        # ffffffff800106b0 <pmm_info+0x10>
    pmm_info.usedpages++;
ffffffff80002359:	48 83 c0 01          	add    $0x1,%rax
ffffffff8000235d:	48 89 05 44 e3 00 00 	mov    %rax,0xe344(%rip)        # ffffffff800106a8 <pmm_info+0x8>
    printf("Available Pages: %d\n", (pmm_info.totalpages - pmm_info.usedpages));
ffffffff80002364:	48 29 c6             	sub    %rax,%rsi
ffffffff80002367:	31 c0                	xor    %eax,%eax
ffffffff80002369:	e8 52 1f 00 00       	callq  ffffffff800042c0 <printf_>
    printf("PMM Initialized\n");

}
ffffffff8000236e:	48 83 c4 08          	add    $0x8,%rsp
    printf("PMM Initialized\n");
ffffffff80002372:	48 c7 c7 d6 5a 00 80 	mov    $0xffffffff80005ad6,%rdi
ffffffff80002379:	31 c0                	xor    %eax,%eax
}
ffffffff8000237b:	5b                   	pop    %rbx
ffffffff8000237c:	41 5c                	pop    %r12
ffffffff8000237e:	41 5d                	pop    %r13
ffffffff80002380:	5d                   	pop    %rbp
    printf("PMM Initialized\n");
ffffffff80002381:	e9 3a 1f 00 00       	jmpq   ffffffff800042c0 <printf_>
ffffffff80002386:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000238d:	00 00 00 

ffffffff80002390 <pmm_allocpage>:


void* pmm_allocpage()
{
    if(pmm_info.usedpages >= pmm_info.totalpages)
ffffffff80002390:	48 8b 05 19 e3 00 00 	mov    0xe319(%rip),%rax        # ffffffff800106b0 <pmm_info+0x10>
ffffffff80002397:	48 39 05 0a e3 00 00 	cmp    %rax,0xe30a(%rip)        # ffffffff800106a8 <pmm_info+0x8>
ffffffff8000239e:	0f 83 8c 00 00 00    	jae    ffffffff80002430 <pmm_allocpage+0xa0>
        return NULL;
    
    uint64_t index = get_first_unset(pmm_info.bitmap, pmm_info.bitmap_size);
ffffffff800023a4:	48 8b 3d 15 e3 00 00 	mov    0xe315(%rip),%rdi        # ffffffff800106c0 <pmm_info+0x20>
ffffffff800023ab:	48 8b 35 06 e3 00 00 	mov    0xe306(%rip),%rsi        # ffffffff800106b8 <pmm_info+0x18>
    for(uint64_t i = 0; i < size; i++)
ffffffff800023b2:	48 85 ff             	test   %rdi,%rdi
ffffffff800023b5:	74 69                	je     ffffffff80002420 <pmm_allocpage+0x90>
ffffffff800023b7:	31 d2                	xor    %edx,%edx
ffffffff800023b9:	eb 0e                	jmp    ffffffff800023c9 <pmm_allocpage+0x39>
ffffffff800023bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
ffffffff800023c0:	48 83 c2 01          	add    $0x1,%rdx
ffffffff800023c4:	48 39 d7             	cmp    %rdx,%rdi
ffffffff800023c7:	74 57                	je     ffffffff80002420 <pmm_allocpage+0x90>
        if(bitmap[i] != 0xff)
ffffffff800023c9:	0f b6 04 16          	movzbl (%rsi,%rdx,1),%eax
ffffffff800023cd:	3c ff                	cmp    $0xff,%al
ffffffff800023cf:	74 ef                	je     ffffffff800023c0 <pmm_allocpage+0x30>
                if(!(bitmap[i] & (1 << j)))
ffffffff800023d1:	a8 01                	test   $0x1,%al
ffffffff800023d3:	0f b6 c8             	movzbl %al,%ecx
            for(uint64_t j = 0; j < 8; j++)
ffffffff800023d6:	b8 00 00 00 00       	mov    $0x0,%eax
                if(!(bitmap[i] & (1 << j)))
ffffffff800023db:	74 12                	je     ffffffff800023ef <pmm_allocpage+0x5f>
ffffffff800023dd:	0f 1f 00             	nopl   (%rax)
            for(uint64_t j = 0; j < 8; j++)
ffffffff800023e0:	48 83 c0 01          	add    $0x1,%rax
ffffffff800023e4:	48 83 f8 08          	cmp    $0x8,%rax
ffffffff800023e8:	74 d6                	je     ffffffff800023c0 <pmm_allocpage+0x30>
                if(!(bitmap[i] & (1 << j)))
ffffffff800023ea:	0f a3 c1             	bt     %eax,%ecx
ffffffff800023ed:	72 f1                	jb     ffffffff800023e0 <pmm_allocpage+0x50>
                    return (i * 8) + j;
ffffffff800023ef:	48 8d 0c d0          	lea    (%rax,%rdx,8),%rcx
    bitmap[bit / 8] |= (1 << (bit % 8));
ffffffff800023f3:	48 89 c8             	mov    %rcx,%rax

    pmm_info.usedpages++;

    //DEBUG_MSG("PMM ALLOC: %p\n", (index * PAGE_SIZE));

    return (void*)(index * PAGE_SIZE);
ffffffff800023f6:	48 89 ca             	mov    %rcx,%rdx
    bitmap[bit / 8] |= (1 << (bit % 8));
ffffffff800023f9:	83 e1 07             	and    $0x7,%ecx
ffffffff800023fc:	48 c1 e8 03          	shr    $0x3,%rax
    return (void*)(index * PAGE_SIZE);
ffffffff80002400:	48 c1 e2 0c          	shl    $0xc,%rdx
    bitmap[bit / 8] |= (1 << (bit % 8));
ffffffff80002404:	48 01 c6             	add    %rax,%rsi
ffffffff80002407:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8000240c:	d3 e0                	shl    %cl,%eax
ffffffff8000240e:	08 06                	or     %al,(%rsi)
}
ffffffff80002410:	48 89 d0             	mov    %rdx,%rax
    pmm_info.usedpages++;
ffffffff80002413:	48 83 05 8d e2 00 00 	addq   $0x1,0xe28d(%rip)        # ffffffff800106a8 <pmm_info+0x8>
ffffffff8000241a:	01 
}
ffffffff8000241b:	c3                   	retq   
ffffffff8000241c:	0f 1f 40 00          	nopl   0x0(%rax)
    for(uint64_t i = 0; i < size; i++)
ffffffff80002420:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff80002425:	31 d2                	xor    %edx,%edx
ffffffff80002427:	eb e5                	jmp    ffffffff8000240e <pmm_allocpage+0x7e>
ffffffff80002429:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        return NULL;
ffffffff80002430:	31 d2                	xor    %edx,%edx
}
ffffffff80002432:	48 89 d0             	mov    %rdx,%rax
ffffffff80002435:	c3                   	retq   
ffffffff80002436:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000243d:	00 00 00 

ffffffff80002440 <pmm_freepage>:
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80002440:	48 89 fa             	mov    %rdi,%rdx


void pmm_freepage(void* page)
{
    uint64_t index = (uint64_t)page / PAGE_SIZE;
ffffffff80002443:	48 c1 ef 0c          	shr    $0xc,%rdi
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80002447:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8000244c:	89 f9                	mov    %edi,%ecx
ffffffff8000244e:	48 c1 ea 0f          	shr    $0xf,%rdx
ffffffff80002452:	48 03 15 5f e2 00 00 	add    0xe25f(%rip),%rdx        # ffffffff800106b8 <pmm_info+0x18>
ffffffff80002459:	83 e1 07             	and    $0x7,%ecx
ffffffff8000245c:	d3 e0                	shl    %cl,%eax
ffffffff8000245e:	f7 d0                	not    %eax
ffffffff80002460:	20 02                	and    %al,(%rdx)
    bitmap_unset(pmm_info.bitmap, index);
    pmm_info.usedpages--;
ffffffff80002462:	48 83 2d 3e e2 00 00 	subq   $0x1,0xe23e(%rip)        # ffffffff800106a8 <pmm_info+0x8>
ffffffff80002469:	01 
}
ffffffff8000246a:	c3                   	retq   
ffffffff8000246b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80002470 <pmm_allocpages>:

void* pmm_allocpages(uint64_t count)
{
    if(pmm_info.usedpages >= pmm_info.totalpages)
ffffffff80002470:	4c 8b 0d 31 e2 00 00 	mov    0xe231(%rip),%r9        # ffffffff800106a8 <pmm_info+0x8>
ffffffff80002477:	4c 3b 0d 32 e2 00 00 	cmp    0xe232(%rip),%r9        # ffffffff800106b0 <pmm_info+0x10>
{
ffffffff8000247e:	49 89 f8             	mov    %rdi,%r8
    if(pmm_info.usedpages >= pmm_info.totalpages)
ffffffff80002481:	0f 83 82 00 00 00    	jae    ffffffff80002509 <pmm_allocpages+0x99>
        return NULL;
    
    uint64_t index = get_first_unset(pmm_info.bitmap, pmm_info.bitmap_size);
ffffffff80002487:	48 8b 05 32 e2 00 00 	mov    0xe232(%rip),%rax        # ffffffff800106c0 <pmm_info+0x20>
ffffffff8000248e:	48 8b 3d 23 e2 00 00 	mov    0xe223(%rip),%rdi        # ffffffff800106b8 <pmm_info+0x18>
    for(uint64_t i = 0; i < size; i++)
ffffffff80002495:	48 85 c0             	test   %rax,%rax
ffffffff80002498:	74 39                	je     ffffffff800024d3 <pmm_allocpages+0x63>
ffffffff8000249a:	31 c9                	xor    %ecx,%ecx
ffffffff8000249c:	eb 0b                	jmp    ffffffff800024a9 <pmm_allocpages+0x39>
ffffffff8000249e:	66 90                	xchg   %ax,%ax
ffffffff800024a0:	48 83 c1 01          	add    $0x1,%rcx
ffffffff800024a4:	48 39 c8             	cmp    %rcx,%rax
ffffffff800024a7:	74 67                	je     ffffffff80002510 <pmm_allocpages+0xa0>
        if(bitmap[i] != 0xff)
ffffffff800024a9:	0f b6 14 0f          	movzbl (%rdi,%rcx,1),%edx
ffffffff800024ad:	80 fa ff             	cmp    $0xff,%dl
ffffffff800024b0:	74 ee                	je     ffffffff800024a0 <pmm_allocpages+0x30>
                if(!(bitmap[i] & (1 << j)))
ffffffff800024b2:	0f b6 f2             	movzbl %dl,%esi
ffffffff800024b5:	83 e2 01             	and    $0x1,%edx
            for(uint64_t j = 0; j < 8; j++)
ffffffff800024b8:	ba 00 00 00 00       	mov    $0x0,%edx
                if(!(bitmap[i] & (1 << j)))
ffffffff800024bd:	74 10                	je     ffffffff800024cf <pmm_allocpages+0x5f>
ffffffff800024bf:	90                   	nop
            for(uint64_t j = 0; j < 8; j++)
ffffffff800024c0:	48 83 c2 01          	add    $0x1,%rdx
ffffffff800024c4:	48 83 fa 08          	cmp    $0x8,%rdx
ffffffff800024c8:	74 d6                	je     ffffffff800024a0 <pmm_allocpages+0x30>
                if(!(bitmap[i] & (1 << j)))
ffffffff800024ca:	0f a3 d6             	bt     %edx,%esi
ffffffff800024cd:	72 f1                	jb     ffffffff800024c0 <pmm_allocpages+0x50>
                    return (i * 8) + j;
ffffffff800024cf:	48 8d 04 ca          	lea    (%rdx,%rcx,8),%rax
    for(uint64_t i = 0; i < count; i++)
ffffffff800024d3:	4d 85 c0             	test   %r8,%r8
ffffffff800024d6:	74 40                	je     ffffffff80002518 <pmm_allocpages+0xa8>
ffffffff800024d8:	31 d2                	xor    %edx,%edx
    return bitmap[bit/8] & (1 << (bit & 8));
ffffffff800024da:	41 ba 01 00 00 00    	mov    $0x1,%r10d
    {
        if(bitmap_get(pmm_info.bitmap, i) == 1)
ffffffff800024e0:	f6 07 01             	testb  $0x1,(%rdi)
ffffffff800024e3:	74 24                	je     ffffffff80002509 <pmm_allocpages+0x99>
    for(uint64_t i = 0; i < count; i++)
ffffffff800024e5:	48 83 c2 01          	add    $0x1,%rdx
ffffffff800024e9:	49 39 d0             	cmp    %rdx,%r8
ffffffff800024ec:	74 2a                	je     ffffffff80002518 <pmm_allocpages+0xa8>
    return bitmap[bit/8] & (1 << (bit & 8));
ffffffff800024ee:	48 89 d1             	mov    %rdx,%rcx
ffffffff800024f1:	45 89 d3             	mov    %r10d,%r11d
ffffffff800024f4:	48 c1 e9 03          	shr    $0x3,%rcx
ffffffff800024f8:	0f b6 34 0f          	movzbl (%rdi,%rcx,1),%esi
ffffffff800024fc:	89 d1                	mov    %edx,%ecx
ffffffff800024fe:	83 e1 08             	and    $0x8,%ecx
ffffffff80002501:	41 d3 e3             	shl    %cl,%r11d
        if(bitmap_get(pmm_info.bitmap, i) == 1)
ffffffff80002504:	44 85 de             	test   %r11d,%esi
ffffffff80002507:	75 dc                	jne    ffffffff800024e5 <pmm_allocpages+0x75>
        return NULL;
ffffffff80002509:	31 c0                	xor    %eax,%eax
    }

    pmm_info.usedpages += count;

    return (void*)(index * PAGE_SIZE);
}
ffffffff8000250b:	c3                   	retq   
ffffffff8000250c:	0f 1f 40 00          	nopl   0x0(%rax)
    return 0;
ffffffff80002510:	31 c0                	xor    %eax,%eax
ffffffff80002512:	eb bf                	jmp    ffffffff800024d3 <pmm_allocpages+0x63>
ffffffff80002514:	0f 1f 40 00          	nopl   0x0(%rax)
    pmm_info.usedpages += count;
ffffffff80002518:	4d 01 c1             	add    %r8,%r9
    return (void*)(index * PAGE_SIZE);
ffffffff8000251b:	48 c1 e0 0c          	shl    $0xc,%rax
    pmm_info.usedpages += count;
ffffffff8000251f:	4c 89 0d 82 e1 00 00 	mov    %r9,0xe182(%rip)        # ffffffff800106a8 <pmm_info+0x8>
    return (void*)(index * PAGE_SIZE);
ffffffff80002526:	c3                   	retq   
ffffffff80002527:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000252e:	00 00 

ffffffff80002530 <pmm_freepages>:

uint64_t pmm_freepages(void* page, uint64_t count)
{
    uint64_t pg = (uint64_t)page;

    for(uint64_t i=0; i < count; i++)
ffffffff80002530:	48 85 f6             	test   %rsi,%rsi
ffffffff80002533:	74 44                	je     ffffffff80002579 <pmm_freepages+0x49>
ffffffff80002535:	45 31 c0             	xor    %r8d,%r8d
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80002538:	41 b9 01 00 00 00    	mov    $0x1,%r9d
ffffffff8000253e:	66 90                	xchg   %ax,%ax
    uint64_t index = (uint64_t)page / PAGE_SIZE;
ffffffff80002540:	48 89 f9             	mov    %rdi,%rcx
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80002543:	48 89 f8             	mov    %rdi,%rax
ffffffff80002546:	44 89 ca             	mov    %r9d,%edx
    for(uint64_t i=0; i < count; i++)
ffffffff80002549:	49 83 c0 01          	add    $0x1,%r8
    uint64_t index = (uint64_t)page / PAGE_SIZE;
ffffffff8000254d:	48 c1 e9 0c          	shr    $0xc,%rcx
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80002551:	48 c1 e8 0f          	shr    $0xf,%rax
ffffffff80002555:	48 03 05 5c e1 00 00 	add    0xe15c(%rip),%rax        # ffffffff800106b8 <pmm_info+0x18>
    {
        pmm_freepage((void*)pg);
        pg += 0x1000;
ffffffff8000255c:	48 81 c7 00 10 00 00 	add    $0x1000,%rdi
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80002563:	83 e1 07             	and    $0x7,%ecx
ffffffff80002566:	d3 e2                	shl    %cl,%edx
ffffffff80002568:	f7 d2                	not    %edx
ffffffff8000256a:	20 10                	and    %dl,(%rax)
    pmm_info.usedpages--;
ffffffff8000256c:	48 83 2d 34 e1 00 00 	subq   $0x1,0xe134(%rip)        # ffffffff800106a8 <pmm_info+0x8>
ffffffff80002573:	01 
    for(uint64_t i=0; i < count; i++)
ffffffff80002574:	4c 39 c6             	cmp    %r8,%rsi
ffffffff80002577:	75 c7                	jne    ffffffff80002540 <pmm_freepages+0x10>
    }

    return 0;
}
ffffffff80002579:	31 c0                	xor    %eax,%eax
ffffffff8000257b:	c3                   	retq   
ffffffff8000257c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80002580 <pmm_get_free_memory>:

uint64_t pmm_get_free_memory()
{
    return (pmm_info.totalpages - pmm_info.usedpages) * PAGE_SIZE;
ffffffff80002580:	48 8b 05 29 e1 00 00 	mov    0xe129(%rip),%rax        # ffffffff800106b0 <pmm_info+0x10>
ffffffff80002587:	48 2b 05 1a e1 00 00 	sub    0xe11a(%rip),%rax        # ffffffff800106a8 <pmm_info+0x8>
ffffffff8000258e:	48 c1 e0 0c          	shl    $0xc,%rax
}
ffffffff80002592:	c3                   	retq   
ffffffff80002593:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000259a:	00 00 00 00 
ffffffff8000259e:	66 90                	xchg   %ax,%ax

ffffffff800025a0 <pmm_get_total_memory>:

uint64_t pmm_get_total_memory()
{   
    return (pmm_info.totalpages) * PAGE_SIZE;
ffffffff800025a0:	48 8b 05 09 e1 00 00 	mov    0xe109(%rip),%rax        # ffffffff800106b0 <pmm_info+0x10>
ffffffff800025a7:	48 c1 e0 0c          	shl    $0xc,%rax
ffffffff800025ab:	c3                   	retq   

ffffffff800025ac <pmm_init.cold>:
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff800025ac:	48 89 f8             	mov    %rdi,%rax
ffffffff800025af:	48 c1 e8 0c          	shr    $0xc,%rax
    pmm_info.usedpages = pmm_info.totalpages;
ffffffff800025b3:	48 89 05 ee e0 00 00 	mov    %rax,0xe0ee(%rip)        # ffffffff800106a8 <pmm_info+0x8>
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff800025ba:	48 89 05 ef e0 00 00 	mov    %rax,0xe0ef(%rip)        # ffffffff800106b0 <pmm_info+0x10>
    pmm_info.bitmap_size = (pmm_info.totalpages / 8) + 1;
ffffffff800025c1:	48 89 f8             	mov    %rdi,%rax
ffffffff800025c4:	48 c1 e8 0f          	shr    $0xf,%rax
ffffffff800025c8:	48 83 c0 01          	add    $0x1,%rax
ffffffff800025cc:	48 89 05 ed e0 00 00 	mov    %rax,0xe0ed(%rip)        # ffffffff800106c0 <pmm_info+0x20>
    if(pmm_info.bitmap_size > current_entry->length) 
ffffffff800025d3:	48 8b 04 25 08 00 00 	mov    0x8,%rax
ffffffff800025da:	00 
ffffffff800025db:	0f 0b                	ud2    
ffffffff800025dd:	0f 1f 00             	nopl   (%rax)

ffffffff800025e0 <vmm_create_page_table>:
struct PageTable* kernel_cr3 = {0};

uint64_t magic = 0xdeadbeef;

struct PageTable* vmm_create_page_table()
{
ffffffff800025e0:	55                   	push   %rbp
    void* page = pmm_allocpage();   //get a page
ffffffff800025e1:	31 c0                	xor    %eax,%eax
{
ffffffff800025e3:	48 89 e5             	mov    %rsp,%rbp
ffffffff800025e6:	53                   	push   %rbx
ffffffff800025e7:	48 83 ec 08          	sub    $0x8,%rsp
    void* page = pmm_allocpage();   //get a page
ffffffff800025eb:	e8 a0 fd ff ff       	callq  ffffffff80002390 <pmm_allocpage>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff800025f0:	48 85 c0             	test   %rax,%rax
ffffffff800025f3:	74 4c                	je     ffffffff80002641 <vmm_create_page_table+0x61>
ffffffff800025f5:	48 89 c2             	mov    %rax,%rdx


static inline void* memset(void* s, uint64_t c, uint64_t len)
{
    unsigned char* p=(uint8_t*)s;
    while(len--)
ffffffff800025f8:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff800025ff:	48 89 c1             	mov    %rax,%rcx
ffffffff80002602:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    {
        *p++ = (unsigned char)c;
ffffffff80002608:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8000260c:	c6 41 ff 00          	movb   $0x0,-0x1(%rcx)
    while(len--)
ffffffff80002610:	48 39 f1             	cmp    %rsi,%rcx
ffffffff80002613:	75 f3                	jne    ffffffff80002608 <vmm_create_page_table+0x28>

    memset((uint8_t*)page, 0, 4096);    //clear the page
    struct PageTable* ret = phys_to_hh_data((uint64_t)page);
    DEBUG_MSG("PageTable %p  %p", page, ret);
ffffffff80002615:	48 c7 c6 3a 5b 00 80 	mov    $0xffffffff80005b3a,%rsi
ffffffff8000261c:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002621:	31 c0                	xor    %eax,%eax
ffffffff80002623:	48 bb 00 00 00 00 00 	movabs $0xffff800000000000,%rbx
ffffffff8000262a:	80 ff ff 
ffffffff8000262d:	48 01 d3             	add    %rdx,%rbx
ffffffff80002630:	48 89 d9             	mov    %rbx,%rcx
ffffffff80002633:	e8 48 1e 00 00       	callq  ffffffff80004480 <serial_printf>
    return ret;
    
    //return (struct PageTable*)phys_to_hh_data((uint64_t)page);
}
ffffffff80002638:	48 89 d8             	mov    %rbx,%rax
ffffffff8000263b:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
ffffffff8000263f:	c9                   	leaveq 
ffffffff80002640:	c3                   	retq   
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff80002641:	31 db                	xor    %ebx,%ebx
ffffffff80002643:	eb f3                	jmp    ffffffff80002638 <vmm_create_page_table+0x58>
ffffffff80002645:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000264c:	00 00 00 00 

ffffffff80002650 <vmm_map_1Gpage>:
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
    }
}

void vmm_map_1Gpage(struct PageTable* pagetable, uint64_t virtual, uint64_t physical, uint64_t flags)
{
ffffffff80002650:	55                   	push   %rbp
ffffffff80002651:	48 89 e5             	mov    %rsp,%rbp
ffffffff80002654:	41 57                	push   %r15
ffffffff80002656:	49 89 d7             	mov    %rdx,%r15
ffffffff80002659:	41 56                	push   %r14
    uint64_t vaddr = virtual;
    uint64_t index4, index3;
    vaddr >>= 12;
    vaddr >>= 9;
    vaddr >>= 9;
ffffffff8000265b:	49 89 f6             	mov    %rsi,%r14
{
ffffffff8000265e:	41 55                	push   %r13
    vaddr >>= 9;
ffffffff80002660:	49 c1 ee 1e          	shr    $0x1e,%r14
{
ffffffff80002664:	41 54                	push   %r12
    index3 = vaddr & 0x1ff;
ffffffff80002666:	41 81 e6 ff 01 00 00 	and    $0x1ff,%r14d
{
ffffffff8000266d:	49 89 cc             	mov    %rcx,%r12
ffffffff80002670:	53                   	push   %rbx
ffffffff80002671:	48 89 f3             	mov    %rsi,%rbx
    vaddr >>= 9;
ffffffff80002674:	48 c1 eb 27          	shr    $0x27,%rbx
    index4 = vaddr & 0x1ff;
ffffffff80002678:	81 e3 ff 01 00 00    	and    $0x1ff,%ebx
{
ffffffff8000267e:	48 83 ec 18          	sub    $0x18,%rsp
    if(pagemap->entry[index] & 1)
ffffffff80002682:	48 8b 04 df          	mov    (%rdi,%rbx,8),%rax
ffffffff80002686:	a8 01                	test   $0x1,%al
ffffffff80002688:	74 26                	je     ffffffff800026b0 <vmm_map_1Gpage+0x60>
    struct PageTable* PML4;
    struct PageTable* PML3;

    PML4 = pagetable;
    PML3 = vmm_get_pagemap(PML4, index4, flags);
    PML3->entry[index3] = physical | flags | PTE_PAGESIZE;
ffffffff8000268a:	4d 09 fc             	or     %r15,%r12
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff8000268d:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
    PML3->entry[index3] = physical | flags | PTE_PAGESIZE;
ffffffff80002693:	41 80 cc 80          	or     $0x80,%r12b
ffffffff80002697:	4e 89 24 f0          	mov    %r12,(%rax,%r14,8)
}
ffffffff8000269b:	48 83 c4 18          	add    $0x18,%rsp
ffffffff8000269f:	5b                   	pop    %rbx
ffffffff800026a0:	41 5c                	pop    %r12
ffffffff800026a2:	41 5d                	pop    %r13
ffffffff800026a4:	41 5e                	pop    %r14
ffffffff800026a6:	41 5f                	pop    %r15
ffffffff800026a8:	5d                   	pop    %rbp
ffffffff800026a9:	c3                   	retq   
ffffffff800026aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    void* page = pmm_allocpage();   //get a page
ffffffff800026b0:	31 c0                	xor    %eax,%eax
ffffffff800026b2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
ffffffff800026b6:	e8 d5 fc ff ff       	callq  ffffffff80002390 <pmm_allocpage>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff800026bb:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff800026bf:	48 85 c0             	test   %rax,%rax
    void* page = pmm_allocpage();   //get a page
ffffffff800026c2:	48 89 c2             	mov    %rax,%rdx
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff800026c5:	74 61                	je     ffffffff80002728 <vmm_map_1Gpage+0xd8>
ffffffff800026c7:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff800026ce:	48 89 c1             	mov    %rax,%rcx
ffffffff800026d1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        *p++ = (unsigned char)c;
ffffffff800026d8:	48 83 c1 01          	add    $0x1,%rcx
ffffffff800026dc:	c6 41 ff 00          	movb   $0x0,-0x1(%rcx)
    while(len--)
ffffffff800026e0:	48 39 ce             	cmp    %rcx,%rsi
ffffffff800026e3:	75 f3                	jne    ffffffff800026d8 <vmm_map_1Gpage+0x88>
ffffffff800026e5:	49 bd 00 00 00 00 00 	movabs $0xffff800000000000,%r13
ffffffff800026ec:	80 ff ff 
    DEBUG_MSG("PageTable %p  %p", page, ret);
ffffffff800026ef:	31 c0                	xor    %eax,%eax
ffffffff800026f1:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800026f6:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
ffffffff800026fa:	49 01 d5             	add    %rdx,%r13
ffffffff800026fd:	48 c7 c6 3a 5b 00 80 	mov    $0xffffffff80005b3a,%rsi
ffffffff80002704:	4c 89 e9             	mov    %r13,%rcx
ffffffff80002707:	e8 74 1d 00 00       	callq  ffffffff80004480 <serial_printf>
        if(!newentry) printf("Null page allocated!\n");
ffffffff8000270c:	4d 85 ed             	test   %r13,%r13
ffffffff8000270f:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff80002713:	74 13                	je     ffffffff80002728 <vmm_map_1Gpage+0xd8>
        pagemap->entry[index] = newentry | flags;
ffffffff80002715:	4c 89 e8             	mov    %r13,%rax
ffffffff80002718:	4c 09 e0             	or     %r12,%rax
ffffffff8000271b:	49 89 04 d8          	mov    %rax,(%r8,%rbx,8)
ffffffff8000271f:	e9 66 ff ff ff       	jmpq   ffffffff8000268a <vmm_map_1Gpage+0x3a>
ffffffff80002724:	0f 1f 40 00          	nopl   0x0(%rax)
        if(!newentry) printf("Null page allocated!\n");
ffffffff80002728:	48 c7 c7 4b 5b 00 80 	mov    $0xffffffff80005b4b,%rdi
ffffffff8000272f:	31 c0                	xor    %eax,%eax
ffffffff80002731:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
ffffffff80002735:	e8 86 1b 00 00       	callq  ffffffff800042c0 <printf_>
ffffffff8000273a:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff8000273e:	4c 89 e0             	mov    %r12,%rax
ffffffff80002741:	eb d8                	jmp    ffffffff8000271b <vmm_map_1Gpage+0xcb>
ffffffff80002743:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000274a:	00 00 00 00 
ffffffff8000274e:	66 90                	xchg   %ax,%ax

ffffffff80002750 <vmm_map_2Mpage>:

void vmm_map_2Mpage(struct PageTable* pagetable, uint64_t virtual, uint64_t physical, uint64_t flags)
{
ffffffff80002750:	55                   	push   %rbp
ffffffff80002751:	48 89 e5             	mov    %rsp,%rbp
ffffffff80002754:	41 57                	push   %r15
ffffffff80002756:	41 56                	push   %r14
    uint64_t vaddr = virtual;
    uint64_t paddr = physical;
    uint64_t index2, index3, index4;
    vaddr >>= 12;
    //index1 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80002758:	49 89 f6             	mov    %rsi,%r14
{
ffffffff8000275b:	41 55                	push   %r13
    index2 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff8000275d:	49 89 f5             	mov    %rsi,%r13
    index3 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80002760:	48 c1 ee 27          	shr    $0x27,%rsi
{
ffffffff80002764:	41 54                	push   %r12
    index4 = vaddr & 0x1ff;
ffffffff80002766:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
    vaddr >>= 9;
ffffffff8000276c:	49 c1 ee 15          	shr    $0x15,%r14
{
ffffffff80002770:	49 89 cc             	mov    %rcx,%r12
ffffffff80002773:	53                   	push   %rbx
    vaddr >>= 9;
ffffffff80002774:	49 c1 ed 1e          	shr    $0x1e,%r13
{
ffffffff80002778:	48 89 d3             	mov    %rdx,%rbx
    index2 = vaddr & 0x1ff;
ffffffff8000277b:	41 81 e6 ff 01 00 00 	and    $0x1ff,%r14d
    index3 = vaddr & 0x1ff;
ffffffff80002782:	41 81 e5 ff 01 00 00 	and    $0x1ff,%r13d
{
ffffffff80002789:	48 83 ec 18          	sub    $0x18,%rsp
    if(pagemap->entry[index] & 1)
ffffffff8000278d:	48 8b 04 f7          	mov    (%rdi,%rsi,8),%rax
ffffffff80002791:	a8 01                	test   $0x1,%al
ffffffff80002793:	74 3b                	je     ffffffff800027d0 <vmm_map_2Mpage+0x80>
        return (struct PageTable*)(pagemap->entry[index] & ~(0x1ff));
ffffffff80002795:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
ffffffff8000279b:	49 89 c7             	mov    %rax,%r15
    if(pagemap->entry[index] & 1)
ffffffff8000279e:	4b 8b 04 ef          	mov    (%r15,%r13,8),%rax
ffffffff800027a2:	a8 01                	test   $0x1,%al
ffffffff800027a4:	0f 84 b9 00 00 00    	je     ffffffff80002863 <vmm_map_2Mpage+0x113>
    PML3 = vmm_get_pagemap(PML4, index4, flags);
    PML2 = vmm_get_pagemap(PML3, index3, flags);

    paddr &= 

    PML2->entry[index2] = physical | flags | PTE_PAGESIZE;
ffffffff800027aa:	4c 09 e3             	or     %r12,%rbx
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff800027ad:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
    PML2->entry[index2] = physical | flags | PTE_PAGESIZE;
ffffffff800027b3:	80 cb 80             	or     $0x80,%bl
ffffffff800027b6:	4a 89 1c f0          	mov    %rbx,(%rax,%r14,8)
}
ffffffff800027ba:	48 83 c4 18          	add    $0x18,%rsp
ffffffff800027be:	5b                   	pop    %rbx
ffffffff800027bf:	41 5c                	pop    %r12
ffffffff800027c1:	41 5d                	pop    %r13
ffffffff800027c3:	41 5e                	pop    %r14
ffffffff800027c5:	41 5f                	pop    %r15
ffffffff800027c7:	5d                   	pop    %rbp
ffffffff800027c8:	c3                   	retq   
ffffffff800027c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    void* page = pmm_allocpage();   //get a page
ffffffff800027d0:	31 c0                	xor    %eax,%eax
ffffffff800027d2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
ffffffff800027d6:	49 89 f7             	mov    %rsi,%r15
ffffffff800027d9:	e8 b2 fb ff ff       	callq  ffffffff80002390 <pmm_allocpage>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff800027de:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff800027e2:	48 85 c0             	test   %rax,%rax
    void* page = pmm_allocpage();   //get a page
ffffffff800027e5:	48 89 c2             	mov    %rax,%rdx
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff800027e8:	0f 84 e2 00 00 00    	je     ffffffff800028d0 <vmm_map_2Mpage+0x180>
ffffffff800027ee:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff800027f5:	48 89 c1             	mov    %rax,%rcx
ffffffff800027f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff800027ff:	00 
        *p++ = (unsigned char)c;
ffffffff80002800:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80002804:	c6 41 ff 00          	movb   $0x0,-0x1(%rcx)
    while(len--)
ffffffff80002808:	48 39 f1             	cmp    %rsi,%rcx
ffffffff8000280b:	75 f3                	jne    ffffffff80002800 <vmm_map_2Mpage+0xb0>
ffffffff8000280d:	48 b9 00 00 00 00 00 	movabs $0xffff800000000000,%rcx
ffffffff80002814:	80 ff ff 
    DEBUG_MSG("PageTable %p  %p", page, ret);
ffffffff80002817:	31 c0                	xor    %eax,%eax
ffffffff80002819:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000281e:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
ffffffff80002822:	48 01 d1             	add    %rdx,%rcx
ffffffff80002825:	48 c7 c6 3a 5b 00 80 	mov    $0xffffffff80005b3a,%rsi
ffffffff8000282c:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff80002830:	e8 4b 1c 00 00       	callq  ffffffff80004480 <serial_printf>
        if(!newentry) printf("Null page allocated!\n");
ffffffff80002835:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80002839:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
ffffffff8000283d:	48 85 c9             	test   %rcx,%rcx
ffffffff80002840:	0f 84 8a 00 00 00    	je     ffffffff800028d0 <vmm_map_2Mpage+0x180>
        pagemap->entry[index] = newentry | flags;
ffffffff80002846:	4c 09 e1             	or     %r12,%rcx
ffffffff80002849:	4b 89 0c f8          	mov    %rcx,(%r8,%r15,8)
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff8000284d:	48 81 e1 00 fe ff ff 	and    $0xfffffffffffffe00,%rcx
ffffffff80002854:	49 89 cf             	mov    %rcx,%r15
    if(pagemap->entry[index] & 1)
ffffffff80002857:	4b 8b 04 ef          	mov    (%r15,%r13,8),%rax
ffffffff8000285b:	a8 01                	test   $0x1,%al
ffffffff8000285d:	0f 85 47 ff ff ff    	jne    ffffffff800027aa <vmm_map_2Mpage+0x5a>
    void* page = pmm_allocpage();   //get a page
ffffffff80002863:	31 c0                	xor    %eax,%eax
ffffffff80002865:	e8 26 fb ff ff       	callq  ffffffff80002390 <pmm_allocpage>
ffffffff8000286a:	48 89 c2             	mov    %rax,%rdx
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff8000286d:	48 85 c0             	test   %rax,%rax
ffffffff80002870:	74 7e                	je     ffffffff800028f0 <vmm_map_2Mpage+0x1a0>
ffffffff80002872:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff80002879:	48 89 c1             	mov    %rax,%rcx
ffffffff8000287c:	0f 1f 40 00          	nopl   0x0(%rax)
        *p++ = (unsigned char)c;
ffffffff80002880:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80002884:	c6 41 ff 00          	movb   $0x0,-0x1(%rcx)
    while(len--)
ffffffff80002888:	48 39 ce             	cmp    %rcx,%rsi
ffffffff8000288b:	75 f3                	jne    ffffffff80002880 <vmm_map_2Mpage+0x130>
    DEBUG_MSG("PageTable %p  %p", page, ret);
ffffffff8000288d:	48 c7 c6 3a 5b 00 80 	mov    $0xffffffff80005b3a,%rsi
ffffffff80002894:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002899:	31 c0                	xor    %eax,%eax
ffffffff8000289b:	48 b9 00 00 00 00 00 	movabs $0xffff800000000000,%rcx
ffffffff800028a2:	80 ff ff 
ffffffff800028a5:	48 01 d1             	add    %rdx,%rcx
ffffffff800028a8:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff800028ac:	e8 cf 1b 00 00       	callq  ffffffff80004480 <serial_printf>
        if(!newentry) printf("Null page allocated!\n");
ffffffff800028b1:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff800028b5:	48 85 c9             	test   %rcx,%rcx
ffffffff800028b8:	74 36                	je     ffffffff800028f0 <vmm_map_2Mpage+0x1a0>
        pagemap->entry[index] = newentry | flags;
ffffffff800028ba:	48 89 c8             	mov    %rcx,%rax
ffffffff800028bd:	4c 09 e0             	or     %r12,%rax
ffffffff800028c0:	4b 89 04 ef          	mov    %rax,(%r15,%r13,8)
ffffffff800028c4:	e9 e1 fe ff ff       	jmpq   ffffffff800027aa <vmm_map_2Mpage+0x5a>
ffffffff800028c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        if(!newentry) printf("Null page allocated!\n");
ffffffff800028d0:	48 c7 c7 4b 5b 00 80 	mov    $0xffffffff80005b4b,%rdi
ffffffff800028d7:	31 c0                	xor    %eax,%eax
ffffffff800028d9:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
ffffffff800028dd:	e8 de 19 00 00       	callq  ffffffff800042c0 <printf_>
ffffffff800028e2:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff800028e6:	4c 89 e1             	mov    %r12,%rcx
ffffffff800028e9:	e9 5b ff ff ff       	jmpq   ffffffff80002849 <vmm_map_2Mpage+0xf9>
ffffffff800028ee:	66 90                	xchg   %ax,%ax
ffffffff800028f0:	48 c7 c7 4b 5b 00 80 	mov    $0xffffffff80005b4b,%rdi
ffffffff800028f7:	31 c0                	xor    %eax,%eax
ffffffff800028f9:	e8 c2 19 00 00       	callq  ffffffff800042c0 <printf_>
ffffffff800028fe:	4c 89 e0             	mov    %r12,%rax
ffffffff80002901:	eb bd                	jmp    ffffffff800028c0 <vmm_map_2Mpage+0x170>
ffffffff80002903:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000290a:	00 00 00 00 
ffffffff8000290e:	66 90                	xchg   %ax,%ax

ffffffff80002910 <vmm_map_4Kpage>:

void vmm_map_4Kpage(struct PageTable* pagetable, uint64_t virtual, uint64_t physical, uint64_t flags)
{
ffffffff80002910:	55                   	push   %rbp
ffffffff80002911:	48 89 e5             	mov    %rsp,%rbp
ffffffff80002914:	41 57                	push   %r15
    uint64_t index1, index2, index3, index4;
    vaddr >>= 12;
    index1 = vaddr & 0x1ff;
    vaddr >>= 9;
    index2 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80002916:	49 89 f7             	mov    %rsi,%r15
{
ffffffff80002919:	41 56                	push   %r14
    vaddr >>= 9;
ffffffff8000291b:	49 c1 ef 1e          	shr    $0x1e,%r15
{
ffffffff8000291f:	49 89 d6             	mov    %rdx,%r14
ffffffff80002922:	41 55                	push   %r13
    vaddr >>= 12;
ffffffff80002924:	49 89 f5             	mov    %rsi,%r13
    index3 = vaddr & 0x1ff;
ffffffff80002927:	41 81 e7 ff 01 00 00 	and    $0x1ff,%r15d
{
ffffffff8000292e:	41 54                	push   %r12
    vaddr >>= 9;
ffffffff80002930:	49 89 f4             	mov    %rsi,%r12
    vaddr >>= 9;
ffffffff80002933:	48 c1 ee 27          	shr    $0x27,%rsi
{
ffffffff80002937:	53                   	push   %rbx
    index4 = vaddr & 0x1ff;
ffffffff80002938:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
    vaddr >>= 12;
ffffffff8000293e:	49 c1 ed 0c          	shr    $0xc,%r13
{
ffffffff80002942:	48 89 cb             	mov    %rcx,%rbx
    vaddr >>= 9;
ffffffff80002945:	49 c1 ec 15          	shr    $0x15,%r12
    index1 = vaddr & 0x1ff;
ffffffff80002949:	41 81 e5 ff 01 00 00 	and    $0x1ff,%r13d
    index2 = vaddr & 0x1ff;
ffffffff80002950:	41 81 e4 ff 01 00 00 	and    $0x1ff,%r12d
{
ffffffff80002957:	48 83 ec 28          	sub    $0x28,%rsp
    if(pagemap->entry[index] & 1)
ffffffff8000295b:	48 8b 04 f7          	mov    (%rdi,%rsi,8),%rax
ffffffff8000295f:	a8 01                	test   $0x1,%al
ffffffff80002961:	74 4d                	je     ffffffff800029b0 <vmm_map_4Kpage+0xa0>
        return (struct PageTable*)(pagemap->entry[index] & ~(0x1ff));
ffffffff80002963:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
ffffffff80002969:	49 89 c0             	mov    %rax,%r8
    if(pagemap->entry[index] & 1)
ffffffff8000296c:	4b 8b 04 f8          	mov    (%r8,%r15,8),%rax
ffffffff80002970:	a8 01                	test   $0x1,%al
ffffffff80002972:	0f 84 d3 00 00 00    	je     ffffffff80002a4b <vmm_map_4Kpage+0x13b>
        return (struct PageTable*)(pagemap->entry[index] & ~(0x1ff));
ffffffff80002978:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
ffffffff8000297e:	49 89 c7             	mov    %rax,%r15
    if(pagemap->entry[index] & 1)
ffffffff80002981:	4b 8b 04 e7          	mov    (%r15,%r12,8),%rax
ffffffff80002985:	a8 01                	test   $0x1,%al
ffffffff80002987:	0f 84 46 01 00 00    	je     ffffffff80002ad3 <vmm_map_4Kpage+0x1c3>
    PML4 = pagetable;
    PML3 = vmm_get_pagemap(PML4, index4, flags);
    PML2 = vmm_get_pagemap(PML3, index3, flags);
    PML1 = vmm_get_pagemap(PML2, index2, flags);

    PML1->entry[index1] = physical | flags;
ffffffff8000298d:	4c 09 f3             	or     %r14,%rbx
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff80002990:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
    PML1->entry[index1] = physical | flags;
ffffffff80002996:	4a 89 1c e8          	mov    %rbx,(%rax,%r13,8)
    //serial_printf(SERIAL_PORT1, "%p, %p, %p, %p\n", PML4->entry[index4], PML3->entry[index3], PML2->entry[index2], PML1->entry[index1]);
    //serial_printf(SERIAL_PORT1, "%p, %d, %d, %d, %d, %p\n", virtual, index4, index3, index2, index1, physical);

    //vmm_flush_tlb((void*)virtual);

}
ffffffff8000299a:	48 83 c4 28          	add    $0x28,%rsp
ffffffff8000299e:	5b                   	pop    %rbx
ffffffff8000299f:	41 5c                	pop    %r12
ffffffff800029a1:	41 5d                	pop    %r13
ffffffff800029a3:	41 5e                	pop    %r14
ffffffff800029a5:	41 5f                	pop    %r15
ffffffff800029a7:	5d                   	pop    %rbp
ffffffff800029a8:	c3                   	retq   
ffffffff800029a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    void* page = pmm_allocpage();   //get a page
ffffffff800029b0:	31 c0                	xor    %eax,%eax
ffffffff800029b2:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
ffffffff800029b6:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
ffffffff800029ba:	e8 d1 f9 ff ff       	callq  ffffffff80002390 <pmm_allocpage>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff800029bf:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff800029c3:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
ffffffff800029c7:	48 85 c0             	test   %rax,%rax
    void* page = pmm_allocpage();   //get a page
ffffffff800029ca:	48 89 c2             	mov    %rax,%rdx
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff800029cd:	0f 84 6d 01 00 00    	je     ffffffff80002b40 <vmm_map_4Kpage+0x230>
ffffffff800029d3:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff800029da:	48 89 c1             	mov    %rax,%rcx
ffffffff800029dd:	0f 1f 00             	nopl   (%rax)
        *p++ = (unsigned char)c;
ffffffff800029e0:	48 83 c1 01          	add    $0x1,%rcx
ffffffff800029e4:	c6 41 ff 00          	movb   $0x0,-0x1(%rcx)
    while(len--)
ffffffff800029e8:	48 39 f1             	cmp    %rsi,%rcx
ffffffff800029eb:	75 f3                	jne    ffffffff800029e0 <vmm_map_4Kpage+0xd0>
ffffffff800029ed:	48 b9 00 00 00 00 00 	movabs $0xffff800000000000,%rcx
ffffffff800029f4:	80 ff ff 
    DEBUG_MSG("PageTable %p  %p", page, ret);
ffffffff800029f7:	31 c0                	xor    %eax,%eax
ffffffff800029f9:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800029fe:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
ffffffff80002a02:	48 01 d1             	add    %rdx,%rcx
ffffffff80002a05:	48 c7 c6 3a 5b 00 80 	mov    $0xffffffff80005b3a,%rsi
ffffffff80002a0c:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
ffffffff80002a10:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff80002a14:	e8 67 1a 00 00       	callq  ffffffff80004480 <serial_printf>
        if(!newentry) printf("Null page allocated!\n");
ffffffff80002a19:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80002a1d:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
ffffffff80002a21:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
ffffffff80002a25:	48 85 c9             	test   %rcx,%rcx
ffffffff80002a28:	0f 84 12 01 00 00    	je     ffffffff80002b40 <vmm_map_4Kpage+0x230>
        pagemap->entry[index] = newentry | flags;
ffffffff80002a2e:	48 09 d9             	or     %rbx,%rcx
ffffffff80002a31:	4b 89 0c c1          	mov    %rcx,(%r9,%r8,8)
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff80002a35:	48 81 e1 00 fe ff ff 	and    $0xfffffffffffffe00,%rcx
ffffffff80002a3c:	49 89 c8             	mov    %rcx,%r8
    if(pagemap->entry[index] & 1)
ffffffff80002a3f:	4b 8b 04 f8          	mov    (%r8,%r15,8),%rax
ffffffff80002a43:	a8 01                	test   $0x1,%al
ffffffff80002a45:	0f 85 2d ff ff ff    	jne    ffffffff80002978 <vmm_map_4Kpage+0x68>
    void* page = pmm_allocpage();   //get a page
ffffffff80002a4b:	31 c0                	xor    %eax,%eax
ffffffff80002a4d:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
ffffffff80002a51:	e8 3a f9 ff ff       	callq  ffffffff80002390 <pmm_allocpage>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff80002a56:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff80002a5a:	48 85 c0             	test   %rax,%rax
    void* page = pmm_allocpage();   //get a page
ffffffff80002a5d:	48 89 c2             	mov    %rax,%rdx
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff80002a60:	0f 84 0a 01 00 00    	je     ffffffff80002b70 <vmm_map_4Kpage+0x260>
ffffffff80002a66:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff80002a6d:	48 89 c1             	mov    %rax,%rcx
        *p++ = (unsigned char)c;
ffffffff80002a70:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80002a74:	c6 41 ff 00          	movb   $0x0,-0x1(%rcx)
    while(len--)
ffffffff80002a78:	48 39 ce             	cmp    %rcx,%rsi
ffffffff80002a7b:	75 f3                	jne    ffffffff80002a70 <vmm_map_4Kpage+0x160>
ffffffff80002a7d:	48 b9 00 00 00 00 00 	movabs $0xffff800000000000,%rcx
ffffffff80002a84:	80 ff ff 
    DEBUG_MSG("PageTable %p  %p", page, ret);
ffffffff80002a87:	31 c0                	xor    %eax,%eax
ffffffff80002a89:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002a8e:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
ffffffff80002a92:	48 01 d1             	add    %rdx,%rcx
ffffffff80002a95:	48 c7 c6 3a 5b 00 80 	mov    $0xffffffff80005b3a,%rsi
ffffffff80002a9c:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff80002aa0:	e8 db 19 00 00       	callq  ffffffff80004480 <serial_printf>
        if(!newentry) printf("Null page allocated!\n");
ffffffff80002aa5:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80002aa9:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
ffffffff80002aad:	48 85 c9             	test   %rcx,%rcx
ffffffff80002ab0:	0f 84 ba 00 00 00    	je     ffffffff80002b70 <vmm_map_4Kpage+0x260>
        pagemap->entry[index] = newentry | flags;
ffffffff80002ab6:	48 09 d9             	or     %rbx,%rcx
ffffffff80002ab9:	4b 89 0c f8          	mov    %rcx,(%r8,%r15,8)
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff80002abd:	48 81 e1 00 fe ff ff 	and    $0xfffffffffffffe00,%rcx
ffffffff80002ac4:	49 89 cf             	mov    %rcx,%r15
    if(pagemap->entry[index] & 1)
ffffffff80002ac7:	4b 8b 04 e7          	mov    (%r15,%r12,8),%rax
ffffffff80002acb:	a8 01                	test   $0x1,%al
ffffffff80002acd:	0f 85 ba fe ff ff    	jne    ffffffff8000298d <vmm_map_4Kpage+0x7d>
    void* page = pmm_allocpage();   //get a page
ffffffff80002ad3:	31 c0                	xor    %eax,%eax
ffffffff80002ad5:	e8 b6 f8 ff ff       	callq  ffffffff80002390 <pmm_allocpage>
ffffffff80002ada:	48 89 c2             	mov    %rax,%rdx
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff80002add:	48 85 c0             	test   %rax,%rax
ffffffff80002ae0:	0f 84 aa 00 00 00    	je     ffffffff80002b90 <vmm_map_4Kpage+0x280>
ffffffff80002ae6:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff80002aed:	48 89 c1             	mov    %rax,%rcx
        *p++ = (unsigned char)c;
ffffffff80002af0:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80002af4:	c6 41 ff 00          	movb   $0x0,-0x1(%rcx)
    while(len--)
ffffffff80002af8:	48 39 f1             	cmp    %rsi,%rcx
ffffffff80002afb:	75 f3                	jne    ffffffff80002af0 <vmm_map_4Kpage+0x1e0>
    DEBUG_MSG("PageTable %p  %p", page, ret);
ffffffff80002afd:	48 c7 c6 3a 5b 00 80 	mov    $0xffffffff80005b3a,%rsi
ffffffff80002b04:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002b09:	31 c0                	xor    %eax,%eax
ffffffff80002b0b:	48 b9 00 00 00 00 00 	movabs $0xffff800000000000,%rcx
ffffffff80002b12:	80 ff ff 
ffffffff80002b15:	48 01 d1             	add    %rdx,%rcx
ffffffff80002b18:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff80002b1c:	e8 5f 19 00 00       	callq  ffffffff80004480 <serial_printf>
        if(!newentry) printf("Null page allocated!\n");
ffffffff80002b21:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80002b25:	48 85 c9             	test   %rcx,%rcx
ffffffff80002b28:	74 66                	je     ffffffff80002b90 <vmm_map_4Kpage+0x280>
        pagemap->entry[index] = newentry | flags;
ffffffff80002b2a:	48 89 c8             	mov    %rcx,%rax
ffffffff80002b2d:	48 09 d8             	or     %rbx,%rax
ffffffff80002b30:	4b 89 04 e7          	mov    %rax,(%r15,%r12,8)
ffffffff80002b34:	e9 54 fe ff ff       	jmpq   ffffffff8000298d <vmm_map_4Kpage+0x7d>
ffffffff80002b39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        if(!newentry) printf("Null page allocated!\n");
ffffffff80002b40:	48 c7 c7 4b 5b 00 80 	mov    $0xffffffff80005b4b,%rdi
ffffffff80002b47:	31 c0                	xor    %eax,%eax
ffffffff80002b49:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
ffffffff80002b4d:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
ffffffff80002b51:	e8 6a 17 00 00       	callq  ffffffff800042c0 <printf_>
ffffffff80002b56:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
ffffffff80002b5a:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff80002b5e:	48 89 d9             	mov    %rbx,%rcx
ffffffff80002b61:	e9 cb fe ff ff       	jmpq   ffffffff80002a31 <vmm_map_4Kpage+0x121>
ffffffff80002b66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80002b6d:	00 00 00 
ffffffff80002b70:	48 c7 c7 4b 5b 00 80 	mov    $0xffffffff80005b4b,%rdi
ffffffff80002b77:	31 c0                	xor    %eax,%eax
ffffffff80002b79:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
ffffffff80002b7d:	e8 3e 17 00 00       	callq  ffffffff800042c0 <printf_>
ffffffff80002b82:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff80002b86:	48 89 d9             	mov    %rbx,%rcx
ffffffff80002b89:	e9 2b ff ff ff       	jmpq   ffffffff80002ab9 <vmm_map_4Kpage+0x1a9>
ffffffff80002b8e:	66 90                	xchg   %ax,%ax
ffffffff80002b90:	48 c7 c7 4b 5b 00 80 	mov    $0xffffffff80005b4b,%rdi
ffffffff80002b97:	31 c0                	xor    %eax,%eax
ffffffff80002b99:	e8 22 17 00 00       	callq  ffffffff800042c0 <printf_>
ffffffff80002b9e:	48 89 d8             	mov    %rbx,%rax
ffffffff80002ba1:	eb 8d                	jmp    ffffffff80002b30 <vmm_map_4Kpage+0x220>
ffffffff80002ba3:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80002baa:	00 00 00 00 
ffffffff80002bae:	66 90                	xchg   %ax,%ax

ffffffff80002bb0 <vmm_unmap_page>:
    virtual >>= 9;
    index3 = virtual & 0x1ff;
    virtual >>= 9;
    index4 = virtual & 0x1ff;

    if(PML4->entry[index4] & 1)
ffffffff80002bb0:	48 ba 00 00 00 00 00 	movabs $0xffff800000000000,%rdx
ffffffff80002bb7:	80 ff ff 
{
ffffffff80002bba:	48 89 f0             	mov    %rsi,%rax
    if(PML4->entry[index4] & 1)
ffffffff80002bbd:	48 01 d7             	add    %rdx,%rdi
    virtual >>= 9;
ffffffff80002bc0:	48 89 f2             	mov    %rsi,%rdx
ffffffff80002bc3:	48 c1 ea 27          	shr    $0x27,%rdx
    index4 = virtual & 0x1ff;
ffffffff80002bc7:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    if(PML4->entry[index4] & 1)
ffffffff80002bcd:	48 8b 14 d7          	mov    (%rdi,%rdx,8),%rdx
ffffffff80002bd1:	f6 c2 01             	test   $0x1,%dl
ffffffff80002bd4:	74 58                	je     ffffffff80002c2e <vmm_unmap_page+0x7e>
    virtual >>= 9;
ffffffff80002bd6:	48 89 f1             	mov    %rsi,%rcx
    {
        PML3 = (struct PageTable*)((PML4->entry[index4] >> 12) * 4096);
        if(PML3->entry[index3] & 1)
ffffffff80002bd9:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
    virtual >>= 9;
ffffffff80002be0:	48 c1 e9 1e          	shr    $0x1e,%rcx
    index3 = virtual & 0x1ff;
ffffffff80002be4:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
        if(PML3->entry[index3] & 1)
ffffffff80002bea:	48 8b 14 ca          	mov    (%rdx,%rcx,8),%rdx
ffffffff80002bee:	f6 c2 01             	test   $0x1,%dl
ffffffff80002bf1:	74 3b                	je     ffffffff80002c2e <vmm_unmap_page+0x7e>
    virtual >>= 9;
ffffffff80002bf3:	48 89 f1             	mov    %rsi,%rcx
        {
            PML2 = (struct PageTable*)((PML3->entry[index3] >> 12) * 4096);
            if(PML2->entry[index2] & 1)
ffffffff80002bf6:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
    virtual >>= 9;
ffffffff80002bfd:	48 c1 e9 15          	shr    $0x15,%rcx
    index2 = virtual & 0x1ff;
ffffffff80002c01:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
            if(PML2->entry[index2] & 1)
ffffffff80002c07:	48 8b 14 ca          	mov    (%rdx,%rcx,8),%rdx
ffffffff80002c0b:	f6 c2 01             	test   $0x1,%dl
ffffffff80002c0e:	74 1e                	je     ffffffff80002c2e <vmm_unmap_page+0x7e>
    virtual >>= 12;
ffffffff80002c10:	48 c1 e8 0c          	shr    $0xc,%rax
            {
                PML1 = (struct PageTable*)((PML2->entry[index2] >> 12) * 4096);
ffffffff80002c14:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
    index1 = virtual & 0x1ff;
ffffffff80002c1b:	25 ff 01 00 00       	and    $0x1ff,%eax
                if(PML1->entry[index1] & 1)
ffffffff80002c20:	f6 04 c2 01          	testb  $0x1,(%rdx,%rax,8)
ffffffff80002c24:	74 08                	je     ffffffff80002c2e <vmm_unmap_page+0x7e>
                {
                    PML1->entry[index1] = 0x00;
ffffffff80002c26:	48 c7 04 c2 00 00 00 	movq   $0x0,(%rdx,%rax,8)
ffffffff80002c2d:	00 
                }
            }
        }
    }
}
ffffffff80002c2e:	c3                   	retq   
ffffffff80002c2f:	90                   	nop

ffffffff80002c30 <vmm_pagewalk>:

//returns a physical address for a given virtual address
uint64_t vmm_pagewalk(uint64_t vaddr, uint64_t* cr3)
{
ffffffff80002c30:	55                   	push   %rbp
    uint64_t* PML4 = (uint64_t*)(phys_to_hh_data((uint64_t)cr3));
    
    uint64_t index1, index2, index3, index4;
    vaddr >>= 12;
ffffffff80002c31:	49 89 f8             	mov    %rdi,%r8
    index1 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80002c34:	48 89 f9             	mov    %rdi,%rcx
    index2 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80002c37:	48 89 fa             	mov    %rdi,%rdx
    index3 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80002c3a:	48 c1 ef 27          	shr    $0x27,%rdi
{
ffffffff80002c3e:	48 89 f0             	mov    %rsi,%rax
    vaddr >>= 9;
ffffffff80002c41:	48 c1 ea 1e          	shr    $0x1e,%rdx
    index4 = vaddr & 0x1ff;
   
    uint64_t* PDPTE = (uint64_t*)((phys_to_hh_data(PML4[index4]) >> 12) * 4096);
ffffffff80002c45:	49 b9 00 00 00 00 00 	movabs $0xffff800000000000,%r9
ffffffff80002c4c:	80 ff ff 
    index4 = vaddr & 0x1ff;
ffffffff80002c4f:	48 89 fe             	mov    %rdi,%rsi
    index3 = vaddr & 0x1ff;
ffffffff80002c52:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    vaddr >>= 9;
ffffffff80002c58:	48 c1 e9 15          	shr    $0x15,%rcx
    uint64_t* PTE = (uint64_t*)((phys_to_hh_data(PDE[index2]) >> 12) * 4096);
    uint64_t* PD = (uint64_t*)((phys_to_hh_data(PTE[index1]) >> 12) * 4096);

    uint64_t pageaddr = hh_data_to_phys((uint64_t)PD);
    
    printf("%d  %d  %d  %d  %p\n", index4, index3, index2, index1, pageaddr);
ffffffff80002c5c:	48 c7 c7 61 5b 00 80 	mov    $0xffffffff80005b61,%rdi
{
ffffffff80002c63:	48 89 e5             	mov    %rsp,%rbp
ffffffff80002c66:	53                   	push   %rbx
    index4 = vaddr & 0x1ff;
ffffffff80002c67:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
    vaddr >>= 12;
ffffffff80002c6d:	49 c1 e8 0c          	shr    $0xc,%r8
    uint64_t* PDPTE = (uint64_t*)((phys_to_hh_data(PML4[index4]) >> 12) * 4096);
ffffffff80002c71:	48 8d 04 f0          	lea    (%rax,%rsi,8),%rax
    index2 = vaddr & 0x1ff;
ffffffff80002c75:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
    index1 = vaddr & 0x1ff;
ffffffff80002c7b:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
{
ffffffff80002c82:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80002c86:	4a 8b 1c 08          	mov    (%rax,%r9,1),%rbx
ffffffff80002c8a:	4c 01 cb             	add    %r9,%rbx
ffffffff80002c8d:	48 89 d8             	mov    %rbx,%rax
    uint64_t* PDE = (uint64_t*)((phys_to_hh_data(PDPTE[index3]) >> 12) * 4096);
ffffffff80002c90:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff80002c96:	48 8b 1c d0          	mov    (%rax,%rdx,8),%rbx
ffffffff80002c9a:	4c 01 cb             	add    %r9,%rbx
ffffffff80002c9d:	48 89 d8             	mov    %rbx,%rax
    uint64_t* PTE = (uint64_t*)((phys_to_hh_data(PDE[index2]) >> 12) * 4096);
ffffffff80002ca0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff80002ca6:	48 8b 1c c8          	mov    (%rax,%rcx,8),%rbx
ffffffff80002caa:	4c 01 cb             	add    %r9,%rbx
ffffffff80002cad:	48 89 d8             	mov    %rbx,%rax
    uint64_t* PD = (uint64_t*)((phys_to_hh_data(PTE[index1]) >> 12) * 4096);
ffffffff80002cb0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff80002cb6:	4e 03 0c c0          	add    (%rax,%r8,8),%r9
    return addr - 0xFFFF800000000000;
ffffffff80002cba:	48 b8 00 00 00 00 00 	movabs $0x800000000000,%rax
ffffffff80002cc1:	80 00 00 
ffffffff80002cc4:	49 81 e1 00 f0 ff ff 	and    $0xfffffffffffff000,%r9
ffffffff80002ccb:	49 8d 1c 01          	lea    (%r9,%rax,1),%rbx
    printf("%d  %d  %d  %d  %p\n", index4, index3, index2, index1, pageaddr);
ffffffff80002ccf:	31 c0                	xor    %eax,%eax
ffffffff80002cd1:	49 89 d9             	mov    %rbx,%r9
ffffffff80002cd4:	e8 e7 15 00 00       	callq  ffffffff800042c0 <printf_>
    
    
    pageaddr >>= 12;
    pageaddr *= 4096;
ffffffff80002cd9:	48 89 d8             	mov    %rbx,%rax

    return pageaddr;
}
ffffffff80002cdc:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
ffffffff80002ce0:	c9                   	leaveq 
ffffffff80002ce1:	c3                   	retq   
ffffffff80002ce2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80002ce9:	00 00 00 00 
ffffffff80002ced:	0f 1f 00             	nopl   (%rax)

ffffffff80002cf0 <vmm_PMLwalk>:

void vmm_PMLwalk(struct PageTable* pagetable)
{
ffffffff80002cf0:	55                   	push   %rbp
ffffffff80002cf1:	48 89 fa             	mov    %rdi,%rdx
    struct PageTable* PML4 = pagetable;
    struct PageTable* PML3 = NULL;
    struct PageTable* PML2 = NULL;
    struct PageTable* PML1 = NULL;

    serial_printf(SERIAL_PORT1, "Begin Pagewalk\r\nPML 4 %p\r\n", (uint64_t)PML4);
ffffffff80002cf4:	48 c7 c6 75 5b 00 80 	mov    $0xffffffff80005b75,%rsi
ffffffff80002cfb:	31 c0                	xor    %eax,%eax
{
ffffffff80002cfd:	48 89 e5             	mov    %rsp,%rbp
ffffffff80002d00:	41 57                	push   %r15
ffffffff80002d02:	41 56                	push   %r14
ffffffff80002d04:	41 55                	push   %r13
ffffffff80002d06:	41 54                	push   %r12
ffffffff80002d08:	53                   	push   %rbx
ffffffff80002d09:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff80002d0d:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    serial_printf(SERIAL_PORT1, "Begin Pagewalk\r\nPML 4 %p\r\n", (uint64_t)PML4);
ffffffff80002d11:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002d16:	e8 65 17 00 00       	callq  ffffffff80004480 <serial_printf>
    for(uint64_t i = 0; i < 512; i++)
ffffffff80002d1b:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
ffffffff80002d22:	00 
ffffffff80002d23:	eb 15                	jmp    ffffffff80002d3a <vmm_PMLwalk+0x4a>
ffffffff80002d25:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
ffffffff80002d2a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff80002d2e:	48 3d 00 02 00 00    	cmp    $0x200,%rax
ffffffff80002d34:	0f 84 19 01 00 00    	je     ffffffff80002e53 <vmm_PMLwalk+0x163>
    {
        if(pagetable->entry[i] & 0x01)
ffffffff80002d3a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff80002d3e:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
ffffffff80002d42:	4c 8b 04 d8          	mov    (%rax,%rbx,8),%r8
ffffffff80002d46:	41 f6 c0 01          	test   $0x1,%r8b
ffffffff80002d4a:	74 d9                	je     ffffffff80002d25 <vmm_PMLwalk+0x35>
            {
                serial_printf(SERIAL_PORT1, "4,%p,%d,%p\r\n",pagetable, i, pagetable->entry[i]);
ffffffff80002d4c:	49 89 de             	mov    %rbx,%r14
ffffffff80002d4f:	48 89 d9             	mov    %rbx,%rcx
ffffffff80002d52:	48 89 c2             	mov    %rax,%rdx
ffffffff80002d55:	48 89 c3             	mov    %rax,%rbx
ffffffff80002d58:	48 c7 c6 90 5b 00 80 	mov    $0xffffffff80005b90,%rsi
ffffffff80002d5f:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002d64:	31 c0                	xor    %eax,%eax
ffffffff80002d66:	e8 15 17 00 00       	callq  ffffffff80004480 <serial_printf>
                PML3 = (struct PageTable*)(pagetable->entry[i] & ~(0x1FF));
ffffffff80002d6b:	4e 8b 34 f3          	mov    (%rbx,%r14,8),%r14
                for(uint64_t j = 0; j < 512; j++)
ffffffff80002d6f:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
ffffffff80002d76:	00 
                PML3 = (struct PageTable*)(pagetable->entry[i] & ~(0x1FF));
ffffffff80002d77:	49 81 e6 00 fe ff ff 	and    $0xfffffffffffffe00,%r14
                for(uint64_t j = 0; j < 512; j++)
ffffffff80002d7e:	eb 11                	jmp    ffffffff80002d91 <vmm_PMLwalk+0xa1>
ffffffff80002d80:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
ffffffff80002d85:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80002d89:	48 3d 00 02 00 00    	cmp    $0x200,%rax
ffffffff80002d8f:	74 94                	je     ffffffff80002d25 <vmm_PMLwalk+0x35>
                {
                    if(PML3->entry[j] & 0x01)
ffffffff80002d91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80002d95:	4d 8b 04 c6          	mov    (%r14,%rax,8),%r8
ffffffff80002d99:	41 f6 c0 01          	test   $0x1,%r8b
ffffffff80002d9d:	74 e1                	je     ffffffff80002d80 <vmm_PMLwalk+0x90>
                    {
                        serial_printf(SERIAL_PORT1, "3,%p,%d,%p\r\n",PML3, j, PML3->entry[j]);
ffffffff80002d9f:	48 89 c3             	mov    %rax,%rbx
ffffffff80002da2:	48 89 c1             	mov    %rax,%rcx
ffffffff80002da5:	4c 89 f2             	mov    %r14,%rdx
ffffffff80002da8:	31 c0                	xor    %eax,%eax
ffffffff80002daa:	48 c7 c6 9d 5b 00 80 	mov    $0xffffffff80005b9d,%rsi
ffffffff80002db1:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002db6:	e8 c5 16 00 00       	callq  ffffffff80004480 <serial_printf>
                        PML2 = (struct PageTable*)(PML3->entry[j] & ~(0x1FF));
ffffffff80002dbb:	49 8b 04 de          	mov    (%r14,%rbx,8),%rax
                        for(uint64_t k = 0; k < 512; k++)
ffffffff80002dbf:	31 db                	xor    %ebx,%ebx
                        PML2 = (struct PageTable*)(PML3->entry[j] & ~(0x1FF));
ffffffff80002dc1:	49 89 c4             	mov    %rax,%r12
ffffffff80002dc4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff80002dc8:	49 81 e4 00 fe ff ff 	and    $0xfffffffffffffe00,%r12
                        for(uint64_t k = 0; k < 512; k++)
ffffffff80002dcf:	eb 14                	jmp    ffffffff80002de5 <vmm_PMLwalk+0xf5>
ffffffff80002dd1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff80002dd8:	48 83 c3 01          	add    $0x1,%rbx
ffffffff80002ddc:	48 81 fb 00 02 00 00 	cmp    $0x200,%rbx
ffffffff80002de3:	74 9b                	je     ffffffff80002d80 <vmm_PMLwalk+0x90>
                        {
                            if(PML2->entry[k] & 0x01)
ffffffff80002de5:	4d 8b 04 dc          	mov    (%r12,%rbx,8),%r8
ffffffff80002de9:	41 f6 c0 01          	test   $0x1,%r8b
ffffffff80002ded:	74 e9                	je     ffffffff80002dd8 <vmm_PMLwalk+0xe8>
                            {
                                serial_printf(SERIAL_PORT1, "2,%p,%d,%p\r\n",PML2, k, PML2->entry[k]);
ffffffff80002def:	48 89 d9             	mov    %rbx,%rcx
ffffffff80002df2:	4c 89 e2             	mov    %r12,%rdx
ffffffff80002df5:	48 c7 c6 aa 5b 00 80 	mov    $0xffffffff80005baa,%rsi
ffffffff80002dfc:	31 c0                	xor    %eax,%eax
ffffffff80002dfe:	bf f8 03 00 00       	mov    $0x3f8,%edi
                                PML1 = (struct PageTable*)(PML3->entry[k] & ~(0x1FF));
                                for(uint64_t l = 0; l < 512; l++)
ffffffff80002e03:	45 31 ff             	xor    %r15d,%r15d
                                serial_printf(SERIAL_PORT1, "2,%p,%d,%p\r\n",PML2, k, PML2->entry[k]);
ffffffff80002e06:	e8 75 16 00 00       	callq  ffffffff80004480 <serial_printf>
                                PML1 = (struct PageTable*)(PML3->entry[k] & ~(0x1FF));
ffffffff80002e0b:	4d 8b 2c de          	mov    (%r14,%rbx,8),%r13
ffffffff80002e0f:	49 81 e5 00 fe ff ff 	and    $0xfffffffffffffe00,%r13
                                for(uint64_t l = 0; l < 512; l++)
ffffffff80002e16:	eb 15                	jmp    ffffffff80002e2d <vmm_PMLwalk+0x13d>
ffffffff80002e18:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80002e1f:	00 
ffffffff80002e20:	49 83 c7 01          	add    $0x1,%r15
ffffffff80002e24:	49 81 ff 00 02 00 00 	cmp    $0x200,%r15
ffffffff80002e2b:	74 ab                	je     ffffffff80002dd8 <vmm_PMLwalk+0xe8>
                                {
                                    if(PML1->entry[l] & 0x01)
ffffffff80002e2d:	4f 8b 44 fd 00       	mov    0x0(%r13,%r15,8),%r8
ffffffff80002e32:	41 f6 c0 01          	test   $0x1,%r8b
ffffffff80002e36:	74 e8                	je     ffffffff80002e20 <vmm_PMLwalk+0x130>
                                    {
                                        serial_printf(SERIAL_PORT1, "1,%p,%d,%p\r\n", PML1, l, PML1->entry[l]);
ffffffff80002e38:	4c 89 f9             	mov    %r15,%rcx
ffffffff80002e3b:	4c 89 ea             	mov    %r13,%rdx
ffffffff80002e3e:	48 c7 c6 b7 5b 00 80 	mov    $0xffffffff80005bb7,%rsi
ffffffff80002e45:	31 c0                	xor    %eax,%eax
ffffffff80002e47:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002e4c:	e8 2f 16 00 00       	callq  ffffffff80004480 <serial_printf>
ffffffff80002e51:	eb cd                	jmp    ffffffff80002e20 <vmm_PMLwalk+0x130>
                }//PML3
            }
    }//PML4

    serial_printf(SERIAL_PORT1, "End Pagewalk\r\n");
}
ffffffff80002e53:	48 83 c4 28          	add    $0x28,%rsp
    serial_printf(SERIAL_PORT1, "End Pagewalk\r\n");
ffffffff80002e57:	48 c7 c6 c4 5b 00 80 	mov    $0xffffffff80005bc4,%rsi
ffffffff80002e5e:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002e63:	31 c0                	xor    %eax,%eax
}
ffffffff80002e65:	5b                   	pop    %rbx
ffffffff80002e66:	41 5c                	pop    %r12
ffffffff80002e68:	41 5d                	pop    %r13
ffffffff80002e6a:	41 5e                	pop    %r14
ffffffff80002e6c:	41 5f                	pop    %r15
ffffffff80002e6e:	5d                   	pop    %rbp
    serial_printf(SERIAL_PORT1, "End Pagewalk\r\n");
ffffffff80002e6f:	e9 0c 16 00 00       	jmpq   ffffffff80004480 <serial_printf>
ffffffff80002e74:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80002e7b:	00 00 00 00 
ffffffff80002e7f:	90                   	nop

ffffffff80002e80 <vmm_init>:

void vmm_init()
{
ffffffff80002e80:	55                   	push   %rbp
    kernel_cr3 = (struct PageTable*)vmm_read_cr3();
ffffffff80002e81:	31 c0                	xor    %eax,%eax
{
ffffffff80002e83:	48 89 e5             	mov    %rsp,%rbp
ffffffff80002e86:	41 57                	push   %r15
ffffffff80002e88:	41 56                	push   %r14
ffffffff80002e8a:	41 55                	push   %r13
ffffffff80002e8c:	41 54                	push   %r12
ffffffff80002e8e:	53                   	push   %rbx
ffffffff80002e8f:	48 83 ec 18          	sub    $0x18,%rsp
    kernel_cr3 = (struct PageTable*)vmm_read_cr3();
ffffffff80002e93:	e8 08 d5 ff ff       	callq  ffffffff800003a0 <vmm_read_cr3>
    printf("CR3: %p\n", (uint64_t)kernel_cr3);
ffffffff80002e98:	48 c7 c7 d3 5b 00 80 	mov    $0xffffffff80005bd3,%rdi
    kernel_cr3 = (struct PageTable*)vmm_read_cr3();
ffffffff80002e9f:	48 89 c6             	mov    %rax,%rsi
ffffffff80002ea2:	48 89 05 1f d8 00 00 	mov    %rax,0xd81f(%rip)        # ffffffff800106c8 <kernel_cr3>
    printf("CR3: %p\n", (uint64_t)kernel_cr3);
ffffffff80002ea9:	31 c0                	xor    %eax,%eax
ffffffff80002eab:	e8 10 14 00 00       	callq  ffffffff800042c0 <printf_>
    uint32_t efer = vmm_read_efer();
ffffffff80002eb0:	31 c0                	xor    %eax,%eax
ffffffff80002eb2:	e8 f5 d4 ff ff       	callq  ffffffff800003ac <vmm_read_efer>
    uint32_t NXE = efer & (1 << 11);
    printf("EFER: %p  NXE: %d\n", efer, NXE);
ffffffff80002eb7:	48 c7 c7 dc 5b 00 80 	mov    $0xffffffff80005bdc,%rdi
    uint32_t NXE = efer & (1 << 11);
ffffffff80002ebe:	89 c2                	mov    %eax,%edx
    uint32_t efer = vmm_read_efer();
ffffffff80002ec0:	89 c6                	mov    %eax,%esi
    printf("EFER: %p  NXE: %d\n", efer, NXE);
ffffffff80002ec2:	31 c0                	xor    %eax,%eax
    uint32_t NXE = efer & (1 << 11);
ffffffff80002ec4:	81 e2 00 08 00 00    	and    $0x800,%edx
    printf("EFER: %p  NXE: %d\n", efer, NXE);
ffffffff80002eca:	e8 f1 13 00 00       	callq  ffffffff800042c0 <printf_>
    void* page = pmm_allocpage();   //get a page
ffffffff80002ecf:	31 c0                	xor    %eax,%eax
ffffffff80002ed1:	e8 ba f4 ff ff       	callq  ffffffff80002390 <pmm_allocpage>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff80002ed6:	48 85 c0             	test   %rax,%rax
ffffffff80002ed9:	0f 84 98 02 00 00    	je     ffffffff80003177 <vmm_init+0x2f7>
ffffffff80002edf:	48 89 c2             	mov    %rax,%rdx
ffffffff80002ee2:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff80002ee9:	48 89 c1             	mov    %rax,%rcx
ffffffff80002eec:	0f 1f 40 00          	nopl   0x0(%rax)
        *p++ = (unsigned char)c;
ffffffff80002ef0:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80002ef4:	c6 41 ff 00          	movb   $0x0,-0x1(%rcx)
    while(len--)
ffffffff80002ef8:	48 39 f1             	cmp    %rsi,%rcx
ffffffff80002efb:	75 f3                	jne    ffffffff80002ef0 <vmm_init+0x70>
    DEBUG_MSG("PageTable %p  %p", page, ret);
ffffffff80002efd:	48 c7 c6 3a 5b 00 80 	mov    $0xffffffff80005b3a,%rsi
ffffffff80002f04:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80002f09:	31 c0                	xor    %eax,%eax
    return 0xFFFF800000000000 + addr;
ffffffff80002f0b:	48 bb 00 00 00 00 00 	movabs $0xffff800000000000,%rbx
ffffffff80002f12:	80 ff ff 
ffffffff80002f15:	48 01 d3             	add    %rdx,%rbx
ffffffff80002f18:	48 89 d9             	mov    %rbx,%rcx
ffffffff80002f1b:	e8 60 15 00 00       	callq  ffffffff80004480 <serial_printf>
 
    //Create the Kernel PML4 table
    RootPageDirectory = vmm_create_page_table();

    //Figure out where the kernel is and how big it is from the boot_info struct
    uint64_t kernel_physical = boot_info.tag_kernel_base_address->physical_base_address;
ffffffff80002f20:	48 8b 05 a1 61 00 00 	mov    0x61a1(%rip),%rax        # ffffffff800090c8 <boot_info+0x8>
    RootPageDirectory = vmm_create_page_table();
ffffffff80002f27:	48 89 1d a2 d7 00 00 	mov    %rbx,0xd7a2(%rip)        # ffffffff800106d0 <RootPageDirectory>
    uint64_t kernel_virtual = boot_info.tag_kernel_base_address->virtual_base_address;
    uint64_t kernel_offset = kernel_virtual - kernel_physical;

    uint64_t kernel_size =   (uint64_t)&_end_of_kernel - (uint64_t)&_start_of_kernel;

    printf("Kernel Physical Base Address %x\n", kernel_physical);
ffffffff80002f2e:	48 c7 c7 58 5c 00 80 	mov    $0xffffffff80005c58,%rdi
    uint64_t kernel_size =   (uint64_t)&_end_of_kernel - (uint64_t)&_start_of_kernel;
ffffffff80002f35:	49 c7 c4 d8 1e 01 80 	mov    $0xffffffff80011ed8,%r12
ffffffff80002f3c:	49 81 ec 00 00 00 80 	sub    $0xffffffff80000000,%r12
    uint64_t kernel_physical = boot_info.tag_kernel_base_address->physical_base_address;
ffffffff80002f43:	4c 8b 70 10          	mov    0x10(%rax),%r14
    uint64_t kernel_virtual = boot_info.tag_kernel_base_address->virtual_base_address;
ffffffff80002f47:	4c 8b 68 18          	mov    0x18(%rax),%r13
    printf("Kernel Physical Base Address %x\n", kernel_physical);
ffffffff80002f4b:	31 c0                	xor    %eax,%eax
ffffffff80002f4d:	4c 89 f6             	mov    %r14,%rsi
    uint64_t kernel_offset = kernel_virtual - kernel_physical;
ffffffff80002f50:	4c 89 eb             	mov    %r13,%rbx
    printf("Kernel Physical Base Address %x\n", kernel_physical);
ffffffff80002f53:	e8 68 13 00 00       	callq  ffffffff800042c0 <printf_>
    uint64_t kernel_offset = kernel_virtual - kernel_physical;
ffffffff80002f58:	4c 29 f3             	sub    %r14,%rbx
    printf("Kernel Virtual Base Address  %x\n", kernel_virtual);
ffffffff80002f5b:	4c 89 ee             	mov    %r13,%rsi
ffffffff80002f5e:	31 c0                	xor    %eax,%eax
ffffffff80002f60:	48 c7 c7 80 5c 00 80 	mov    $0xffffffff80005c80,%rdi
ffffffff80002f67:	e8 54 13 00 00       	callq  ffffffff800042c0 <printf_>
    printf("Kernel Offset: %x\n", kernel_offset);
ffffffff80002f6c:	48 89 de             	mov    %rbx,%rsi
ffffffff80002f6f:	48 c7 c7 ef 5b 00 80 	mov    $0xffffffff80005bef,%rdi
ffffffff80002f76:	31 c0                	xor    %eax,%eax
ffffffff80002f78:	e8 43 13 00 00       	callq  ffffffff800042c0 <printf_>
    printf("Kernel Size: %x\n", kernel_size);
ffffffff80002f7d:	4c 89 e6             	mov    %r12,%rsi
ffffffff80002f80:	31 c0                	xor    %eax,%eax

    uint64_t aligned_size = (kernel_size + 0x1000) & ~(0xFFF);

    printf("Aligned Size: %x\n", aligned_size);

    for(uint64_t i = 0; i < aligned_size; i+=0x1000)
ffffffff80002f82:	31 db                	xor    %ebx,%ebx
    uint64_t aligned_size = (kernel_size + 0x1000) & ~(0xFFF);
ffffffff80002f84:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
    printf("Kernel Size: %x\n", kernel_size);
ffffffff80002f8b:	48 c7 c7 02 5c 00 80 	mov    $0xffffffff80005c02,%rdi
ffffffff80002f92:	e8 29 13 00 00       	callq  ffffffff800042c0 <printf_>
    uint64_t aligned_size = (kernel_size + 0x1000) & ~(0xFFF);
ffffffff80002f97:	49 81 e4 00 f0 ff ff 	and    $0xfffffffffffff000,%r12
    printf("Aligned Size: %x\n", aligned_size);
ffffffff80002f9e:	48 c7 c7 13 5c 00 80 	mov    $0xffffffff80005c13,%rdi
ffffffff80002fa5:	31 c0                	xor    %eax,%eax
ffffffff80002fa7:	4c 89 e6             	mov    %r12,%rsi
ffffffff80002faa:	e8 11 13 00 00       	callq  ffffffff800042c0 <printf_>
    for(uint64_t i = 0; i < aligned_size; i+=0x1000)
ffffffff80002faf:	4d 85 e4             	test   %r12,%r12
ffffffff80002fb2:	74 2a                	je     ffffffff80002fde <vmm_init+0x15e>
ffffffff80002fb4:	0f 1f 40 00          	nopl   0x0(%rax)
    {
        vmm_map_4Kpage(RootPageDirectory, kernel_virtual + i, kernel_physical + i, PTE_PRESENT | PTE_READWRITE);
ffffffff80002fb8:	48 8b 3d 11 d7 00 00 	mov    0xd711(%rip),%rdi        # ffffffff800106d0 <RootPageDirectory>
ffffffff80002fbf:	49 8d 14 1e          	lea    (%r14,%rbx,1),%rdx
ffffffff80002fc3:	49 8d 74 1d 00       	lea    0x0(%r13,%rbx,1),%rsi
ffffffff80002fc8:	b9 03 00 00 00       	mov    $0x3,%ecx
    for(uint64_t i = 0; i < aligned_size; i+=0x1000)
ffffffff80002fcd:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
        vmm_map_4Kpage(RootPageDirectory, kernel_virtual + i, kernel_physical + i, PTE_PRESENT | PTE_READWRITE);
ffffffff80002fd4:	e8 37 f9 ff ff       	callq  ffffffff80002910 <vmm_map_4Kpage>
    for(uint64_t i = 0; i < aligned_size; i+=0x1000)
ffffffff80002fd9:	4c 39 e3             	cmp    %r12,%rbx
ffffffff80002fdc:	72 da                	jb     ffffffff80002fb8 <vmm_init+0x138>
    //{
    //    vmm_map_4Kpage(RootPageDirectory, kernel_virt + (0x1000 * i), kernel_phys + (0x1000 * i), PTE_PRESENT | PTE_READWRITE);
    //}

    //Map Physical Memory to 0xFFFF8...
    printf("HHDM: %p\n", boot_info.tag_hhdm->addr);
ffffffff80002fde:	48 8b 05 1b 61 00 00 	mov    0x611b(%rip),%rax        # ffffffff80009100 <boot_info+0x40>
    uint64_t hhdm_addr = boot_info.tag_hhdm->addr;
    
    for(uint64_t i = 0; i < (4 * GB); i += GB)
ffffffff80002fe5:	45 31 ff             	xor    %r15d,%r15d
    printf("HHDM: %p\n", boot_info.tag_hhdm->addr);
ffffffff80002fe8:	48 c7 c7 25 5c 00 80 	mov    $0xffffffff80005c25,%rdi
    for(uint64_t i = 0; i < (4 * GB); i += GB)
ffffffff80002fef:	49 bc 00 00 00 00 01 	movabs $0x100000000,%r12
ffffffff80002ff6:	00 00 00 
    printf("HHDM: %p\n", boot_info.tag_hhdm->addr);
ffffffff80002ff9:	48 8b 70 10          	mov    0x10(%rax),%rsi
ffffffff80002ffd:	31 c0                	xor    %eax,%eax
ffffffff80002fff:	e8 bc 12 00 00       	callq  ffffffff800042c0 <printf_>
    uint64_t hhdm_addr = boot_info.tag_hhdm->addr;
ffffffff80003004:	48 8b 05 f5 60 00 00 	mov    0x60f5(%rip),%rax        # ffffffff80009100 <boot_info+0x40>
    {
        vmm_map_1Gpage(RootPageDirectory, hhdm_addr + i, i, PTE_PRESENT | PTE_READWRITE);
ffffffff8000300b:	4c 8b 35 be d6 00 00 	mov    0xd6be(%rip),%r14        # ffffffff800106d0 <RootPageDirectory>
    uint64_t hhdm_addr = boot_info.tag_hhdm->addr;
ffffffff80003012:	4c 8b 68 10          	mov    0x10(%rax),%r13
        vmm_map_1Gpage(RootPageDirectory, hhdm_addr + i, i, PTE_PRESENT | PTE_READWRITE);
ffffffff80003016:	4b 8d 5c 3d 00       	lea    0x0(%r13,%r15,1),%rbx
    vaddr >>= 9;
ffffffff8000301b:	49 89 d8             	mov    %rbx,%r8
    vaddr >>= 9;
ffffffff8000301e:	48 c1 eb 27          	shr    $0x27,%rbx
    index4 = vaddr & 0x1ff;
ffffffff80003022:	81 e3 ff 01 00 00    	and    $0x1ff,%ebx
    vaddr >>= 9;
ffffffff80003028:	49 c1 e8 1e          	shr    $0x1e,%r8
    if(pagemap->entry[index] & 1)
ffffffff8000302c:	49 8b 04 de          	mov    (%r14,%rbx,8),%rax
    index3 = vaddr & 0x1ff;
ffffffff80003030:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
    if(pagemap->entry[index] & 1)
ffffffff80003037:	a8 01                	test   $0x1,%al
ffffffff80003039:	0f 84 89 00 00 00    	je     ffffffff800030c8 <vmm_init+0x248>
        return (struct PageTable*)(pagemap->entry[index] & ~(0x1ff));
ffffffff8000303f:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
    PML3->entry[index3] = physical | flags | PTE_PAGESIZE;
ffffffff80003045:	4c 89 fa             	mov    %r15,%rdx
    for(uint64_t i = 0; i < (4 * GB); i += GB)
ffffffff80003048:	49 81 c7 00 00 00 40 	add    $0x40000000,%r15
    PML3->entry[index3] = physical | flags | PTE_PAGESIZE;
ffffffff8000304f:	80 ca 83             	or     $0x83,%dl
ffffffff80003052:	4a 89 14 c0          	mov    %rdx,(%rax,%r8,8)
    for(uint64_t i = 0; i < (4 * GB); i += GB)
ffffffff80003056:	4d 39 e7             	cmp    %r12,%r15
ffffffff80003059:	75 bb                	jne    ffffffff80003016 <vmm_init+0x196>
    for(uint64_t i = 0; i < pmm_info.totalmem ; i+=0x1000)
    {   
        vmm_map_4Kpage(RootPageDirectory, (boot_info.tag_hhdm->addr + i), i, PTE_PRESENT | PTE_READWRITE);
    }
    */
    DEBUG_MSG("New CR3: %p -- & %p \n", (uint64_t)RootPageDirectory, &RootPageDirectory);
ffffffff8000305b:	48 c7 c1 d0 06 01 80 	mov    $0xffffffff800106d0,%rcx
ffffffff80003062:	4c 89 f2             	mov    %r14,%rdx
ffffffff80003065:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000306a:	31 c0                	xor    %eax,%eax
ffffffff8000306c:	48 c7 c6 2f 5c 00 80 	mov    $0xffffffff80005c2f,%rsi
ffffffff80003073:	e8 08 14 00 00       	callq  ffffffff80004480 <serial_printf>
    printf("New CR3: %p -- & %p \n", (uint64_t)RootPageDirectory, &RootPageDirectory);
ffffffff80003078:	48 8b 35 51 d6 00 00 	mov    0xd651(%rip),%rsi        # ffffffff800106d0 <RootPageDirectory>
ffffffff8000307f:	48 c7 c2 d0 06 01 80 	mov    $0xffffffff800106d0,%rdx
ffffffff80003086:	31 c0                	xor    %eax,%eax
ffffffff80003088:	48 c7 c7 2f 5c 00 80 	mov    $0xffffffff80005c2f,%rdi
ffffffff8000308f:	e8 2c 12 00 00       	callq  ffffffff800042c0 <printf_>

    //Load new CR3
    vmm_write_cr3((uint64_t)RootPageDirectory);
ffffffff80003094:	48 8b 3d 35 d6 00 00 	mov    0xd635(%rip),%rdi        # ffffffff800106d0 <RootPageDirectory>
ffffffff8000309b:	e8 04 d3 ff ff       	callq  ffffffff800003a4 <vmm_write_cr3>

    //cycle through page entries


    
}
ffffffff800030a0:	48 83 c4 18          	add    $0x18,%rsp
    DEBUG_MSG("CR3 Loaded\n");
ffffffff800030a4:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800030a9:	31 c0                	xor    %eax,%eax
}
ffffffff800030ab:	5b                   	pop    %rbx
    DEBUG_MSG("CR3 Loaded\n");
ffffffff800030ac:	48 c7 c6 45 5c 00 80 	mov    $0xffffffff80005c45,%rsi
}
ffffffff800030b3:	41 5c                	pop    %r12
ffffffff800030b5:	41 5d                	pop    %r13
ffffffff800030b7:	41 5e                	pop    %r14
ffffffff800030b9:	41 5f                	pop    %r15
ffffffff800030bb:	5d                   	pop    %rbp
    DEBUG_MSG("CR3 Loaded\n");
ffffffff800030bc:	e9 bf 13 00 00       	jmpq   ffffffff80004480 <serial_printf>
ffffffff800030c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    void* page = pmm_allocpage();   //get a page
ffffffff800030c8:	31 c0                	xor    %eax,%eax
ffffffff800030ca:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
ffffffff800030ce:	e8 bd f2 ff ff       	callq  ffffffff80002390 <pmm_allocpage>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff800030d3:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff800030d7:	48 85 c0             	test   %rax,%rax
    void* page = pmm_allocpage();   //get a page
ffffffff800030da:	48 89 c2             	mov    %rax,%rdx
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff800030dd:	74 79                	je     ffffffff80003158 <vmm_init+0x2d8>
ffffffff800030df:	48 8d b0 00 10 00 00 	lea    0x1000(%rax),%rsi
ffffffff800030e6:	48 89 c1             	mov    %rax,%rcx
ffffffff800030e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        *p++ = (unsigned char)c;
ffffffff800030f0:	48 83 c1 01          	add    $0x1,%rcx
ffffffff800030f4:	c6 41 ff 00          	movb   $0x0,-0x1(%rcx)
    while(len--)
ffffffff800030f8:	48 39 f1             	cmp    %rsi,%rcx
ffffffff800030fb:	75 f3                	jne    ffffffff800030f0 <vmm_init+0x270>
    DEBUG_MSG("PageTable %p  %p", page, ret);
ffffffff800030fd:	48 c7 c6 3a 5b 00 80 	mov    $0xffffffff80005b3a,%rsi
ffffffff80003104:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003109:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
ffffffff8000310d:	48 b8 00 00 00 00 00 	movabs $0xffff800000000000,%rax
ffffffff80003114:	80 ff ff 
ffffffff80003117:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
ffffffff8000311b:	31 c0                	xor    %eax,%eax
ffffffff8000311d:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff80003121:	e8 5a 13 00 00       	callq  ffffffff80004480 <serial_printf>
        if(!newentry) printf("Null page allocated!\n");
ffffffff80003126:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff8000312a:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
ffffffff8000312e:	48 85 c9             	test   %rcx,%rcx
ffffffff80003131:	74 25                	je     ffffffff80003158 <vmm_init+0x2d8>
        pagemap->entry[index] = newentry | flags;
ffffffff80003133:	48 89 ca             	mov    %rcx,%rdx
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff80003136:	48 89 c8             	mov    %rcx,%rax
        pagemap->entry[index] = newentry | flags;
ffffffff80003139:	48 83 ca 03          	or     $0x3,%rdx
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff8000313d:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
        pagemap->entry[index] = newentry | flags;
ffffffff80003143:	49 89 14 de          	mov    %rdx,(%r14,%rbx,8)
    DEBUG_MSG("New CR3: %p -- & %p \n", (uint64_t)RootPageDirectory, &RootPageDirectory);
ffffffff80003147:	4c 8b 35 82 d5 00 00 	mov    0xd582(%rip),%r14        # ffffffff800106d0 <RootPageDirectory>
ffffffff8000314e:	e9 f2 fe ff ff       	jmpq   ffffffff80003045 <vmm_init+0x1c5>
ffffffff80003153:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        if(!newentry) printf("Null page allocated!\n");
ffffffff80003158:	48 c7 c7 4b 5b 00 80 	mov    $0xffffffff80005b4b,%rdi
ffffffff8000315f:	31 c0                	xor    %eax,%eax
ffffffff80003161:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
ffffffff80003165:	e8 56 11 00 00       	callq  ffffffff800042c0 <printf_>
ffffffff8000316a:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff8000316e:	31 c0                	xor    %eax,%eax
ffffffff80003170:	ba 03 00 00 00       	mov    $0x3,%edx
ffffffff80003175:	eb cc                	jmp    ffffffff80003143 <vmm_init+0x2c3>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff80003177:	31 db                	xor    %ebx,%ebx
ffffffff80003179:	e9 a2 fd ff ff       	jmpq   ffffffff80002f20 <vmm_init+0xa0>
ffffffff8000317e:	66 90                	xchg   %ax,%ax

ffffffff80003180 <schedule>:
#include "../memory/memory.h"


struct thread_control_block* threads[512];

void schedule()
ffffffff80003180:	c3                   	retq   
ffffffff80003181:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80003188:	00 00 00 00 
ffffffff8000318c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80003190 <scheduler_init>:
}

void scheduler_init()
{

ffffffff80003190:	c3                   	retq   
ffffffff80003191:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80003198:	00 00 00 
ffffffff8000319b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff800031a0 <user_init>:
extern void __syscall_handler();
extern void enable_syscall(uint64_t STAR, void* handler);

void user_init()
{
    enable_syscall(0x00180008, &__syscall_handler);
ffffffff800031a0:	48 c7 c6 4c 04 00 80 	mov    $0xffffffff8000044c,%rsi
ffffffff800031a7:	bf 08 00 18 00       	mov    $0x180008,%edi
ffffffff800031ac:	e9 54 d2 ff ff       	jmpq   ffffffff80000405 <enable_syscall>
ffffffff800031b1:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800031b8:	00 00 00 00 
ffffffff800031bc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff800031c0 <syscall_handler>:
    //set_lstar(__syscall_handler);
}

uint64_t syscall_handler(uint64_t num, uint64_t param1, uint64_t param2, uint64_t param3, uint64_t param4, uint64_t param5)
{
    switch(num)
ffffffff800031c0:	48 83 ff 01          	cmp    $0x1,%rdi
ffffffff800031c4:	74 2a                	je     ffffffff800031f0 <syscall_handler+0x30>
ffffffff800031c6:	76 0c                	jbe    ffffffff800031d4 <syscall_handler+0x14>
ffffffff800031c8:	48 83 ff 03          	cmp    $0x3,%rdi
ffffffff800031cc:	76 06                	jbe    ffffffff800031d4 <syscall_handler+0x14>
ffffffff800031ce:	48 83 ff 10          	cmp    $0x10,%rdi
ffffffff800031d2:	75 0c                	jne    ffffffff800031e0 <syscall_handler+0x20>
{
ffffffff800031d4:	31 c0                	xor    %eax,%eax
        default:
            return -1;
    }

    return 0;
}
ffffffff800031d6:	c3                   	retq   
ffffffff800031d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800031de:	00 00 
            return -1;
ffffffff800031e0:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff800031e7:	c3                   	retq   
ffffffff800031e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff800031ef:	00 
{
ffffffff800031f0:	55                   	push   %rbp
            printf((char*)param1);
ffffffff800031f1:	48 89 f7             	mov    %rsi,%rdi
ffffffff800031f4:	31 c0                	xor    %eax,%eax
{
ffffffff800031f6:	48 89 e5             	mov    %rsp,%rbp
            printf((char*)param1);
ffffffff800031f9:	e8 c2 10 00 00       	callq  ffffffff800042c0 <printf_>
{
ffffffff800031fe:	31 c0                	xor    %eax,%eax
}
ffffffff80003200:	5d                   	pop    %rbp
ffffffff80003201:	c3                   	retq   
ffffffff80003202:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80003209:	00 00 00 
ffffffff8000320c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80003210 <_out_buffer>:


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  if (idx < maxlen) {
ffffffff80003210:	48 39 ca             	cmp    %rcx,%rdx
ffffffff80003213:	73 04                	jae    ffffffff80003219 <_out_buffer+0x9>
    ((char*)buffer)[idx] = character;
ffffffff80003215:	40 88 3c 16          	mov    %dil,(%rsi,%rdx,1)
  }
}
ffffffff80003219:	c3                   	retq   
ffffffff8000321a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80003220 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
ffffffff80003220:	c3                   	retq   
ffffffff80003221:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80003228:	00 00 00 00 
ffffffff8000322c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80003230 <_ntoa_long>:
}


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
ffffffff80003230:	55                   	push   %rbp
ffffffff80003231:	48 89 e5             	mov    %rsp,%rbp
ffffffff80003234:	41 57                	push   %r15
ffffffff80003236:	41 56                	push   %r14
ffffffff80003238:	49 89 ce             	mov    %rcx,%r14
ffffffff8000323b:	41 55                	push   %r13
ffffffff8000323d:	49 89 f5             	mov    %rsi,%r13
ffffffff80003240:	44 89 ce             	mov    %r9d,%esi
ffffffff80003243:	41 54                	push   %r12
ffffffff80003245:	49 89 fc             	mov    %rdi,%r12
ffffffff80003248:	53                   	push   %rbx
ffffffff80003249:	48 83 ec 48          	sub    $0x48,%rsp
ffffffff8000324d:	44 8b 55 28          	mov    0x28(%rbp),%r10d
ffffffff80003251:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
ffffffff80003255:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff80003259:	45 89 d7             	mov    %r10d,%r15d
ffffffff8000325c:	41 81 e7 00 04 00 00 	and    $0x400,%r15d
  if (!value) {
ffffffff80003263:	4d 85 c0             	test   %r8,%r8
ffffffff80003266:	0f 84 84 03 00 00    	je     ffffffff800035f0 <_ntoa_long+0x3c0>
  if (flags & FLAGS_HASH) {
ffffffff8000326c:	44 89 d1             	mov    %r10d,%ecx
ffffffff8000326f:	83 e1 10             	and    $0x10,%ecx
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80003272:	44 89 d2             	mov    %r10d,%edx
ffffffff80003275:	89 4d a8             	mov    %ecx,-0x58(%rbp)
ffffffff80003278:	4c 8d 4d af          	lea    -0x51(%rbp),%r9
ffffffff8000327c:	83 e2 20             	and    $0x20,%edx
ffffffff8000327f:	44 89 7d 9c          	mov    %r15d,-0x64(%rbp)
ffffffff80003283:	83 fa 01             	cmp    $0x1,%edx
ffffffff80003286:	45 19 db             	sbb    %r11d,%r11d
ffffffff80003289:	31 db                	xor    %ebx,%ebx
ffffffff8000328b:	41 83 e3 20          	and    $0x20,%r11d
ffffffff8000328f:	41 83 c3 37          	add    $0x37,%r11d
ffffffff80003293:	eb 06                	jmp    ffffffff8000329b <_ntoa_long+0x6b>
ffffffff80003295:	0f 1f 00             	nopl   (%rax)
      value /= base;
ffffffff80003298:	49 89 c0             	mov    %rax,%r8
      const char digit = (char)(value % base);
ffffffff8000329b:	31 d2                	xor    %edx,%edx
ffffffff8000329d:	4c 89 c0             	mov    %r8,%rax
ffffffff800032a0:	48 f7 f7             	div    %rdi
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff800032a3:	48 83 fa 09          	cmp    $0x9,%rdx
ffffffff800032a7:	44 8d 7a 30          	lea    0x30(%rdx),%r15d
ffffffff800032ab:	41 8d 0c 13          	lea    (%r11,%rdx,1),%ecx
ffffffff800032af:	41 0f 46 cf          	cmovbe %r15d,%ecx
ffffffff800032b3:	48 83 c3 01          	add    $0x1,%rbx
ffffffff800032b7:	41 88 0c 19          	mov    %cl,(%r9,%rbx,1)
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff800032bb:	48 83 fb 1f          	cmp    $0x1f,%rbx
ffffffff800032bf:	77 05                	ja     ffffffff800032c6 <_ntoa_long+0x96>
ffffffff800032c1:	49 39 f8             	cmp    %rdi,%r8
ffffffff800032c4:	73 d2                	jae    ffffffff80003298 <_ntoa_long+0x68>
  if (!(flags & FLAGS_LEFT)) {
ffffffff800032c6:	45 89 d0             	mov    %r10d,%r8d
ffffffff800032c9:	8b 4d a8             	mov    -0x58(%rbp),%ecx
ffffffff800032cc:	44 8b 7d 9c          	mov    -0x64(%rbp),%r15d
ffffffff800032d0:	41 83 e0 02          	and    $0x2,%r8d
ffffffff800032d4:	0f 85 a5 00 00 00    	jne    ffffffff8000337f <_ntoa_long+0x14f>
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800032da:	8b 55 18             	mov    0x18(%rbp),%edx
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
ffffffff800032dd:	45 89 d0             	mov    %r10d,%r8d
ffffffff800032e0:	8b 45 20             	mov    0x20(%rbp),%eax
ffffffff800032e3:	41 83 e0 01          	and    $0x1,%r8d
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800032e7:	48 83 fb 1f          	cmp    $0x1f,%rbx
ffffffff800032eb:	41 0f 96 c3          	setbe  %r11b
ffffffff800032ef:	48 39 d3             	cmp    %rdx,%rbx
ffffffff800032f2:	41 0f 92 c1          	setb   %r9b
ffffffff800032f6:	45 21 d9             	and    %r11d,%r9d
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
ffffffff800032f9:	85 c0                	test   %eax,%eax
ffffffff800032fb:	74 23                	je     ffffffff80003320 <_ntoa_long+0xf0>
ffffffff800032fd:	45 85 c0             	test   %r8d,%r8d
ffffffff80003300:	0f 84 5a 03 00 00    	je     ffffffff80003660 <_ntoa_long+0x430>
ffffffff80003306:	40 84 f6             	test   %sil,%sil
ffffffff80003309:	75 06                	jne    ffffffff80003311 <_ntoa_long+0xe1>
ffffffff8000330b:	41 f6 c2 0c          	test   $0xc,%r10b
ffffffff8000330f:	74 04                	je     ffffffff80003315 <_ntoa_long+0xe5>
      width--;
ffffffff80003311:	83 6d 20 01          	subl   $0x1,0x20(%rbp)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003315:	45 84 c9             	test   %r9b,%r9b
ffffffff80003318:	75 0b                	jne    ffffffff80003325 <_ntoa_long+0xf5>
ffffffff8000331a:	eb 35                	jmp    ffffffff80003351 <_ntoa_long+0x121>
ffffffff8000331c:	0f 1f 40 00          	nopl   0x0(%rax)
ffffffff80003320:	45 84 c9             	test   %r9b,%r9b
ffffffff80003323:	74 1f                	je     ffffffff80003344 <_ntoa_long+0x114>
ffffffff80003325:	4c 8d 4d af          	lea    -0x51(%rbp),%r9
ffffffff80003329:	eb 0b                	jmp    ffffffff80003336 <_ntoa_long+0x106>
ffffffff8000332b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
ffffffff80003330:	48 83 fb 1f          	cmp    $0x1f,%rbx
ffffffff80003334:	77 0e                	ja     ffffffff80003344 <_ntoa_long+0x114>
      buf[len++] = '0';
ffffffff80003336:	48 83 c3 01          	add    $0x1,%rbx
ffffffff8000333a:	41 c6 04 19 30       	movb   $0x30,(%r9,%rbx,1)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff8000333f:	48 39 d3             	cmp    %rdx,%rbx
ffffffff80003342:	72 ec                	jb     ffffffff80003330 <_ntoa_long+0x100>
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003344:	45 85 c0             	test   %r8d,%r8d
ffffffff80003347:	74 36                	je     ffffffff8000337f <_ntoa_long+0x14f>
ffffffff80003349:	48 83 fb 1f          	cmp    $0x1f,%rbx
ffffffff8000334d:	41 0f 96 c3          	setbe  %r11b
ffffffff80003351:	8b 55 20             	mov    0x20(%rbp),%edx
ffffffff80003354:	48 39 d3             	cmp    %rdx,%rbx
ffffffff80003357:	73 23                	jae    ffffffff8000337c <_ntoa_long+0x14c>
ffffffff80003359:	45 84 db             	test   %r11b,%r11b
ffffffff8000335c:	74 1e                	je     ffffffff8000337c <_ntoa_long+0x14c>
ffffffff8000335e:	4c 8d 4d af          	lea    -0x51(%rbp),%r9
ffffffff80003362:	eb 09                	jmp    ffffffff8000336d <_ntoa_long+0x13d>
ffffffff80003364:	0f 1f 40 00          	nopl   0x0(%rax)
ffffffff80003368:	48 39 d3             	cmp    %rdx,%rbx
ffffffff8000336b:	73 0f                	jae    ffffffff8000337c <_ntoa_long+0x14c>
      buf[len++] = '0';
ffffffff8000336d:	48 83 c3 01          	add    $0x1,%rbx
ffffffff80003371:	41 c6 04 19 30       	movb   $0x30,(%r9,%rbx,1)
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003376:	48 83 fb 1f          	cmp    $0x1f,%rbx
ffffffff8000337a:	76 ec                	jbe    ffffffff80003368 <_ntoa_long+0x138>
ffffffff8000337c:	45 31 c0             	xor    %r8d,%r8d
  if (flags & FLAGS_HASH) {
ffffffff8000337f:	85 c9                	test   %ecx,%ecx
ffffffff80003381:	0f 84 e5 00 00 00    	je     ffffffff8000346c <_ntoa_long+0x23c>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff80003387:	45 85 ff             	test   %r15d,%r15d
ffffffff8000338a:	0f 84 a0 01 00 00    	je     ffffffff80003530 <_ntoa_long+0x300>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003390:	48 83 ff 10          	cmp    $0x10,%rdi
ffffffff80003394:	0f 84 e6 02 00 00    	je     ffffffff80003680 <_ntoa_long+0x450>
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff8000339a:	83 ff 02             	cmp    $0x2,%edi
ffffffff8000339d:	75 12                	jne    ffffffff800033b1 <_ntoa_long+0x181>
ffffffff8000339f:	48 83 fb 1f          	cmp    $0x1f,%rbx
ffffffff800033a3:	77 0c                	ja     ffffffff800033b1 <_ntoa_long+0x181>
    for (size_t i = len; i < width; i++) {
ffffffff800033a5:	48 89 da             	mov    %rbx,%rdx
ffffffff800033a8:	48 83 c3 01          	add    $0x1,%rbx
      buf[len++] = 'b';
ffffffff800033ac:	c6 44 15 b0 62       	movb   $0x62,-0x50(%rbp,%rdx,1)
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
ffffffff800033b1:	48 83 fb 20          	cmp    $0x20,%rbx
ffffffff800033b5:	0f 85 a5 00 00 00    	jne    ffffffff80003460 <_ntoa_long+0x230>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800033bb:	41 83 e2 03          	and    $0x3,%r10d
ffffffff800033bf:	0f 85 1b 03 00 00    	jne    ffffffff800036e0 <_ntoa_long+0x4b0>
    for (size_t i = len; i < width; i++) {
ffffffff800033c5:	83 7d 20 20          	cmpl   $0x20,0x20(%rbp)
ffffffff800033c9:	8b 4d 20             	mov    0x20(%rbp),%ecx
ffffffff800033cc:	0f 86 0e 03 00 00    	jbe    ffffffff800036e0 <_ntoa_long+0x4b0>
      buf[len++] = '-';
ffffffff800033d2:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
ffffffff800033d6:	48 89 d8             	mov    %rbx,%rax
ffffffff800033d9:	44 89 45 9c          	mov    %r8d,-0x64(%rbp)
ffffffff800033dd:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
ffffffff800033e1:	48 89 cb             	mov    %rcx,%rbx
ffffffff800033e4:	48 29 f0             	sub    %rsi,%rax
ffffffff800033e7:	4c 89 6d a8          	mov    %r13,-0x58(%rbp)
ffffffff800033eb:	49 89 f5             	mov    %rsi,%r13
ffffffff800033ee:	49 89 c7             	mov    %rax,%r15
ffffffff800033f1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      out(' ', buffer, idx++, maxlen);
ffffffff800033f8:	4c 89 ea             	mov    %r13,%rdx
ffffffff800033fb:	49 83 c5 01          	add    $0x1,%r13
ffffffff800033ff:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
ffffffff80003403:	4c 89 f1             	mov    %r14,%rcx
ffffffff80003406:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff8000340b:	41 ff d4             	callq  *%r12
    for (size_t i = len; i < width; i++) {
ffffffff8000340e:	4b 8d 54 3d 00       	lea    0x0(%r13,%r15,1),%rdx
ffffffff80003413:	48 39 da             	cmp    %rbx,%rdx
ffffffff80003416:	72 e0                	jb     ffffffff800033f8 <_ntoa_long+0x1c8>
      out(' ', buffer, idx++, maxlen);
ffffffff80003418:	48 89 d9             	mov    %rbx,%rcx
ffffffff8000341b:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
ffffffff8000341f:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
ffffffff80003423:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
ffffffff80003427:	44 8b 45 9c          	mov    -0x64(%rbp),%r8d
ffffffff8000342b:	4c 8b 6d a8          	mov    -0x58(%rbp),%r13
ffffffff8000342f:	48 8d 53 01          	lea    0x1(%rbx),%rdx
ffffffff80003433:	48 29 d8             	sub    %rbx,%rax
ffffffff80003436:	48 39 d1             	cmp    %rdx,%rcx
ffffffff80003439:	ba 00 00 00 00       	mov    $0x0,%edx
ffffffff8000343e:	48 0f 42 c2          	cmovb  %rdx,%rax
ffffffff80003442:	4c 8d 7c 06 01       	lea    0x1(%rsi,%rax,1),%r15
  while (len) {
ffffffff80003447:	48 85 db             	test   %rbx,%rbx
ffffffff8000344a:	75 38                	jne    ffffffff80003484 <_ntoa_long+0x254>
ffffffff8000344c:	eb 7c                	jmp    ffffffff800034ca <_ntoa_long+0x29a>
      buf[len++] = 'x';
ffffffff8000344e:	c6 44 1d b0 78       	movb   $0x78,-0x50(%rbp,%rbx,1)
ffffffff80003453:	48 89 d3             	mov    %rdx,%rbx
ffffffff80003456:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000345d:	00 00 00 
    for (size_t i = len; i < width; i++) {
ffffffff80003460:	48 89 da             	mov    %rbx,%rdx
ffffffff80003463:	48 83 c3 01          	add    $0x1,%rbx
      buf[len++] = '0';
ffffffff80003467:	c6 44 15 b0 30       	movb   $0x30,-0x50(%rbp,%rdx,1)
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
ffffffff8000346c:	48 83 fb 20          	cmp    $0x20,%rbx
ffffffff80003470:	0f 85 4c 01 00 00    	jne    ffffffff800035c2 <_ntoa_long+0x392>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff80003476:	41 83 e2 03          	and    $0x3,%r10d
ffffffff8000347a:	0f 84 18 01 00 00    	je     ffffffff80003598 <_ntoa_long+0x368>
ffffffff80003480:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
ffffffff80003484:	44 89 45 9c          	mov    %r8d,-0x64(%rbp)
ffffffff80003488:	49 8d 04 1f          	lea    (%r15,%rbx,1),%rax
ffffffff8000348c:	4c 89 6d a8          	mov    %r13,-0x58(%rbp)
ffffffff80003490:	49 89 dd             	mov    %rbx,%r13
ffffffff80003493:	48 89 c3             	mov    %rax,%rbx
ffffffff80003496:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000349d:	00 00 00 
ffffffff800034a0:	48 89 da             	mov    %rbx,%rdx
    out(buf[--len], buffer, idx++, maxlen);
ffffffff800034a3:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
ffffffff800034a7:	49 89 df             	mov    %rbx,%r15
ffffffff800034aa:	4c 89 f1             	mov    %r14,%rcx
ffffffff800034ad:	4c 29 ea             	sub    %r13,%rdx
ffffffff800034b0:	49 83 ed 01          	sub    $0x1,%r13
ffffffff800034b4:	42 0f be 7c 2d b0    	movsbl -0x50(%rbp,%r13,1),%edi
ffffffff800034ba:	41 ff d4             	callq  *%r12
  while (len) {
ffffffff800034bd:	4d 85 ed             	test   %r13,%r13
ffffffff800034c0:	75 de                	jne    ffffffff800034a0 <_ntoa_long+0x270>
ffffffff800034c2:	44 8b 45 9c          	mov    -0x64(%rbp),%r8d
ffffffff800034c6:	4c 8b 6d a8          	mov    -0x58(%rbp),%r13
  if (flags & FLAGS_LEFT) {
ffffffff800034ca:	45 85 c0             	test   %r8d,%r8d
ffffffff800034cd:	74 4b                	je     ffffffff8000351a <_ntoa_long+0x2ea>
    while (idx - start_idx < width) {
ffffffff800034cf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
ffffffff800034d3:	4c 89 fb             	mov    %r15,%rbx
ffffffff800034d6:	48 29 c3             	sub    %rax,%rbx
ffffffff800034d9:	8b 45 20             	mov    0x20(%rbp),%eax
ffffffff800034dc:	48 39 c3             	cmp    %rax,%rbx
ffffffff800034df:	73 39                	jae    ffffffff8000351a <_ntoa_long+0x2ea>
ffffffff800034e1:	4c 89 6d a8          	mov    %r13,-0x58(%rbp)
ffffffff800034e5:	4d 89 e5             	mov    %r12,%r13
ffffffff800034e8:	49 89 c4             	mov    %rax,%r12
ffffffff800034eb:	4c 89 f0             	mov    %r14,%rax
ffffffff800034ee:	4d 89 fe             	mov    %r15,%r14
ffffffff800034f1:	49 89 c7             	mov    %rax,%r15
ffffffff800034f4:	0f 1f 40 00          	nopl   0x0(%rax)
ffffffff800034f8:	48 83 c3 01          	add    $0x1,%rbx
ffffffff800034fc:	4c 89 f2             	mov    %r14,%rdx
      out(' ', buffer, idx++, maxlen);
ffffffff800034ff:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
ffffffff80003503:	4c 89 f9             	mov    %r15,%rcx
ffffffff80003506:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff8000350b:	49 83 c6 01          	add    $0x1,%r14
ffffffff8000350f:	41 ff d5             	callq  *%r13
    while (idx - start_idx < width) {
ffffffff80003512:	4c 39 e3             	cmp    %r12,%rbx
ffffffff80003515:	72 e1                	jb     ffffffff800034f8 <_ntoa_long+0x2c8>
ffffffff80003517:	4d 89 f7             	mov    %r14,%r15
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
ffffffff8000351a:	48 83 c4 48          	add    $0x48,%rsp
ffffffff8000351e:	4c 89 f8             	mov    %r15,%rax
ffffffff80003521:	5b                   	pop    %rbx
ffffffff80003522:	41 5c                	pop    %r12
ffffffff80003524:	41 5d                	pop    %r13
ffffffff80003526:	41 5e                	pop    %r14
ffffffff80003528:	41 5f                	pop    %r15
ffffffff8000352a:	5d                   	pop    %rbp
ffffffff8000352b:	c3                   	retq   
ffffffff8000352c:	0f 1f 40 00          	nopl   0x0(%rax)
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff80003530:	48 85 db             	test   %rbx,%rbx
ffffffff80003533:	0f 84 f7 00 00 00    	je     ffffffff80003630 <_ntoa_long+0x400>
ffffffff80003539:	8b 55 18             	mov    0x18(%rbp),%edx
ffffffff8000353c:	48 39 d3             	cmp    %rdx,%rbx
ffffffff8000353f:	74 0c                	je     ffffffff8000354d <_ntoa_long+0x31d>
ffffffff80003541:	8b 55 20             	mov    0x20(%rbp),%edx
ffffffff80003544:	48 39 d3             	cmp    %rdx,%rbx
ffffffff80003547:	0f 85 43 fe ff ff    	jne    ffffffff80003390 <_ntoa_long+0x160>
      if (len && (base == 16U)) {
ffffffff8000354d:	48 8d 53 ff          	lea    -0x1(%rbx),%rdx
ffffffff80003551:	48 83 fb 01          	cmp    $0x1,%rbx
ffffffff80003555:	0f 84 b7 01 00 00    	je     ffffffff80003712 <_ntoa_long+0x4e2>
ffffffff8000355b:	83 ff 10             	cmp    $0x10,%edi
ffffffff8000355e:	0f 85 ae 01 00 00    	jne    ffffffff80003712 <_ntoa_long+0x4e2>
        len--;
ffffffff80003564:	48 83 eb 02          	sub    $0x2,%rbx
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003568:	41 f6 c2 20          	test   $0x20,%r10b
ffffffff8000356c:	0f 84 dc fe ff ff    	je     ffffffff8000344e <_ntoa_long+0x21e>
      buf[len++] = 'X';
ffffffff80003572:	c6 44 1d b0 58       	movb   $0x58,-0x50(%rbp,%rbx,1)
ffffffff80003577:	48 89 d3             	mov    %rdx,%rbx
ffffffff8000357a:	e9 e1 fe ff ff       	jmpq   ffffffff80003460 <_ntoa_long+0x230>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff8000357f:	48 83 fb 20          	cmp    $0x20,%rbx
ffffffff80003583:	0f 85 9e 01 00 00    	jne    ffffffff80003727 <_ntoa_long+0x4f7>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff80003589:	85 d2                	test   %edx,%edx
ffffffff8000358b:	0f 85 ef fe ff ff    	jne    ffffffff80003480 <_ntoa_long+0x250>
ffffffff80003591:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    for (size_t i = len; i < width; i++) {
ffffffff80003598:	83 7d 20 20          	cmpl   $0x20,0x20(%rbp)
ffffffff8000359c:	8b 4d 20             	mov    0x20(%rbp),%ecx
ffffffff8000359f:	0f 87 2d fe ff ff    	ja     ffffffff800033d2 <_ntoa_long+0x1a2>
ffffffff800035a5:	e9 d6 fe ff ff       	jmpq   ffffffff80003480 <_ntoa_long+0x250>
ffffffff800035aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  if (!(flags & FLAGS_LEFT)) {
ffffffff800035b0:	41 83 e2 02          	and    $0x2,%r10d
ffffffff800035b4:	45 89 d0             	mov    %r10d,%r8d
ffffffff800035b7:	0f 84 b3 00 00 00    	je     ffffffff80003670 <_ntoa_long+0x440>
ffffffff800035bd:	41 89 d2             	mov    %edx,%r10d
  size_t len = 0U;
ffffffff800035c0:	31 db                	xor    %ebx,%ebx
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800035c2:	44 89 d2             	mov    %r10d,%edx
ffffffff800035c5:	83 e2 03             	and    $0x3,%edx
    if (negative) {
ffffffff800035c8:	40 84 f6             	test   %sil,%sil
ffffffff800035cb:	74 3b                	je     ffffffff80003608 <_ntoa_long+0x3d8>
      buf[len++] = '-';
ffffffff800035cd:	c6 44 1d b0 2d       	movb   $0x2d,-0x50(%rbp,%rbx,1)
ffffffff800035d2:	48 8d 43 01          	lea    0x1(%rbx),%rax
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800035d6:	85 d2                	test   %edx,%edx
ffffffff800035d8:	75 45                	jne    ffffffff8000361f <_ntoa_long+0x3ef>
    for (size_t i = len; i < width; i++) {
ffffffff800035da:	8b 4d 20             	mov    0x20(%rbp),%ecx
      buf[len++] = '-';
ffffffff800035dd:	48 89 c3             	mov    %rax,%rbx
    for (size_t i = len; i < width; i++) {
ffffffff800035e0:	48 39 c8             	cmp    %rcx,%rax
ffffffff800035e3:	0f 82 e9 fd ff ff    	jb     ffffffff800033d2 <_ntoa_long+0x1a2>
ffffffff800035e9:	e9 92 fe ff ff       	jmpq   ffffffff80003480 <_ntoa_long+0x250>
ffffffff800035ee:	66 90                	xchg   %ax,%ax
    flags &= ~FLAGS_HASH;
ffffffff800035f0:	44 89 d2             	mov    %r10d,%edx
ffffffff800035f3:	83 e2 ef             	and    $0xffffffef,%edx
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff800035f6:	45 85 ff             	test   %r15d,%r15d
ffffffff800035f9:	75 b5                	jne    ffffffff800035b0 <_ntoa_long+0x380>
ffffffff800035fb:	31 c9                	xor    %ecx,%ecx
ffffffff800035fd:	41 89 d2             	mov    %edx,%r10d
ffffffff80003600:	e9 6d fc ff ff       	jmpq   ffffffff80003272 <_ntoa_long+0x42>
ffffffff80003605:	0f 1f 00             	nopl   (%rax)
    else if (flags & FLAGS_PLUS) {
ffffffff80003608:	41 f6 c2 04          	test   $0x4,%r10b
ffffffff8000360c:	0f 84 9e 00 00 00    	je     ffffffff800036b0 <_ntoa_long+0x480>
      buf[len++] = '+';  // ignore the space if the '+' exists
ffffffff80003612:	c6 44 1d b0 2b       	movb   $0x2b,-0x50(%rbp,%rbx,1)
ffffffff80003617:	48 8d 43 01          	lea    0x1(%rbx),%rax
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff8000361b:	85 d2                	test   %edx,%edx
ffffffff8000361d:	74 bb                	je     ffffffff800035da <_ntoa_long+0x3aa>
ffffffff8000361f:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
      buf[len++] = ' ';
ffffffff80003623:	48 89 c3             	mov    %rax,%rbx
ffffffff80003626:	e9 59 fe ff ff       	jmpq   ffffffff80003484 <_ntoa_long+0x254>
ffffffff8000362b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003630:	48 83 ff 10          	cmp    $0x10,%rdi
ffffffff80003634:	0f 84 06 01 00 00    	je     ffffffff80003740 <_ntoa_long+0x510>
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff8000363a:	48 83 ff 02          	cmp    $0x2,%rdi
ffffffff8000363e:	0f 85 c0 00 00 00    	jne    ffffffff80003704 <_ntoa_long+0x4d4>
ffffffff80003644:	ba 62 00 00 00       	mov    $0x62,%edx
      buf[len++] = 'x';
ffffffff80003649:	88 55 b0             	mov    %dl,-0x50(%rbp)
      buf[len++] = '0';
ffffffff8000364c:	bb 02 00 00 00       	mov    $0x2,%ebx
ffffffff80003651:	c6 45 b1 30          	movb   $0x30,-0x4f(%rbp)
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
ffffffff80003655:	e9 68 ff ff ff       	jmpq   ffffffff800035c2 <_ntoa_long+0x392>
ffffffff8000365a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003660:	45 84 c9             	test   %r9b,%r9b
ffffffff80003663:	0f 85 bc fc ff ff    	jne    ffffffff80003325 <_ntoa_long+0xf5>
ffffffff80003669:	e9 11 fd ff ff       	jmpq   ffffffff8000337f <_ntoa_long+0x14f>
ffffffff8000366e:	66 90                	xchg   %ax,%ax
  if (!(flags & FLAGS_LEFT)) {
ffffffff80003670:	31 c9                	xor    %ecx,%ecx
ffffffff80003672:	41 89 d2             	mov    %edx,%r10d
  size_t len = 0U;
ffffffff80003675:	31 db                	xor    %ebx,%ebx
ffffffff80003677:	e9 5e fc ff ff       	jmpq   ffffffff800032da <_ntoa_long+0xaa>
ffffffff8000367c:	0f 1f 40 00          	nopl   0x0(%rax)
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff80003680:	44 89 d2             	mov    %r10d,%edx
ffffffff80003683:	83 e2 03             	and    $0x3,%edx
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003686:	41 f6 c2 20          	test   $0x20,%r10b
ffffffff8000368a:	0f 84 ef fe ff ff    	je     ffffffff8000357f <_ntoa_long+0x34f>
    for (size_t i = len; i < width; i++) {
ffffffff80003690:	48 8d 4b 01          	lea    0x1(%rbx),%rcx
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003694:	48 83 fb 20          	cmp    $0x20,%rbx
ffffffff80003698:	74 3e                	je     ffffffff800036d8 <_ntoa_long+0x4a8>
      buf[len++] = 'X';
ffffffff8000369a:	c6 44 1d b0 58       	movb   $0x58,-0x50(%rbp,%rbx,1)
ffffffff8000369f:	48 89 cb             	mov    %rcx,%rbx
ffffffff800036a2:	e9 0a fd ff ff       	jmpq   ffffffff800033b1 <_ntoa_long+0x181>
ffffffff800036a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800036ae:	00 00 
    else if (flags & FLAGS_SPACE) {
ffffffff800036b0:	41 83 e2 08          	and    $0x8,%r10d
ffffffff800036b4:	75 38                	jne    ffffffff800036ee <_ntoa_long+0x4be>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800036b6:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
ffffffff800036ba:	85 d2                	test   %edx,%edx
ffffffff800036bc:	0f 85 85 fd ff ff    	jne    ffffffff80003447 <_ntoa_long+0x217>
    for (size_t i = len; i < width; i++) {
ffffffff800036c2:	8b 4d 20             	mov    0x20(%rbp),%ecx
ffffffff800036c5:	48 39 cb             	cmp    %rcx,%rbx
ffffffff800036c8:	0f 82 04 fd ff ff    	jb     ffffffff800033d2 <_ntoa_long+0x1a2>
ffffffff800036ce:	e9 74 fd ff ff       	jmpq   ffffffff80003447 <_ntoa_long+0x217>
ffffffff800036d3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800036d8:	85 d2                	test   %edx,%edx
ffffffff800036da:	0f 84 e5 fc ff ff    	je     ffffffff800033c5 <_ntoa_long+0x195>
      buf[len++] = '-';
ffffffff800036e0:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
ffffffff800036e4:	bb 20 00 00 00       	mov    $0x20,%ebx
ffffffff800036e9:	e9 96 fd ff ff       	jmpq   ffffffff80003484 <_ntoa_long+0x254>
      buf[len++] = ' ';
ffffffff800036ee:	c6 44 1d b0 20       	movb   $0x20,-0x50(%rbp,%rbx,1)
ffffffff800036f3:	48 8d 43 01          	lea    0x1(%rbx),%rax
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800036f7:	85 d2                	test   %edx,%edx
ffffffff800036f9:	0f 85 20 ff ff ff    	jne    ffffffff8000361f <_ntoa_long+0x3ef>
ffffffff800036ff:	e9 d6 fe ff ff       	jmpq   ffffffff800035da <_ntoa_long+0x3aa>
      buf[len++] = '0';
ffffffff80003704:	c6 45 b0 30          	movb   $0x30,-0x50(%rbp)
ffffffff80003708:	bb 01 00 00 00       	mov    $0x1,%ebx
ffffffff8000370d:	e9 b0 fe ff ff       	jmpq   ffffffff800035c2 <_ntoa_long+0x392>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003712:	48 83 ff 10          	cmp    $0x10,%rdi
ffffffff80003716:	74 3e                	je     ffffffff80003756 <_ntoa_long+0x526>
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003718:	48 83 ff 02          	cmp    $0x2,%rdi
ffffffff8000371c:	0f 84 8a fc ff ff    	je     ffffffff800033ac <_ntoa_long+0x17c>
ffffffff80003722:	e9 40 fd ff ff       	jmpq   ffffffff80003467 <_ntoa_long+0x237>
    for (size_t i = len; i < width; i++) {
ffffffff80003727:	48 89 da             	mov    %rbx,%rdx
ffffffff8000372a:	48 83 c3 01          	add    $0x1,%rbx
      buf[len++] = 'x';
ffffffff8000372e:	c6 44 15 b0 78       	movb   $0x78,-0x50(%rbp,%rdx,1)
ffffffff80003733:	e9 79 fc ff ff       	jmpq   ffffffff800033b1 <_ntoa_long+0x181>
ffffffff80003738:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000373f:	00 
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80003740:	44 89 d2             	mov    %r10d,%edx
ffffffff80003743:	83 e2 20             	and    $0x20,%edx
ffffffff80003746:	83 fa 01             	cmp    $0x1,%edx
ffffffff80003749:	19 d2                	sbb    %edx,%edx
ffffffff8000374b:	83 e2 20             	and    $0x20,%edx
ffffffff8000374e:	83 c2 58             	add    $0x58,%edx
ffffffff80003751:	e9 f3 fe ff ff       	jmpq   ffffffff80003649 <_ntoa_long+0x419>
ffffffff80003756:	41 f6 c2 20          	test   $0x20,%r10b
ffffffff8000375a:	74 d2                	je     ffffffff8000372e <_ntoa_long+0x4fe>
ffffffff8000375c:	48 89 d9             	mov    %rbx,%rcx
      len--;
ffffffff8000375f:	48 89 d3             	mov    %rdx,%rbx
ffffffff80003762:	e9 33 ff ff ff       	jmpq   ffffffff8000369a <_ntoa_long+0x46a>
ffffffff80003767:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000376e:	00 00 

ffffffff80003770 <_out_char>:
  if (character) {
ffffffff80003770:	40 84 ff             	test   %dil,%dil
ffffffff80003773:	75 0b                	jne    ffffffff80003780 <_out_char+0x10>
}
ffffffff80003775:	c3                   	retq   
ffffffff80003776:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000377d:	00 00 00 
    _putchar(character);
ffffffff80003780:	40 0f be ff          	movsbl %dil,%edi
ffffffff80003784:	e9 e7 0c 00 00       	jmpq   ffffffff80004470 <_putchar>
ffffffff80003789:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80003790 <_out_fct>:
  if (character) {
ffffffff80003790:	40 84 ff             	test   %dil,%dil
ffffffff80003793:	74 13                	je     ffffffff800037a8 <_out_fct+0x18>
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
ffffffff80003795:	48 8b 56 08          	mov    0x8(%rsi),%rdx
ffffffff80003799:	48 8b 06             	mov    (%rsi),%rax
ffffffff8000379c:	40 0f be ff          	movsbl %dil,%edi
ffffffff800037a0:	48 89 d6             	mov    %rdx,%rsi
ffffffff800037a3:	ff e0                	jmpq   *%rax
ffffffff800037a5:	0f 1f 00             	nopl   (%rax)
}
ffffffff800037a8:	c3                   	retq   
ffffffff800037a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff800037b0 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
ffffffff800037b0:	55                   	push   %rbp
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
ffffffff800037b1:	48 c7 c0 20 32 00 80 	mov    $0xffffffff80003220,%rax
{
ffffffff800037b8:	48 89 e5             	mov    %rsp,%rbp
ffffffff800037bb:	41 57                	push   %r15
ffffffff800037bd:	41 56                	push   %r14
ffffffff800037bf:	41 55                	push   %r13
ffffffff800037c1:	41 54                	push   %r12
ffffffff800037c3:	49 89 f4             	mov    %rsi,%r12
ffffffff800037c6:	53                   	push   %rbx
ffffffff800037c7:	48 89 d3             	mov    %rdx,%rbx
ffffffff800037ca:	48 83 ec 48          	sub    $0x48,%rsp
    out = _out_null;
ffffffff800037ce:	48 85 f6             	test   %rsi,%rsi
  }

  while (*format)
ffffffff800037d1:	0f b6 11             	movzbl (%rcx),%edx
    out = _out_null;
ffffffff800037d4:	48 0f 45 c7          	cmovne %rdi,%rax
ffffffff800037d8:	49 89 c5             	mov    %rax,%r13
  while (*format)
ffffffff800037db:	31 c0                	xor    %eax,%eax
ffffffff800037dd:	84 d2                	test   %dl,%dl
ffffffff800037df:	0f 84 b2 07 00 00    	je     ffffffff80003f97 <_vsnprintf+0x7e7>
ffffffff800037e5:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
ffffffff800037e9:	49 89 cf             	mov    %rcx,%r15
ffffffff800037ec:	eb 24                	jmp    ffffffff80003812 <_vsnprintf+0x62>
ffffffff800037ee:	66 90                	xchg   %ax,%ax
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
      // no
      out(*format, buffer, idx++, maxlen);
ffffffff800037f0:	4c 8d 70 01          	lea    0x1(%rax),%r14
ffffffff800037f4:	0f be fa             	movsbl %dl,%edi
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
ffffffff800037f7:	48 89 d9             	mov    %rbx,%rcx
ffffffff800037fa:	48 89 c2             	mov    %rax,%rdx
ffffffff800037fd:	4c 89 e6             	mov    %r12,%rsi
ffffffff80003800:	41 ff d5             	callq  *%r13
ffffffff80003803:	4c 89 f0             	mov    %r14,%rax
  while (*format)
ffffffff80003806:	41 0f b6 17          	movzbl (%r15),%edx
ffffffff8000380a:	84 d2                	test   %dl,%dl
ffffffff8000380c:	0f 84 ee 01 00 00    	je     ffffffff80003a00 <_vsnprintf+0x250>
      format++;
ffffffff80003812:	49 83 c7 01          	add    $0x1,%r15
    if (*format != '%') {
ffffffff80003816:	80 fa 25             	cmp    $0x25,%dl
ffffffff80003819:	75 d5                	jne    ffffffff800037f0 <_vsnprintf+0x40>
    flags = 0U;
ffffffff8000381b:	45 31 f6             	xor    %r14d,%r14d
ffffffff8000381e:	66 90                	xchg   %ax,%ax
      switch (*format) {
ffffffff80003820:	41 0f be 3f          	movsbl (%r15),%edi
      format++;
ffffffff80003824:	49 8d 4f 01          	lea    0x1(%r15),%rcx
      switch (*format) {
ffffffff80003828:	8d 57 e0             	lea    -0x20(%rdi),%edx
ffffffff8000382b:	80 fa 10             	cmp    $0x10,%dl
ffffffff8000382e:	77 10                	ja     ffffffff80003840 <_vsnprintf+0x90>
ffffffff80003830:	0f b6 d2             	movzbl %dl,%edx
ffffffff80003833:	ff 24 d5 a8 5c 00 80 	jmpq   *-0x7fffa358(,%rdx,8)
ffffffff8000383a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  return (ch >= '0') && (ch <= '9');
ffffffff80003840:	8d 57 d0             	lea    -0x30(%rdi),%edx
    if (_is_digit(*format)) {
ffffffff80003843:	80 fa 09             	cmp    $0x9,%dl
ffffffff80003846:	0f 86 d4 02 00 00    	jbe    ffffffff80003b20 <_vsnprintf+0x370>
    width = 0U;
ffffffff8000384c:	45 31 db             	xor    %r11d,%r11d
    else if (*format == '*') {
ffffffff8000384f:	40 80 ff 2a          	cmp    $0x2a,%dil
ffffffff80003853:	0f 84 7f 03 00 00    	je     ffffffff80003bd8 <_vsnprintf+0x428>
    precision = 0U;
ffffffff80003859:	31 f6                	xor    %esi,%esi
    if (*format == '.') {
ffffffff8000385b:	40 80 ff 2e          	cmp    $0x2e,%dil
ffffffff8000385f:	0f 84 eb 02 00 00    	je     ffffffff80003b50 <_vsnprintf+0x3a0>
        format++;
ffffffff80003865:	48 89 ca             	mov    %rcx,%rdx
    switch (*format) {
ffffffff80003868:	40 80 ff 6c          	cmp    $0x6c,%dil
ffffffff8000386c:	0f 84 1e 03 00 00    	je     ffffffff80003b90 <_vsnprintf+0x3e0>
ffffffff80003872:	0f 8f b8 01 00 00    	jg     ffffffff80003a30 <_vsnprintf+0x280>
ffffffff80003878:	40 80 ff 68          	cmp    $0x68,%dil
ffffffff8000387c:	0f 84 a6 03 00 00    	je     ffffffff80003c28 <_vsnprintf+0x478>
ffffffff80003882:	40 80 ff 6a          	cmp    $0x6a,%dil
ffffffff80003886:	0f 85 1e 0a 00 00    	jne    ffffffff800042aa <_vsnprintf+0xafa>
        if (*format == 'l') {
ffffffff8000388c:	41 0f be 7f 01       	movsbl 0x1(%r15),%edi
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
ffffffff80003891:	41 81 ce 00 01 00 00 	or     $0x100,%r14d
        format++;
ffffffff80003898:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
    switch (*format) {
ffffffff8000389c:	40 80 ff 78          	cmp    $0x78,%dil
ffffffff800038a0:	0f 8f c8 01 00 00    	jg     ffffffff80003a6e <_vsnprintf+0x2be>
ffffffff800038a6:	40 80 ff 63          	cmp    $0x63,%dil
ffffffff800038aa:	0f 8f 93 01 00 00    	jg     ffffffff80003a43 <_vsnprintf+0x293>
ffffffff800038b0:	40 80 ff 62          	cmp    $0x62,%dil
ffffffff800038b4:	0f 84 d9 07 00 00    	je     ffffffff80004093 <_vsnprintf+0x8e3>
ffffffff800038ba:	40 80 ff 63          	cmp    $0x63,%dil
ffffffff800038be:	0f 85 0c 01 00 00    	jne    ffffffff800039d0 <_vsnprintf+0x220>
        if (!(flags & FLAGS_LEFT)) {
ffffffff800038c4:	41 83 e6 02          	and    $0x2,%r14d
        unsigned int l = 1U;
ffffffff800038c8:	c7 45 a8 01 00 00 00 	movl   $0x1,-0x58(%rbp)
        if (!(flags & FLAGS_LEFT)) {
ffffffff800038cf:	44 89 75 c0          	mov    %r14d,-0x40(%rbp)
ffffffff800038d3:	0f 84 8e 05 00 00    	je     ffffffff80003e67 <_vsnprintf+0x6b7>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff800038d9:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
ffffffff800038dd:	4c 8d 70 01          	lea    0x1(%rax),%r14
ffffffff800038e1:	8b 16                	mov    (%rsi),%edx
ffffffff800038e3:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff800038e6:	0f 87 31 05 00 00    	ja     ffffffff80003e1d <_vsnprintf+0x66d>
ffffffff800038ec:	89 d1                	mov    %edx,%ecx
ffffffff800038ee:	83 c2 08             	add    $0x8,%edx
ffffffff800038f1:	48 03 4e 10          	add    0x10(%rsi),%rcx
ffffffff800038f5:	89 16                	mov    %edx,(%rsi)
ffffffff800038f7:	48 89 c2             	mov    %rax,%rdx
ffffffff800038fa:	44 89 5d b8          	mov    %r11d,-0x48(%rbp)
ffffffff800038fe:	0f be 39             	movsbl (%rcx),%edi
ffffffff80003901:	4c 89 e6             	mov    %r12,%rsi
ffffffff80003904:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
ffffffff80003908:	48 89 d9             	mov    %rbx,%rcx
ffffffff8000390b:	41 ff d5             	callq  *%r13
        if (flags & FLAGS_LEFT) {
ffffffff8000390e:	8b 55 c0             	mov    -0x40(%rbp),%edx
ffffffff80003911:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80003915:	44 8b 5d b8          	mov    -0x48(%rbp),%r11d
ffffffff80003919:	85 d2                	test   %edx,%edx
ffffffff8000391b:	0f 84 e2 fe ff ff    	je     ffffffff80003803 <_vsnprintf+0x53>
          while (l++ < width) {
ffffffff80003921:	8b 75 a8             	mov    -0x58(%rbp),%esi
ffffffff80003924:	44 39 de             	cmp    %r11d,%esi
ffffffff80003927:	0f 83 d6 fe ff ff    	jae    ffffffff80003803 <_vsnprintf+0x53>
ffffffff8000392d:	41 83 eb 01          	sub    $0x1,%r11d
ffffffff80003931:	4c 89 7d c8          	mov    %r15,-0x38(%rbp)
ffffffff80003935:	4d 89 f7             	mov    %r14,%r15
ffffffff80003938:	49 89 de             	mov    %rbx,%r14
ffffffff8000393b:	41 29 f3             	sub    %esi,%r11d
ffffffff8000393e:	4a 8d 44 18 02       	lea    0x2(%rax,%r11,1),%rax
ffffffff80003943:	48 89 c3             	mov    %rax,%rbx
ffffffff80003946:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000394d:	00 00 00 
            out(' ', buffer, idx++, maxlen);
ffffffff80003950:	4c 89 fa             	mov    %r15,%rdx
ffffffff80003953:	49 83 c7 01          	add    $0x1,%r15
ffffffff80003957:	4c 89 f1             	mov    %r14,%rcx
ffffffff8000395a:	4c 89 e6             	mov    %r12,%rsi
ffffffff8000395d:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80003962:	41 ff d5             	callq  *%r13
          while (l++ < width) {
ffffffff80003965:	49 39 df             	cmp    %rbx,%r15
ffffffff80003968:	75 e6                	jne    ffffffff80003950 <_vsnprintf+0x1a0>
ffffffff8000396a:	4c 89 f3             	mov    %r14,%rbx
ffffffff8000396d:	4d 89 fe             	mov    %r15,%r14
ffffffff80003970:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
        break;
ffffffff80003974:	e9 8a fe ff ff       	jmpq   ffffffff80003803 <_vsnprintf+0x53>
ffffffff80003979:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
ffffffff80003980:	41 83 ce 01          	or     $0x1,%r14d
      format++;
ffffffff80003984:	49 89 cf             	mov    %rcx,%r15
ffffffff80003987:	e9 94 fe ff ff       	jmpq   ffffffff80003820 <_vsnprintf+0x70>
ffffffff8000398c:	0f 1f 40 00          	nopl   0x0(%rax)
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
ffffffff80003990:	41 83 ce 02          	or     $0x2,%r14d
ffffffff80003994:	eb ee                	jmp    ffffffff80003984 <_vsnprintf+0x1d4>
ffffffff80003996:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000399d:	00 00 00 
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
ffffffff800039a0:	41 83 ce 04          	or     $0x4,%r14d
ffffffff800039a4:	eb de                	jmp    ffffffff80003984 <_vsnprintf+0x1d4>
ffffffff800039a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800039ad:	00 00 00 
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
ffffffff800039b0:	41 83 ce 10          	or     $0x10,%r14d
ffffffff800039b4:	eb ce                	jmp    ffffffff80003984 <_vsnprintf+0x1d4>
ffffffff800039b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800039bd:	00 00 00 
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
ffffffff800039c0:	41 83 ce 08          	or     $0x8,%r14d
ffffffff800039c4:	eb be                	jmp    ffffffff80003984 <_vsnprintf+0x1d4>
ffffffff800039c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800039cd:	00 00 00 
    switch (*format) {
ffffffff800039d0:	40 80 ff 25          	cmp    $0x25,%dil
ffffffff800039d4:	0f 85 a6 00 00 00    	jne    ffffffff80003a80 <_vsnprintf+0x2d0>
        out('%', buffer, idx++, maxlen);
ffffffff800039da:	48 89 c2             	mov    %rax,%rdx
ffffffff800039dd:	4c 8d 70 01          	lea    0x1(%rax),%r14
ffffffff800039e1:	48 89 d9             	mov    %rbx,%rcx
ffffffff800039e4:	4c 89 e6             	mov    %r12,%rsi
ffffffff800039e7:	bf 25 00 00 00       	mov    $0x25,%edi
ffffffff800039ec:	41 ff d5             	callq  *%r13
  while (*format)
ffffffff800039ef:	41 0f b6 17          	movzbl (%r15),%edx
        out('%', buffer, idx++, maxlen);
ffffffff800039f3:	4c 89 f0             	mov    %r14,%rax
  while (*format)
ffffffff800039f6:	84 d2                	test   %dl,%dl
ffffffff800039f8:	0f 85 14 fe ff ff    	jne    ffffffff80003812 <_vsnprintf+0x62>
ffffffff800039fe:	66 90                	xchg   %ax,%ax

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

  // return written chars without terminating \0
  return (int)idx;
ffffffff80003a00:	41 89 c6             	mov    %eax,%r14d
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
ffffffff80003a03:	48 39 d8             	cmp    %rbx,%rax
ffffffff80003a06:	48 8d 53 ff          	lea    -0x1(%rbx),%rdx
ffffffff80003a0a:	48 89 d9             	mov    %rbx,%rcx
ffffffff80003a0d:	4c 89 e6             	mov    %r12,%rsi
ffffffff80003a10:	48 0f 43 c2          	cmovae %rdx,%rax
ffffffff80003a14:	31 ff                	xor    %edi,%edi
ffffffff80003a16:	48 89 c2             	mov    %rax,%rdx
ffffffff80003a19:	41 ff d5             	callq  *%r13
}
ffffffff80003a1c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
ffffffff80003a20:	44 89 f0             	mov    %r14d,%eax
ffffffff80003a23:	5b                   	pop    %rbx
ffffffff80003a24:	41 5c                	pop    %r12
ffffffff80003a26:	41 5d                	pop    %r13
ffffffff80003a28:	41 5e                	pop    %r14
ffffffff80003a2a:	41 5f                	pop    %r15
ffffffff80003a2c:	5d                   	pop    %rbp
ffffffff80003a2d:	c3                   	retq   
ffffffff80003a2e:	66 90                	xchg   %ax,%ax
    switch (*format) {
ffffffff80003a30:	40 80 ff 7a          	cmp    $0x7a,%dil
ffffffff80003a34:	0f 84 52 fe ff ff    	je     ffffffff8000388c <_vsnprintf+0xdc>
        format++;
ffffffff80003a3a:	49 89 cf             	mov    %rcx,%r15
    switch (*format) {
ffffffff80003a3d:	40 80 ff 78          	cmp    $0x78,%dil
ffffffff80003a41:	7f 2b                	jg     ffffffff80003a6e <_vsnprintf+0x2be>
ffffffff80003a43:	8d 4f 9c             	lea    -0x64(%rdi),%ecx
ffffffff80003a46:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80003a4b:	48 d3 e2             	shl    %cl,%rdx
ffffffff80003a4e:	f7 c2 21 08 12 00    	test   $0x120821,%edx
ffffffff80003a54:	0f 85 f9 07 00 00    	jne    ffffffff80004253 <_vsnprintf+0xaa3>
ffffffff80003a5a:	40 80 ff 73          	cmp    $0x73,%dil
ffffffff80003a5e:	0f 84 21 02 00 00    	je     ffffffff80003c85 <_vsnprintf+0x4d5>
ffffffff80003a64:	40 80 ff 70          	cmp    $0x70,%dil
ffffffff80003a68:	0f 84 d2 01 00 00    	je     ffffffff80003c40 <_vsnprintf+0x490>
        out(*format, buffer, idx++, maxlen);
ffffffff80003a6e:	4c 8d 70 01          	lea    0x1(%rax),%r14
ffffffff80003a72:	e9 80 fd ff ff       	jmpq   ffffffff800037f7 <_vsnprintf+0x47>
ffffffff80003a77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80003a7e:	00 00 
          flags |= FLAGS_UPPERCASE;
ffffffff80003a80:	41 83 ce 20          	or     $0x20,%r14d
ffffffff80003a84:	ba 10 00 00 00       	mov    $0x10,%edx
    switch (*format) {
ffffffff80003a89:	40 80 ff 58          	cmp    $0x58,%dil
ffffffff80003a8d:	75 df                	jne    ffffffff80003a6e <_vsnprintf+0x2be>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
ffffffff80003a8f:	41 83 e6 f3          	and    $0xfffffff3,%r14d
          flags &= ~FLAGS_ZEROPAD;
ffffffff80003a93:	44 89 f1             	mov    %r14d,%ecx
ffffffff80003a96:	83 e1 fe             	and    $0xfffffffe,%ecx
ffffffff80003a99:	41 f7 c6 00 04 00 00 	test   $0x400,%r14d
ffffffff80003aa0:	44 0f 45 f1          	cmovne %ecx,%r14d
            const long long value = va_arg(va, long long);
ffffffff80003aa4:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
          if (flags & FLAGS_LONG_LONG) {
ffffffff80003aa8:	45 89 f0             	mov    %r14d,%r8d
            const long long value = va_arg(va, long long);
ffffffff80003aab:	8b 09                	mov    (%rcx),%ecx
          if (flags & FLAGS_LONG_LONG) {
ffffffff80003aad:	41 81 e0 00 02 00 00 	and    $0x200,%r8d
        if ((*format == 'i') || (*format == 'd')) {
ffffffff80003ab4:	40 80 ff 69          	cmp    $0x69,%dil
ffffffff80003ab8:	0f 84 13 04 00 00    	je     ffffffff80003ed1 <_vsnprintf+0x721>
ffffffff80003abe:	40 80 ff 64          	cmp    $0x64,%dil
ffffffff80003ac2:	0f 84 09 04 00 00    	je     ffffffff80003ed1 <_vsnprintf+0x721>
          if (flags & FLAGS_LONG_LONG) {
ffffffff80003ac8:	45 85 c0             	test   %r8d,%r8d
ffffffff80003acb:	0f 85 9f 05 00 00    	jne    ffffffff80004070 <_vsnprintf+0x8c0>
          else if (flags & FLAGS_LONG) {
ffffffff80003ad1:	41 f7 c6 00 01 00 00 	test   $0x100,%r14d
ffffffff80003ad8:	0f 85 2a 06 00 00    	jne    ffffffff80004108 <_vsnprintf+0x958>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff80003ade:	41 f6 c6 40          	test   $0x40,%r14b
ffffffff80003ae2:	0f 85 d7 05 00 00    	jne    ffffffff800040bf <_vsnprintf+0x90f>
ffffffff80003ae8:	41 f6 c6 80          	test   $0x80,%r14b
ffffffff80003aec:	0f 84 af 06 00 00    	je     ffffffff800041a1 <_vsnprintf+0x9f1>
ffffffff80003af2:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff80003af5:	0f 87 fe 06 00 00    	ja     ffffffff800041f9 <_vsnprintf+0xa49>
ffffffff80003afb:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff80003aff:	89 cf                	mov    %ecx,%edi
ffffffff80003b01:	83 c1 08             	add    $0x8,%ecx
ffffffff80003b04:	41 89 0a             	mov    %ecx,(%r10)
ffffffff80003b07:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff80003b0b:	44 0f b7 07          	movzwl (%rdi),%r8d
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
ffffffff80003b0f:	41 56                	push   %r14
ffffffff80003b11:	45 31 c9             	xor    %r9d,%r9d
ffffffff80003b14:	41 53                	push   %r11
ffffffff80003b16:	56                   	push   %rsi
ffffffff80003b17:	52                   	push   %rdx
ffffffff80003b18:	e9 12 04 00 00       	jmpq   ffffffff80003f2f <_vsnprintf+0x77f>
ffffffff80003b1d:	0f 1f 00             	nopl   (%rax)
  unsigned int i = 0U;
ffffffff80003b20:	45 31 db             	xor    %r11d,%r11d
ffffffff80003b23:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
ffffffff80003b28:	43 8d 14 9b          	lea    (%r11,%r11,4),%edx
ffffffff80003b2c:	49 89 cf             	mov    %rcx,%r15
ffffffff80003b2f:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80003b33:	44 8d 5c 57 d0       	lea    -0x30(%rdi,%rdx,2),%r11d
  while (_is_digit(**str)) {
ffffffff80003b38:	0f be 79 ff          	movsbl -0x1(%rcx),%edi
  return (ch >= '0') && (ch <= '9');
ffffffff80003b3c:	8d 57 d0             	lea    -0x30(%rdi),%edx
  while (_is_digit(**str)) {
ffffffff80003b3f:	80 fa 09             	cmp    $0x9,%dl
ffffffff80003b42:	76 e4                	jbe    ffffffff80003b28 <_vsnprintf+0x378>
    precision = 0U;
ffffffff80003b44:	31 f6                	xor    %esi,%esi
    if (*format == '.') {
ffffffff80003b46:	40 80 ff 2e          	cmp    $0x2e,%dil
ffffffff80003b4a:	0f 85 15 fd ff ff    	jne    ffffffff80003865 <_vsnprintf+0xb5>
      if (_is_digit(*format)) {
ffffffff80003b50:	41 0f be 7f 01       	movsbl 0x1(%r15),%edi
      format++;
ffffffff80003b55:	48 89 ca             	mov    %rcx,%rdx
      flags |= FLAGS_PRECISION;
ffffffff80003b58:	41 81 ce 00 04 00 00 	or     $0x400,%r14d
  return (ch >= '0') && (ch <= '9');
ffffffff80003b5f:	44 8d 47 d0          	lea    -0x30(%rdi),%r8d
      if (_is_digit(*format)) {
ffffffff80003b63:	41 80 f8 09          	cmp    $0x9,%r8b
ffffffff80003b67:	76 47                	jbe    ffffffff80003bb0 <_vsnprintf+0x400>
      else if (*format == '*') {
ffffffff80003b69:	40 80 ff 2a          	cmp    $0x2a,%dil
ffffffff80003b6d:	0f 84 bf 02 00 00    	je     ffffffff80003e32 <_vsnprintf+0x682>
      format++;
ffffffff80003b73:	49 89 cf             	mov    %rcx,%r15
ffffffff80003b76:	48 83 c1 01          	add    $0x1,%rcx
        format++;
ffffffff80003b7a:	48 89 ca             	mov    %rcx,%rdx
    switch (*format) {
ffffffff80003b7d:	40 80 ff 6c          	cmp    $0x6c,%dil
ffffffff80003b81:	0f 85 eb fc ff ff    	jne    ffffffff80003872 <_vsnprintf+0xc2>
ffffffff80003b87:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80003b8e:	00 00 
        if (*format == 'l') {
ffffffff80003b90:	41 0f be 7f 01       	movsbl 0x1(%r15),%edi
ffffffff80003b95:	40 80 ff 6c          	cmp    $0x6c,%dil
ffffffff80003b99:	0f 84 b2 03 00 00    	je     ffffffff80003f51 <_vsnprintf+0x7a1>
        flags |= FLAGS_LONG;
ffffffff80003b9f:	41 81 ce 00 01 00 00 	or     $0x100,%r14d
ffffffff80003ba6:	e9 ed fc ff ff       	jmpq   ffffffff80003898 <_vsnprintf+0xe8>
ffffffff80003bab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
ffffffff80003bb0:	8d 0c b6             	lea    (%rsi,%rsi,4),%ecx
ffffffff80003bb3:	48 83 c2 01          	add    $0x1,%rdx
ffffffff80003bb7:	8d 74 4f d0          	lea    -0x30(%rdi,%rcx,2),%esi
  while (_is_digit(**str)) {
ffffffff80003bbb:	0f be 3a             	movsbl (%rdx),%edi
  return (ch >= '0') && (ch <= '9');
ffffffff80003bbe:	8d 4f d0             	lea    -0x30(%rdi),%ecx
  while (_is_digit(**str)) {
ffffffff80003bc1:	80 f9 09             	cmp    $0x9,%cl
ffffffff80003bc4:	76 ea                	jbe    ffffffff80003bb0 <_vsnprintf+0x400>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
ffffffff80003bc6:	49 89 d7             	mov    %rdx,%r15
ffffffff80003bc9:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
ffffffff80003bcd:	e9 93 fc ff ff       	jmpq   ffffffff80003865 <_vsnprintf+0xb5>
ffffffff80003bd2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      const int w = va_arg(va, int);
ffffffff80003bd8:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
ffffffff80003bdc:	8b 17                	mov    (%rdi),%edx
ffffffff80003bde:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003be1:	77 2d                	ja     ffffffff80003c10 <_vsnprintf+0x460>
ffffffff80003be3:	89 d6                	mov    %edx,%esi
ffffffff80003be5:	83 c2 08             	add    $0x8,%edx
ffffffff80003be8:	48 03 77 10          	add    0x10(%rdi),%rsi
ffffffff80003bec:	89 17                	mov    %edx,(%rdi)
ffffffff80003bee:	44 8b 1e             	mov    (%rsi),%r11d
      if (w < 0) {
ffffffff80003bf1:	45 85 db             	test   %r11d,%r11d
ffffffff80003bf4:	79 07                	jns    ffffffff80003bfd <_vsnprintf+0x44d>
        flags |= FLAGS_LEFT;    // reverse padding
ffffffff80003bf6:	41 83 ce 02          	or     $0x2,%r14d
        width = (unsigned int)-w;
ffffffff80003bfa:	41 f7 db             	neg    %r11d
    if (*format == '.') {
ffffffff80003bfd:	41 0f be 7f 01       	movsbl 0x1(%r15),%edi
      format++;
ffffffff80003c02:	49 89 cf             	mov    %rcx,%r15
ffffffff80003c05:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80003c09:	e9 4b fc ff ff       	jmpq   ffffffff80003859 <_vsnprintf+0xa9>
ffffffff80003c0e:	66 90                	xchg   %ax,%ax
      const int w = va_arg(va, int);
ffffffff80003c10:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
ffffffff80003c14:	48 8b 77 08          	mov    0x8(%rdi),%rsi
ffffffff80003c18:	48 8d 56 08          	lea    0x8(%rsi),%rdx
ffffffff80003c1c:	48 89 57 08          	mov    %rdx,0x8(%rdi)
ffffffff80003c20:	eb cc                	jmp    ffffffff80003bee <_vsnprintf+0x43e>
ffffffff80003c22:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        if (*format == 'h') {
ffffffff80003c28:	41 0f be 7f 01       	movsbl 0x1(%r15),%edi
ffffffff80003c2d:	40 80 ff 68          	cmp    $0x68,%dil
ffffffff80003c31:	0f 84 2f 03 00 00    	je     ffffffff80003f66 <_vsnprintf+0x7b6>
        flags |= FLAGS_SHORT;
ffffffff80003c37:	41 80 ce 80          	or     $0x80,%r14b
ffffffff80003c3b:	e9 58 fc ff ff       	jmpq   ffffffff80003898 <_vsnprintf+0xe8>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
ffffffff80003c40:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
ffffffff80003c44:	41 83 ce 21          	or     $0x21,%r14d
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
ffffffff80003c48:	8b 17                	mov    (%rdi),%edx
ffffffff80003c4a:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003c4d:	0f 87 b5 01 00 00    	ja     ffffffff80003e08 <_vsnprintf+0x658>
ffffffff80003c53:	89 d1                	mov    %edx,%ecx
ffffffff80003c55:	83 c2 08             	add    $0x8,%edx
ffffffff80003c58:	48 03 4f 10          	add    0x10(%rdi),%rcx
ffffffff80003c5c:	89 17                	mov    %edx,(%rdi)
ffffffff80003c5e:	4c 8b 01             	mov    (%rcx),%r8
ffffffff80003c61:	41 56                	push   %r14
ffffffff80003c63:	6a 10                	pushq  $0x10
ffffffff80003c65:	56                   	push   %rsi
ffffffff80003c66:	6a 10                	pushq  $0x10
ffffffff80003c68:	45 31 c9             	xor    %r9d,%r9d
ffffffff80003c6b:	48 89 d9             	mov    %rbx,%rcx
ffffffff80003c6e:	48 89 c2             	mov    %rax,%rdx
ffffffff80003c71:	4c 89 e6             	mov    %r12,%rsi
ffffffff80003c74:	4c 89 ef             	mov    %r13,%rdi
ffffffff80003c77:	e8 b4 f5 ff ff       	callq  ffffffff80003230 <_ntoa_long>
        break;
ffffffff80003c7c:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80003c80:	e9 81 fb ff ff       	jmpq   ffffffff80003806 <_vsnprintf+0x56>
        const char* p = va_arg(va, char*);
ffffffff80003c85:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
ffffffff80003c89:	8b 17                	mov    (%rdi),%edx
ffffffff80003c8b:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003c8e:	0f 87 5f 01 00 00    	ja     ffffffff80003df3 <_vsnprintf+0x643>
ffffffff80003c94:	89 d1                	mov    %edx,%ecx
ffffffff80003c96:	83 c2 08             	add    $0x8,%edx
ffffffff80003c99:	48 03 4f 10          	add    0x10(%rdi),%rcx
ffffffff80003c9d:	89 17                	mov    %edx,(%rdi)
ffffffff80003c9f:	48 8b 09             	mov    (%rcx),%rcx
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
ffffffff80003ca2:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
ffffffff80003ca9:	41 89 f0             	mov    %esi,%r8d
ffffffff80003cac:	85 f6                	test   %esi,%esi
ffffffff80003cae:	4c 0f 44 c2          	cmove  %rdx,%r8
  for (s = str; *s && maxsize--; ++s);
ffffffff80003cb2:	0f b6 11             	movzbl (%rcx),%edx
ffffffff80003cb5:	84 d2                	test   %dl,%dl
ffffffff80003cb7:	0f 84 a0 04 00 00    	je     ffffffff8000415d <_vsnprintf+0x9ad>
ffffffff80003cbd:	49 01 c8             	add    %rcx,%r8
ffffffff80003cc0:	48 89 cf             	mov    %rcx,%rdi
ffffffff80003cc3:	eb 0c                	jmp    ffffffff80003cd1 <_vsnprintf+0x521>
ffffffff80003cc5:	0f 1f 00             	nopl   (%rax)
ffffffff80003cc8:	49 39 f8             	cmp    %rdi,%r8
ffffffff80003ccb:	0f 84 78 02 00 00    	je     ffffffff80003f49 <_vsnprintf+0x799>
ffffffff80003cd1:	48 83 c7 01          	add    $0x1,%rdi
ffffffff80003cd5:	80 3f 00             	cmpb   $0x0,(%rdi)
ffffffff80003cd8:	75 ee                	jne    ffffffff80003cc8 <_vsnprintf+0x518>
  return (unsigned int)(s - str);
ffffffff80003cda:	41 89 f8             	mov    %edi,%r8d
ffffffff80003cdd:	41 29 c8             	sub    %ecx,%r8d
          l = (l < precision ? l : precision);
ffffffff80003ce0:	41 39 f0             	cmp    %esi,%r8d
ffffffff80003ce3:	89 f7                	mov    %esi,%edi
ffffffff80003ce5:	45 89 f2             	mov    %r14d,%r10d
ffffffff80003ce8:	41 0f 46 f8          	cmovbe %r8d,%edi
ffffffff80003cec:	41 81 e2 00 04 00 00 	and    $0x400,%r10d
ffffffff80003cf3:	44 89 55 a8          	mov    %r10d,-0x58(%rbp)
ffffffff80003cf7:	44 0f 45 c7          	cmovne %edi,%r8d
        if (!(flags & FLAGS_LEFT)) {
ffffffff80003cfb:	41 83 e6 02          	and    $0x2,%r14d
ffffffff80003cff:	44 89 75 a4          	mov    %r14d,-0x5c(%rbp)
ffffffff80003d03:	0f 84 96 02 00 00    	je     ffffffff80003f9f <_vsnprintf+0x7ef>
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80003d09:	84 d2                	test   %dl,%dl
ffffffff80003d0b:	0f 84 8c 00 00 00    	je     ffffffff80003d9d <_vsnprintf+0x5ed>
ffffffff80003d11:	48 29 c1             	sub    %rax,%rcx
ffffffff80003d14:	4c 89 65 c8          	mov    %r12,-0x38(%rbp)
ffffffff80003d18:	49 89 c4             	mov    %rax,%r12
ffffffff80003d1b:	48 89 5d c0          	mov    %rbx,-0x40(%rbp)
ffffffff80003d1f:	8b 5d a8             	mov    -0x58(%rbp),%ebx
ffffffff80003d22:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
ffffffff80003d26:	4c 89 7d a8          	mov    %r15,-0x58(%rbp)
ffffffff80003d2a:	41 89 f7             	mov    %esi,%r15d
ffffffff80003d2d:	44 89 45 a0          	mov    %r8d,-0x60(%rbp)
ffffffff80003d31:	44 89 5d 98          	mov    %r11d,-0x68(%rbp)
ffffffff80003d35:	eb 0c                	jmp    ffffffff80003d43 <_vsnprintf+0x593>
ffffffff80003d37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80003d3e:	00 00 
          out(*(p++), buffer, idx++, maxlen);
ffffffff80003d40:	4d 89 f4             	mov    %r14,%r12
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80003d43:	85 db                	test   %ebx,%ebx
ffffffff80003d45:	74 10                	je     ffffffff80003d57 <_vsnprintf+0x5a7>
ffffffff80003d47:	41 8d 4f ff          	lea    -0x1(%r15),%ecx
ffffffff80003d4b:	45 85 ff             	test   %r15d,%r15d
ffffffff80003d4e:	0f 84 24 02 00 00    	je     ffffffff80003f78 <_vsnprintf+0x7c8>
ffffffff80003d54:	41 89 cf             	mov    %ecx,%r15d
          out(*(p++), buffer, idx++, maxlen);
ffffffff80003d57:	0f be fa             	movsbl %dl,%edi
ffffffff80003d5a:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80003d5e:	4c 89 e2             	mov    %r12,%rdx
ffffffff80003d61:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
ffffffff80003d65:	41 ff d5             	callq  *%r13
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80003d68:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
          out(*(p++), buffer, idx++, maxlen);
ffffffff80003d6c:	4d 8d 74 24 01       	lea    0x1(%r12),%r14
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80003d71:	41 0f b6 54 04 01    	movzbl 0x1(%r12,%rax,1),%edx
ffffffff80003d77:	84 d2                	test   %dl,%dl
ffffffff80003d79:	75 c5                	jne    ffffffff80003d40 <_vsnprintf+0x590>
ffffffff80003d7b:	44 8b 45 a0          	mov    -0x60(%rbp),%r8d
ffffffff80003d7f:	44 8b 5d 98          	mov    -0x68(%rbp),%r11d
ffffffff80003d83:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
ffffffff80003d87:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
ffffffff80003d8b:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
        if (flags & FLAGS_LEFT) {
ffffffff80003d8f:	8b 45 a4             	mov    -0x5c(%rbp),%eax
ffffffff80003d92:	85 c0                	test   %eax,%eax
ffffffff80003d94:	0f 84 69 fa ff ff    	je     ffffffff80003803 <_vsnprintf+0x53>
ffffffff80003d9a:	4c 89 f0             	mov    %r14,%rax
          while (l++ < width) {
ffffffff80003d9d:	45 39 d8             	cmp    %r11d,%r8d
ffffffff80003da0:	0f 83 75 02 00 00    	jae    ffffffff8000401b <_vsnprintf+0x86b>
ffffffff80003da6:	41 83 eb 01          	sub    $0x1,%r11d
ffffffff80003daa:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
ffffffff80003dae:	45 29 c3             	sub    %r8d,%r11d
ffffffff80003db1:	4c 8d 40 01          	lea    0x1(%rax),%r8
ffffffff80003db5:	4c 89 7d c0          	mov    %r15,-0x40(%rbp)
ffffffff80003db9:	49 89 c7             	mov    %rax,%r15
ffffffff80003dbc:	4f 8d 34 03          	lea    (%r11,%r8,1),%r14
ffffffff80003dc0:	4c 89 c3             	mov    %r8,%rbx
ffffffff80003dc3:	eb 07                	jmp    ffffffff80003dcc <_vsnprintf+0x61c>
ffffffff80003dc5:	0f 1f 00             	nopl   (%rax)
ffffffff80003dc8:	48 83 c3 01          	add    $0x1,%rbx
            out(' ', buffer, idx++, maxlen);
ffffffff80003dcc:	4c 89 fa             	mov    %r15,%rdx
ffffffff80003dcf:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80003dd3:	49 89 df             	mov    %rbx,%r15
ffffffff80003dd6:	4c 89 e6             	mov    %r12,%rsi
ffffffff80003dd9:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80003dde:	41 ff d5             	callq  *%r13
          while (l++ < width) {
ffffffff80003de1:	4c 39 f3             	cmp    %r14,%rbx
ffffffff80003de4:	75 e2                	jne    ffffffff80003dc8 <_vsnprintf+0x618>
ffffffff80003de6:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
ffffffff80003dea:	4c 8b 7d c0          	mov    -0x40(%rbp),%r15
        break;
ffffffff80003dee:	e9 10 fa ff ff       	jmpq   ffffffff80003803 <_vsnprintf+0x53>
        const char* p = va_arg(va, char*);
ffffffff80003df3:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
ffffffff80003df7:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
ffffffff80003dfb:	48 8d 51 08          	lea    0x8(%rcx),%rdx
ffffffff80003dff:	48 89 57 08          	mov    %rdx,0x8(%rdi)
ffffffff80003e03:	e9 97 fe ff ff       	jmpq   ffffffff80003c9f <_vsnprintf+0x4ef>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
ffffffff80003e08:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
ffffffff80003e0c:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
ffffffff80003e10:	48 8d 51 08          	lea    0x8(%rcx),%rdx
ffffffff80003e14:	48 89 57 08          	mov    %rdx,0x8(%rdi)
ffffffff80003e18:	e9 41 fe ff ff       	jmpq   ffffffff80003c5e <_vsnprintf+0x4ae>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff80003e1d:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
ffffffff80003e21:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
ffffffff80003e25:	48 8d 51 08          	lea    0x8(%rcx),%rdx
ffffffff80003e29:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003e2d:	e9 c5 fa ff ff       	jmpq   ffffffff800038f7 <_vsnprintf+0x147>
        const int prec = (int)va_arg(va, int);
ffffffff80003e32:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
ffffffff80003e36:	8b 16                	mov    (%rsi),%edx
ffffffff80003e38:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003e3b:	0f 87 e2 01 00 00    	ja     ffffffff80004023 <_vsnprintf+0x873>
ffffffff80003e41:	89 d1                	mov    %edx,%ecx
ffffffff80003e43:	83 c2 08             	add    $0x8,%edx
ffffffff80003e46:	48 03 4e 10          	add    0x10(%rsi),%rcx
ffffffff80003e4a:	89 16                	mov    %edx,(%rsi)
        precision = prec > 0 ? (unsigned int)prec : 0U;
ffffffff80003e4c:	8b 31                	mov    (%rcx),%esi
ffffffff80003e4e:	31 d2                	xor    %edx,%edx
    switch (*format) {
ffffffff80003e50:	41 0f be 7f 02       	movsbl 0x2(%r15),%edi
        precision = prec > 0 ? (unsigned int)prec : 0U;
ffffffff80003e55:	85 f6                	test   %esi,%esi
ffffffff80003e57:	0f 48 f2             	cmovs  %edx,%esi
        format++;
ffffffff80003e5a:	49 83 c7 02          	add    $0x2,%r15
ffffffff80003e5e:	49 8d 4f 01          	lea    0x1(%r15),%rcx
ffffffff80003e62:	e9 fe f9 ff ff       	jmpq   ffffffff80003865 <_vsnprintf+0xb5>
          while (l++ < width) {
ffffffff80003e67:	41 83 fb 01          	cmp    $0x1,%r11d
ffffffff80003e6b:	0f 86 c4 03 00 00    	jbe    ffffffff80004235 <_vsnprintf+0xa85>
ffffffff80003e71:	4c 8d 40 01          	lea    0x1(%rax),%r8
ffffffff80003e75:	41 8d 53 fe          	lea    -0x2(%r11),%edx
ffffffff80003e79:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
ffffffff80003e7d:	4c 89 7d a8          	mov    %r15,-0x58(%rbp)
ffffffff80003e81:	4d 8d 34 10          	lea    (%r8,%rdx,1),%r14
ffffffff80003e85:	49 89 c7             	mov    %rax,%r15
ffffffff80003e88:	4c 89 c3             	mov    %r8,%rbx
ffffffff80003e8b:	44 89 5d b8          	mov    %r11d,-0x48(%rbp)
ffffffff80003e8f:	eb 0b                	jmp    ffffffff80003e9c <_vsnprintf+0x6ec>
ffffffff80003e91:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff80003e98:	48 83 c3 01          	add    $0x1,%rbx
            out(' ', buffer, idx++, maxlen);
ffffffff80003e9c:	4c 89 fa             	mov    %r15,%rdx
ffffffff80003e9f:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80003ea3:	49 89 df             	mov    %rbx,%r15
ffffffff80003ea6:	4c 89 e6             	mov    %r12,%rsi
ffffffff80003ea9:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80003eae:	41 ff d5             	callq  *%r13
          while (l++ < width) {
ffffffff80003eb1:	4c 39 f3             	cmp    %r14,%rbx
ffffffff80003eb4:	75 e2                	jne    ffffffff80003e98 <_vsnprintf+0x6e8>
ffffffff80003eb6:	44 8b 5d b8          	mov    -0x48(%rbp),%r11d
ffffffff80003eba:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
ffffffff80003ebe:	48 89 d8             	mov    %rbx,%rax
ffffffff80003ec1:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
ffffffff80003ec5:	41 8d 73 01          	lea    0x1(%r11),%esi
ffffffff80003ec9:	89 75 a8             	mov    %esi,-0x58(%rbp)
ffffffff80003ecc:	e9 08 fa ff ff       	jmpq   ffffffff800038d9 <_vsnprintf+0x129>
          if (flags & FLAGS_LONG_LONG) {
ffffffff80003ed1:	45 85 c0             	test   %r8d,%r8d
ffffffff80003ed4:	0f 85 5e 01 00 00    	jne    ffffffff80004038 <_vsnprintf+0x888>
          else if (flags & FLAGS_LONG) {
ffffffff80003eda:	41 f7 c6 00 01 00 00 	test   $0x100,%r14d
ffffffff80003ee1:	0f 85 42 02 00 00    	jne    ffffffff80004129 <_vsnprintf+0x979>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff80003ee7:	41 f6 c6 40          	test   $0x40,%r14b
ffffffff80003eeb:	0f 85 ac 01 00 00    	jne    ffffffff8000409d <_vsnprintf+0x8ed>
ffffffff80003ef1:	41 f6 c6 80          	test   $0x80,%r14b
ffffffff80003ef5:	0f 84 c3 02 00 00    	je     ffffffff800041be <_vsnprintf+0xa0e>
ffffffff80003efb:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff80003efe:	0f 87 0a 03 00 00    	ja     ffffffff8000420e <_vsnprintf+0xa5e>
ffffffff80003f04:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff80003f08:	89 cf                	mov    %ecx,%edi
ffffffff80003f0a:	83 c1 08             	add    $0x8,%ecx
ffffffff80003f0d:	41 89 0a             	mov    %ecx,(%r10)
ffffffff80003f10:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff80003f14:	44 0f bf 0f          	movswl (%rdi),%r9d
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff80003f18:	45 89 c8             	mov    %r9d,%r8d
ffffffff80003f1b:	41 56                	push   %r14
ffffffff80003f1d:	41 f7 d8             	neg    %r8d
ffffffff80003f20:	41 53                	push   %r11
ffffffff80003f22:	45 0f 48 c1          	cmovs  %r9d,%r8d
ffffffff80003f26:	56                   	push   %rsi
ffffffff80003f27:	41 c1 e9 1f          	shr    $0x1f,%r9d
ffffffff80003f2b:	52                   	push   %rdx
ffffffff80003f2c:	4d 63 c0             	movslq %r8d,%r8
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
ffffffff80003f2f:	48 89 d9             	mov    %rbx,%rcx
ffffffff80003f32:	48 89 c2             	mov    %rax,%rdx
ffffffff80003f35:	4c 89 e6             	mov    %r12,%rsi
ffffffff80003f38:	4c 89 ef             	mov    %r13,%rdi
ffffffff80003f3b:	e8 f0 f2 ff ff       	callq  ffffffff80003230 <_ntoa_long>
ffffffff80003f40:	48 83 c4 20          	add    $0x20,%rsp
        break;
ffffffff80003f44:	e9 bd f8 ff ff       	jmpq   ffffffff80003806 <_vsnprintf+0x56>
  return (unsigned int)(s - str);
ffffffff80003f49:	41 29 c8             	sub    %ecx,%r8d
ffffffff80003f4c:	e9 8f fd ff ff       	jmpq   ffffffff80003ce0 <_vsnprintf+0x530>
    switch (*format) {
ffffffff80003f51:	41 0f be 7f 02       	movsbl 0x2(%r15),%edi
          flags |= FLAGS_LONG_LONG;
ffffffff80003f56:	41 81 ce 00 03 00 00 	or     $0x300,%r14d
          format++;
ffffffff80003f5d:	49 8d 57 02          	lea    0x2(%r15),%rdx
ffffffff80003f61:	e9 32 f9 ff ff       	jmpq   ffffffff80003898 <_vsnprintf+0xe8>
    switch (*format) {
ffffffff80003f66:	41 0f be 7f 02       	movsbl 0x2(%r15),%edi
          flags |= FLAGS_CHAR;
ffffffff80003f6b:	41 80 ce c0          	or     $0xc0,%r14b
          format++;
ffffffff80003f6f:	49 8d 57 02          	lea    0x2(%r15),%rdx
ffffffff80003f73:	e9 20 f9 ff ff       	jmpq   ffffffff80003898 <_vsnprintf+0xe8>
ffffffff80003f78:	4c 89 e0             	mov    %r12,%rax
ffffffff80003f7b:	44 8b 45 a0          	mov    -0x60(%rbp),%r8d
ffffffff80003f7f:	44 8b 5d 98          	mov    -0x68(%rbp),%r11d
ffffffff80003f83:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
ffffffff80003f87:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
ffffffff80003f8b:	49 89 c6             	mov    %rax,%r14
ffffffff80003f8e:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
ffffffff80003f92:	e9 f8 fd ff ff       	jmpq   ffffffff80003d8f <_vsnprintf+0x5df>
  while (*format)
ffffffff80003f97:	45 31 f6             	xor    %r14d,%r14d
ffffffff80003f9a:	e9 64 fa ff ff       	jmpq   ffffffff80003a03 <_vsnprintf+0x253>
          while (l++ < width) {
ffffffff80003f9f:	45 39 d8             	cmp    %r11d,%r8d
ffffffff80003fa2:	0f 83 48 02 00 00    	jae    ffffffff800041f0 <_vsnprintf+0xa40>
ffffffff80003fa8:	41 8d 53 ff          	lea    -0x1(%r11),%edx
ffffffff80003fac:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
ffffffff80003fb0:	44 29 c2             	sub    %r8d,%edx
ffffffff80003fb3:	4c 8d 40 01          	lea    0x1(%rax),%r8
ffffffff80003fb7:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
ffffffff80003fbb:	49 89 c7             	mov    %rax,%r15
ffffffff80003fbe:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
ffffffff80003fc2:	4e 8d 34 02          	lea    (%rdx,%r8,1),%r14
ffffffff80003fc6:	4c 89 c3             	mov    %r8,%rbx
ffffffff80003fc9:	44 89 5d b8          	mov    %r11d,-0x48(%rbp)
ffffffff80003fcd:	89 75 a0             	mov    %esi,-0x60(%rbp)
ffffffff80003fd0:	eb 0a                	jmp    ffffffff80003fdc <_vsnprintf+0x82c>
ffffffff80003fd2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff80003fd8:	48 83 c3 01          	add    $0x1,%rbx
            out(' ', buffer, idx++, maxlen);
ffffffff80003fdc:	4c 89 fa             	mov    %r15,%rdx
ffffffff80003fdf:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80003fe3:	49 89 df             	mov    %rbx,%r15
ffffffff80003fe6:	4c 89 e6             	mov    %r12,%rsi
ffffffff80003fe9:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80003fee:	41 ff d5             	callq  *%r13
          while (l++ < width) {
ffffffff80003ff1:	49 39 de             	cmp    %rbx,%r14
ffffffff80003ff4:	75 e2                	jne    ffffffff80003fd8 <_vsnprintf+0x828>
ffffffff80003ff6:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80003ffa:	44 8b 5d b8          	mov    -0x48(%rbp),%r11d
ffffffff80003ffe:	48 89 d8             	mov    %rbx,%rax
ffffffff80004001:	8b 75 a0             	mov    -0x60(%rbp),%esi
ffffffff80004004:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
ffffffff80004008:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff8000400c:	0f b6 11             	movzbl (%rcx),%edx
          while (l++ < width) {
ffffffff8000400f:	45 8d 43 01          	lea    0x1(%r11),%r8d
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80004013:	84 d2                	test   %dl,%dl
ffffffff80004015:	0f 85 f6 fc ff ff    	jne    ffffffff80003d11 <_vsnprintf+0x561>
          while (l++ < width) {
ffffffff8000401b:	49 89 c6             	mov    %rax,%r14
ffffffff8000401e:	e9 e0 f7 ff ff       	jmpq   ffffffff80003803 <_vsnprintf+0x53>
        const int prec = (int)va_arg(va, int);
ffffffff80004023:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
ffffffff80004027:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
ffffffff8000402b:	48 8d 51 08          	lea    0x8(%rcx),%rdx
ffffffff8000402f:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80004033:	e9 14 fe ff ff       	jmpq   ffffffff80003e4c <_vsnprintf+0x69c>
            const long long value = va_arg(va, long long);
ffffffff80004038:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff8000403b:	0f 87 b2 00 00 00    	ja     ffffffff800040f3 <_vsnprintf+0x943>
ffffffff80004041:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff80004045:	89 cf                	mov    %ecx,%edi
ffffffff80004047:	83 c1 08             	add    $0x8,%ecx
ffffffff8000404a:	41 89 0a             	mov    %ecx,(%r10)
ffffffff8000404d:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff80004051:	48 8b 0f             	mov    (%rdi),%rcx
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff80004054:	41 56                	push   %r14
ffffffff80004056:	41 53                	push   %r11
ffffffff80004058:	49 89 c9             	mov    %rcx,%r9
ffffffff8000405b:	49 89 c8             	mov    %rcx,%r8
ffffffff8000405e:	56                   	push   %rsi
ffffffff8000405f:	49 c1 e9 3f          	shr    $0x3f,%r9
ffffffff80004063:	49 f7 d8             	neg    %r8
ffffffff80004066:	52                   	push   %rdx
ffffffff80004067:	4c 0f 48 c1          	cmovs  %rcx,%r8
ffffffff8000406b:	e9 fb fb ff ff       	jmpq   ffffffff80003c6b <_vsnprintf+0x4bb>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
ffffffff80004070:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff80004073:	77 6c                	ja     ffffffff800040e1 <_vsnprintf+0x931>
ffffffff80004075:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff80004079:	89 cf                	mov    %ecx,%edi
ffffffff8000407b:	83 c1 08             	add    $0x8,%ecx
ffffffff8000407e:	41 89 0a             	mov    %ecx,(%r10)
ffffffff80004081:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff80004085:	4c 8b 07             	mov    (%rdi),%r8
ffffffff80004088:	41 56                	push   %r14
ffffffff8000408a:	41 53                	push   %r11
ffffffff8000408c:	56                   	push   %rsi
ffffffff8000408d:	52                   	push   %rdx
ffffffff8000408e:	e9 d5 fb ff ff       	jmpq   ffffffff80003c68 <_vsnprintf+0x4b8>
    switch (*format) {
ffffffff80004093:	ba 02 00 00 00       	mov    $0x2,%edx
ffffffff80004098:	e9 f2 f9 ff ff       	jmpq   ffffffff80003a8f <_vsnprintf+0x2df>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff8000409d:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff800040a0:	0f 87 e6 00 00 00    	ja     ffffffff8000418c <_vsnprintf+0x9dc>
ffffffff800040a6:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff800040aa:	89 cf                	mov    %ecx,%edi
ffffffff800040ac:	83 c1 08             	add    $0x8,%ecx
ffffffff800040af:	41 89 0a             	mov    %ecx,(%r10)
ffffffff800040b2:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff800040b6:	44 0f be 0f          	movsbl (%rdi),%r9d
ffffffff800040ba:	e9 59 fe ff ff       	jmpq   ffffffff80003f18 <_vsnprintf+0x768>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff800040bf:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff800040c2:	0f 87 9d 00 00 00    	ja     ffffffff80004165 <_vsnprintf+0x9b5>
ffffffff800040c8:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff800040cc:	89 cf                	mov    %ecx,%edi
ffffffff800040ce:	83 c1 08             	add    $0x8,%ecx
ffffffff800040d1:	41 89 0a             	mov    %ecx,(%r10)
ffffffff800040d4:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff800040d8:	44 0f b6 07          	movzbl (%rdi),%r8d
ffffffff800040dc:	e9 2e fa ff ff       	jmpq   ffffffff80003b0f <_vsnprintf+0x35f>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
ffffffff800040e1:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff800040e5:	49 8b 7a 08          	mov    0x8(%r10),%rdi
ffffffff800040e9:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff800040ed:	49 89 4a 08          	mov    %rcx,0x8(%r10)
ffffffff800040f1:	eb 92                	jmp    ffffffff80004085 <_vsnprintf+0x8d5>
            const long long value = va_arg(va, long long);
ffffffff800040f3:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff800040f7:	49 8b 7a 08          	mov    0x8(%r10),%rdi
ffffffff800040fb:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff800040ff:	49 89 4a 08          	mov    %rcx,0x8(%r10)
ffffffff80004103:	e9 49 ff ff ff       	jmpq   ffffffff80004051 <_vsnprintf+0x8a1>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
ffffffff80004108:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff8000410b:	0f 87 ca 00 00 00    	ja     ffffffff800041db <_vsnprintf+0xa2b>
ffffffff80004111:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff80004115:	89 cf                	mov    %ecx,%edi
ffffffff80004117:	83 c1 08             	add    $0x8,%ecx
ffffffff8000411a:	41 89 0a             	mov    %ecx,(%r10)
ffffffff8000411d:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff80004121:	4c 8b 07             	mov    (%rdi),%r8
ffffffff80004124:	e9 e6 f9 ff ff       	jmpq   ffffffff80003b0f <_vsnprintf+0x35f>
            const long value = va_arg(va, long);
ffffffff80004129:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff8000412c:	77 4c                	ja     ffffffff8000417a <_vsnprintf+0x9ca>
ffffffff8000412e:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff80004132:	89 cf                	mov    %ecx,%edi
ffffffff80004134:	83 c1 08             	add    $0x8,%ecx
ffffffff80004137:	41 89 0a             	mov    %ecx,(%r10)
ffffffff8000413a:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff8000413e:	48 8b 0f             	mov    (%rdi),%rcx
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff80004141:	41 56                	push   %r14
ffffffff80004143:	41 53                	push   %r11
ffffffff80004145:	49 89 c9             	mov    %rcx,%r9
ffffffff80004148:	49 89 c8             	mov    %rcx,%r8
ffffffff8000414b:	56                   	push   %rsi
ffffffff8000414c:	49 c1 e9 3f          	shr    $0x3f,%r9
ffffffff80004150:	49 f7 d8             	neg    %r8
ffffffff80004153:	52                   	push   %rdx
ffffffff80004154:	4c 0f 48 c1          	cmovs  %rcx,%r8
ffffffff80004158:	e9 d2 fd ff ff       	jmpq   ffffffff80003f2f <_vsnprintf+0x77f>
  for (s = str; *s && maxsize--; ++s);
ffffffff8000415d:	45 31 c0             	xor    %r8d,%r8d
ffffffff80004160:	e9 7b fb ff ff       	jmpq   ffffffff80003ce0 <_vsnprintf+0x530>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff80004165:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
ffffffff80004169:	49 8b 79 08          	mov    0x8(%r9),%rdi
ffffffff8000416d:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff80004171:	49 89 49 08          	mov    %rcx,0x8(%r9)
ffffffff80004175:	e9 5e ff ff ff       	jmpq   ffffffff800040d8 <_vsnprintf+0x928>
            const long value = va_arg(va, long);
ffffffff8000417a:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff8000417e:	49 8b 7a 08          	mov    0x8(%r10),%rdi
ffffffff80004182:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff80004186:	49 89 4a 08          	mov    %rcx,0x8(%r10)
ffffffff8000418a:	eb b2                	jmp    ffffffff8000413e <_vsnprintf+0x98e>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff8000418c:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff80004190:	49 8b 7a 08          	mov    0x8(%r10),%rdi
ffffffff80004194:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff80004198:	49 89 4a 08          	mov    %rcx,0x8(%r10)
ffffffff8000419c:	e9 15 ff ff ff       	jmpq   ffffffff800040b6 <_vsnprintf+0x906>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff800041a1:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff800041a4:	77 7d                	ja     ffffffff80004223 <_vsnprintf+0xa73>
ffffffff800041a6:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff800041aa:	89 cf                	mov    %ecx,%edi
ffffffff800041ac:	83 c1 08             	add    $0x8,%ecx
ffffffff800041af:	41 89 0a             	mov    %ecx,(%r10)
ffffffff800041b2:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff800041b6:	44 8b 07             	mov    (%rdi),%r8d
ffffffff800041b9:	e9 51 f9 ff ff       	jmpq   ffffffff80003b0f <_vsnprintf+0x35f>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff800041be:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff800041c1:	77 7e                	ja     ffffffff80004241 <_vsnprintf+0xa91>
ffffffff800041c3:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff800041c7:	89 cf                	mov    %ecx,%edi
ffffffff800041c9:	83 c1 08             	add    $0x8,%ecx
ffffffff800041cc:	41 89 0a             	mov    %ecx,(%r10)
ffffffff800041cf:	49 03 7a 10          	add    0x10(%r10),%rdi
ffffffff800041d3:	44 8b 0f             	mov    (%rdi),%r9d
ffffffff800041d6:	e9 3d fd ff ff       	jmpq   ffffffff80003f18 <_vsnprintf+0x768>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
ffffffff800041db:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff800041df:	49 8b 7a 08          	mov    0x8(%r10),%rdi
ffffffff800041e3:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff800041e7:	49 89 4a 08          	mov    %rcx,0x8(%r10)
ffffffff800041eb:	e9 31 ff ff ff       	jmpq   ffffffff80004121 <_vsnprintf+0x971>
          while (l++ < width) {
ffffffff800041f0:	41 83 c0 01          	add    $0x1,%r8d
ffffffff800041f4:	e9 1a fe ff ff       	jmpq   ffffffff80004013 <_vsnprintf+0x863>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff800041f9:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
ffffffff800041fd:	49 8b 79 08          	mov    0x8(%r9),%rdi
ffffffff80004201:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff80004205:	49 89 49 08          	mov    %rcx,0x8(%r9)
ffffffff80004209:	e9 fd f8 ff ff       	jmpq   ffffffff80003b0b <_vsnprintf+0x35b>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff8000420e:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff80004212:	49 8b 7a 08          	mov    0x8(%r10),%rdi
ffffffff80004216:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff8000421a:	49 89 4a 08          	mov    %rcx,0x8(%r10)
ffffffff8000421e:	e9 f1 fc ff ff       	jmpq   ffffffff80003f14 <_vsnprintf+0x764>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff80004223:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
ffffffff80004227:	49 8b 79 08          	mov    0x8(%r9),%rdi
ffffffff8000422b:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff8000422f:	49 89 49 08          	mov    %rcx,0x8(%r9)
ffffffff80004233:	eb 81                	jmp    ffffffff800041b6 <_vsnprintf+0xa06>
          while (l++ < width) {
ffffffff80004235:	c7 45 a8 02 00 00 00 	movl   $0x2,-0x58(%rbp)
ffffffff8000423c:	e9 98 f6 ff ff       	jmpq   ffffffff800038d9 <_vsnprintf+0x129>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff80004241:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
ffffffff80004245:	49 8b 7a 08          	mov    0x8(%r10),%rdi
ffffffff80004249:	48 8d 4f 08          	lea    0x8(%rdi),%rcx
ffffffff8000424d:	49 89 4a 08          	mov    %rcx,0x8(%r10)
ffffffff80004251:	eb 80                	jmp    ffffffff800041d3 <_vsnprintf+0xa23>
        if (*format == 'x' || *format == 'X') {
ffffffff80004253:	89 fa                	mov    %edi,%edx
ffffffff80004255:	83 e2 df             	and    $0xffffffdf,%edx
ffffffff80004258:	80 fa 58             	cmp    $0x58,%dl
ffffffff8000425b:	75 13                	jne    ffffffff80004270 <_vsnprintf+0xac0>
ffffffff8000425d:	ba 10 00 00 00       	mov    $0x10,%edx
ffffffff80004262:	e9 28 f8 ff ff       	jmpq   ffffffff80003a8f <_vsnprintf+0x2df>
ffffffff80004267:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000426e:	00 00 
        else if (*format == 'o') {
ffffffff80004270:	40 80 ff 6f          	cmp    $0x6f,%dil
ffffffff80004274:	74 2a                	je     ffffffff800042a0 <_vsnprintf+0xaf0>
          flags &= ~FLAGS_HASH;   // no hash for dec format
ffffffff80004276:	41 83 e6 ef          	and    $0xffffffef,%r14d
        if ((*format != 'i') && (*format != 'd')) {
ffffffff8000427a:	ba 0a 00 00 00       	mov    $0xa,%edx
ffffffff8000427f:	40 80 ff 69          	cmp    $0x69,%dil
ffffffff80004283:	0f 84 0a f8 ff ff    	je     ffffffff80003a93 <_vsnprintf+0x2e3>
ffffffff80004289:	40 80 ff 64          	cmp    $0x64,%dil
ffffffff8000428d:	0f 84 00 f8 ff ff    	je     ffffffff80003a93 <_vsnprintf+0x2e3>
ffffffff80004293:	e9 f7 f7 ff ff       	jmpq   ffffffff80003a8f <_vsnprintf+0x2df>
ffffffff80004298:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000429f:	00 
ffffffff800042a0:	ba 08 00 00 00       	mov    $0x8,%edx
ffffffff800042a5:	e9 e5 f7 ff ff       	jmpq   ffffffff80003a8f <_vsnprintf+0x2df>
        format++;
ffffffff800042aa:	49 89 cf             	mov    %rcx,%r15
ffffffff800042ad:	e9 f4 f5 ff ff       	jmpq   ffffffff800038a6 <_vsnprintf+0xf6>
ffffffff800042b2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800042b9:	00 00 00 00 
ffffffff800042bd:	0f 1f 00             	nopl   (%rax)

ffffffff800042c0 <printf_>:


///////////////////////////////////////////////////////////////////////////////

int printf_(const char* format, ...)
{
ffffffff800042c0:	55                   	push   %rbp
ffffffff800042c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff800042c4:	48 83 ec 50          	sub    $0x50,%rsp
  va_list va;
  va_start(va, format);
ffffffff800042c8:	48 8d 45 10          	lea    0x10(%rbp),%rax
{
ffffffff800042cc:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff800042d0:	48 8d 75 b7          	lea    -0x49(%rbp),%rsi
  va_start(va, format);
ffffffff800042d4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff800042d8:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
{
ffffffff800042dc:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff800042e0:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
{
ffffffff800042e7:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff800042eb:	48 89 f9             	mov    %rdi,%rcx
ffffffff800042ee:	48 c7 c7 70 37 00 80 	mov    $0xffffffff80003770,%rdi
{
ffffffff800042f5:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff800042f9:	4c 8d 45 b8          	lea    -0x48(%rbp),%r8
{
ffffffff800042fd:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
  va_start(va, format);
ffffffff80004301:	c7 45 b8 08 00 00 00 	movl   $0x8,-0x48(%rbp)
ffffffff80004308:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff8000430c:	e8 9f f4 ff ff       	callq  ffffffff800037b0 <_vsnprintf>
  va_end(va);
  return ret;
}
ffffffff80004311:	c9                   	leaveq 
ffffffff80004312:	c3                   	retq   
ffffffff80004313:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000431a:	00 00 00 00 
ffffffff8000431e:	66 90                	xchg   %ax,%ax

ffffffff80004320 <sprintf_>:


int sprintf_(char* buffer, const char* format, ...)
{
ffffffff80004320:	55                   	push   %rbp
ffffffff80004321:	48 89 e5             	mov    %rsp,%rbp
ffffffff80004324:	48 83 ec 50          	sub    $0x50,%rsp
  va_list va;
  va_start(va, format);
ffffffff80004328:	48 8d 45 10          	lea    0x10(%rbp),%rax
{
ffffffff8000432c:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff80004330:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  va_start(va, format);
ffffffff80004337:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff8000433b:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
{
ffffffff8000433f:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff80004343:	48 89 f1             	mov    %rsi,%rcx
ffffffff80004346:	48 89 fe             	mov    %rdi,%rsi
ffffffff80004349:	48 c7 c7 10 32 00 80 	mov    $0xffffffff80003210,%rdi
{
ffffffff80004350:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff80004354:	4c 8d 45 b8          	lea    -0x48(%rbp),%r8
{
ffffffff80004358:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
  va_start(va, format);
ffffffff8000435c:	c7 45 b8 10 00 00 00 	movl   $0x10,-0x48(%rbp)
ffffffff80004363:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff80004367:	e8 44 f4 ff ff       	callq  ffffffff800037b0 <_vsnprintf>
  va_end(va);
  return ret;
}
ffffffff8000436c:	c9                   	leaveq 
ffffffff8000436d:	c3                   	retq   
ffffffff8000436e:	66 90                	xchg   %ax,%ax

ffffffff80004370 <snprintf_>:


int snprintf_(char* buffer, size_t count, const char* format, ...)
{
ffffffff80004370:	55                   	push   %rbp
ffffffff80004371:	48 89 e5             	mov    %rsp,%rbp
ffffffff80004374:	48 83 ec 50          	sub    $0x50,%rsp
  va_list va;
  va_start(va, format);
ffffffff80004378:	48 8d 45 10          	lea    0x10(%rbp),%rax
{
ffffffff8000437c:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff80004380:	48 89 d1             	mov    %rdx,%rcx
ffffffff80004383:	48 89 f2             	mov    %rsi,%rdx
  va_start(va, format);
ffffffff80004386:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff8000438a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff8000438e:	48 89 fe             	mov    %rdi,%rsi
ffffffff80004391:	48 c7 c7 10 32 00 80 	mov    $0xffffffff80003210,%rdi
{
ffffffff80004398:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff8000439c:	4c 8d 45 b8          	lea    -0x48(%rbp),%r8
{
ffffffff800043a0:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
  va_start(va, format);
ffffffff800043a4:	c7 45 b8 18 00 00 00 	movl   $0x18,-0x48(%rbp)
ffffffff800043ab:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff800043af:	e8 fc f3 ff ff       	callq  ffffffff800037b0 <_vsnprintf>
  va_end(va);
  return ret;
}
ffffffff800043b4:	c9                   	leaveq 
ffffffff800043b5:	c3                   	retq   
ffffffff800043b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800043bd:	00 00 00 

ffffffff800043c0 <vprintf_>:


int vprintf_(const char* format, va_list va)
{
ffffffff800043c0:	55                   	push   %rbp
ffffffff800043c1:	48 89 f9             	mov    %rdi,%rcx
ffffffff800043c4:	49 89 f0             	mov    %rsi,%r8
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff800043c7:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
ffffffff800043ce:	48 c7 c7 70 37 00 80 	mov    $0xffffffff80003770,%rdi
{
ffffffff800043d5:	48 89 e5             	mov    %rsp,%rbp
ffffffff800043d8:	48 83 ec 10          	sub    $0x10,%rsp
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff800043dc:	48 8d 75 ff          	lea    -0x1(%rbp),%rsi
ffffffff800043e0:	e8 cb f3 ff ff       	callq  ffffffff800037b0 <_vsnprintf>
}
ffffffff800043e5:	c9                   	leaveq 
ffffffff800043e6:	c3                   	retq   
ffffffff800043e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800043ee:	00 00 

ffffffff800043f0 <vsnprintf_>:


int vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
ffffffff800043f0:	49 89 c8             	mov    %rcx,%r8
  return _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff800043f3:	48 89 d1             	mov    %rdx,%rcx
ffffffff800043f6:	48 89 f2             	mov    %rsi,%rdx
ffffffff800043f9:	48 89 fe             	mov    %rdi,%rsi
ffffffff800043fc:	48 c7 c7 10 32 00 80 	mov    $0xffffffff80003210,%rdi
ffffffff80004403:	e9 a8 f3 ff ff       	jmpq   ffffffff800037b0 <_vsnprintf>
ffffffff80004408:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000440f:	00 

ffffffff80004410 <fctprintf>:
}


int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
ffffffff80004410:	55                   	push   %rbp
ffffffff80004411:	48 89 e5             	mov    %rsp,%rbp
ffffffff80004414:	48 83 ec 60          	sub    $0x60,%rsp
  va_list va;
  va_start(va, format);
ffffffff80004418:	48 8d 45 10          	lea    0x10(%rbp),%rax
{
ffffffff8000441c:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff80004420:	48 89 d1             	mov    %rdx,%rcx
ffffffff80004423:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  va_start(va, format);
ffffffff8000442a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff8000442e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
{
ffffffff80004432:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff80004436:	4c 8d 45 b8          	lea    -0x48(%rbp),%r8
{
ffffffff8000443a:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
  va_start(va, format);
ffffffff8000443e:	c7 45 b8 18 00 00 00 	movl   $0x18,-0x48(%rbp)
ffffffff80004445:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  const out_fct_wrap_type out_fct_wrap = { out, arg };
ffffffff80004449:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff8000444d:	48 c7 c7 90 37 00 80 	mov    $0xffffffff80003790,%rdi
  const out_fct_wrap_type out_fct_wrap = { out, arg };
ffffffff80004454:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff80004458:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
ffffffff8000445c:	e8 4f f3 ff ff       	callq  ffffffff800037b0 <_vsnprintf>
  va_end(va);
  return ret;
ffffffff80004461:	c9                   	leaveq 
ffffffff80004462:	c3                   	retq   
ffffffff80004463:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000446a:	00 00 00 
ffffffff8000446d:	0f 1f 00             	nopl   (%rax)

ffffffff80004470 <_putchar>:


void _putchar(char character)
{
    
    putchar(character);
ffffffff80004470:	40 0f b6 ff          	movzbl %dil,%edi
ffffffff80004474:	e9 e7 c2 ff ff       	jmpq   ffffffff80000760 <putchar>
ffffffff80004479:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80004480 <serial_printf>:
    
    //serial_write(0x3F8, character);
}

void serial_printf(uint16_t port, const char* format, ...)
{
ffffffff80004480:	55                   	push   %rbp
ffffffff80004481:	48 89 e5             	mov    %rsp,%rbp
ffffffff80004484:	53                   	push   %rbx
ffffffff80004485:	89 fb                	mov    %edi,%ebx
    char buffer[256];

    va_list argptr;
    va_start(argptr, format);
ffffffff80004487:	48 8d 45 10          	lea    0x10(%rbp),%rax
    vsnprintf(buffer, 256, format, argptr);
ffffffff8000448b:	48 8d bd c0 fe ff ff 	lea    -0x140(%rbp),%rdi
{
ffffffff80004492:	48 81 ec 58 01 00 00 	sub    $0x158,%rsp
    va_start(argptr, format);
ffffffff80004499:	48 89 85 b0 fe ff ff 	mov    %rax,-0x150(%rbp)
ffffffff800044a0:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
{
ffffffff800044a4:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
    vsnprintf(buffer, 256, format, argptr);
ffffffff800044a8:	48 89 f2             	mov    %rsi,%rdx
ffffffff800044ab:	be 00 01 00 00       	mov    $0x100,%esi
{
ffffffff800044b0:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    vsnprintf(buffer, 256, format, argptr);
ffffffff800044b4:	48 8d 8d a8 fe ff ff 	lea    -0x158(%rbp),%rcx
{
ffffffff800044bb:	4c 89 45 e0          	mov    %r8,-0x20(%rbp)
ffffffff800044bf:	4c 89 4d e8          	mov    %r9,-0x18(%rbp)
    va_start(argptr, format);
ffffffff800044c3:	c7 85 a8 fe ff ff 10 	movl   $0x10,-0x158(%rbp)
ffffffff800044ca:	00 00 00 
ffffffff800044cd:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
    vsnprintf(buffer, 256, format, argptr);
ffffffff800044d4:	e8 17 ff ff ff       	callq  ffffffff800043f0 <vsnprintf_>
    va_end(argptr);

    serial_write_str(port, buffer);
ffffffff800044d9:	0f b7 fb             	movzwl %bx,%edi
ffffffff800044dc:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
ffffffff800044e3:	e8 d8 cc ff ff       	callq  ffffffff800011c0 <serial_write_str>
}
ffffffff800044e8:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
ffffffff800044ec:	c9                   	leaveq 
ffffffff800044ed:	c3                   	retq   
ffffffff800044ee:	66 90                	xchg   %ax,%ax

ffffffff800044f0 <bootloader_printf>:

void bootloader_printf(const char* format, ...)
{
ffffffff800044f0:	55                   	push   %rbp
ffffffff800044f1:	48 89 e5             	mov    %rsp,%rbp
ffffffff800044f4:	48 81 ec 50 01 00 00 	sub    $0x150,%rsp
    char buffer[256];
    va_list argptr;
    va_start(argptr, format);
ffffffff800044fb:	48 8d 45 10          	lea    0x10(%rbp),%rax
{
ffffffff800044ff:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
    vsnprintf(buffer, 256, format, argptr);
ffffffff80004503:	be 00 01 00 00       	mov    $0x100,%esi
    va_start(argptr, format);
ffffffff80004508:	48 89 85 c0 fe ff ff 	mov    %rax,-0x140(%rbp)
ffffffff8000450f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
{
ffffffff80004513:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
    vsnprintf(buffer, 256, format, argptr);
ffffffff80004517:	48 89 fa             	mov    %rdi,%rdx
ffffffff8000451a:	48 8d bd d0 fe ff ff 	lea    -0x130(%rbp),%rdi
{
ffffffff80004521:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
    vsnprintf(buffer, 256, format, argptr);
ffffffff80004525:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
{
ffffffff8000452c:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
ffffffff80004530:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
    va_start(argptr, format);
ffffffff80004534:	c7 85 b8 fe ff ff 08 	movl   $0x8,-0x148(%rbp)
ffffffff8000453b:	00 00 00 
ffffffff8000453e:	48 89 85 c8 fe ff ff 	mov    %rax,-0x138(%rbp)
    vsnprintf(buffer, 256, format, argptr);
ffffffff80004545:	e8 a6 fe ff ff       	callq  ffffffff800043f0 <vsnprintf_>
    else if(boot_info.type == LIMINE)
    {
  
        //limine_term_write(boot_info.limine_terminal, buffer, strlen(buffer));
    }
ffffffff8000454a:	c9                   	leaveq 
ffffffff8000454b:	c3                   	retq   
ffffffff8000454c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80004550 <vfs_init>:
void vfs_init()
{
    //create file descriptors for STDIN, STDOUT, and STDERR
    

};
ffffffff80004550:	c3                   	retq   
