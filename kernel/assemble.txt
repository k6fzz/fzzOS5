
./bin/kernel.elf:     file format elf64-x86-64


Disassembly of section .text:

ffffffff80000000 <to_usermode>:
ffffffff80000000:	48 89 f9             	mov    %rdi,%rcx
ffffffff80000003:	48 89 f4             	mov    %rsi,%rsp
ffffffff80000006:	41 bb 02 32 00 00    	mov    $0x3202,%r11d
ffffffff8000000c:	48 0f 07             	sysretq 

ffffffff8000000f <read_msr>:
ffffffff8000000f:	48 89 f9             	mov    %rdi,%rcx
ffffffff80000012:	0f 32                	rdmsr  
ffffffff80000014:	c3                   	retq   

ffffffff80000015 <enable_syscall>:
ffffffff80000015:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff8000001a:	0f 32                	rdmsr  
ffffffff8000001c:	83 c8 01             	or     $0x1,%eax
ffffffff8000001f:	0f 30                	wrmsr  
ffffffff80000021:	b9 81 00 00 c0       	mov    $0xc0000081,%ecx
ffffffff80000026:	0f 32                	rdmsr  
ffffffff80000028:	48 89 fa             	mov    %rdi,%rdx
ffffffff8000002b:	0f 30                	wrmsr  
ffffffff8000002d:	b9 82 00 00 c0       	mov    $0xc0000082,%ecx
ffffffff80000032:	0f 32                	rdmsr  
ffffffff80000034:	48 89 f0             	mov    %rsi,%rax
ffffffff80000037:	48 89 f2             	mov    %rsi,%rdx
ffffffff8000003a:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff8000003e:	0f 30                	wrmsr  
ffffffff80000040:	c3                   	retq   

ffffffff80000041 <enable_sce>:
ffffffff80000041:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff80000046:	0f 32                	rdmsr  
ffffffff80000048:	83 c8 01             	or     $0x1,%eax
ffffffff8000004b:	0f 30                	wrmsr  
ffffffff8000004d:	b9 81 00 00 c0       	mov    $0xc0000081,%ecx
ffffffff80000052:	0f 32                	rdmsr  
ffffffff80000054:	ba 08 00 18 00       	mov    $0x180008,%edx
ffffffff80000059:	0f 30                	wrmsr  
ffffffff8000005b:	c3                   	retq   

ffffffff8000005c <__syscall_handler>:
ffffffff8000005c:	53                   	push   %rbx
ffffffff8000005d:	54                   	push   %rsp
ffffffff8000005e:	55                   	push   %rbp
ffffffff8000005f:	41 54                	push   %r12
ffffffff80000061:	41 55                	push   %r13
ffffffff80000063:	41 56                	push   %r14
ffffffff80000065:	41 57                	push   %r15
ffffffff80000067:	51                   	push   %rcx
ffffffff80000068:	e8 23 04 00 00       	callq  ffffffff80000490 <syscall_handler>
ffffffff8000006d:	59                   	pop    %rcx
ffffffff8000006e:	41 5f                	pop    %r15
ffffffff80000070:	41 5e                	pop    %r14
ffffffff80000072:	41 5d                	pop    %r13
ffffffff80000074:	41 5c                	pop    %r12
ffffffff80000076:	5d                   	pop    %rbp
ffffffff80000077:	5c                   	pop    %rsp
ffffffff80000078:	5b                   	pop    %rbx
ffffffff80000079:	48 0f 07             	sysretq 

ffffffff8000007c <__syscall_handler.end>:
ffffffff8000007c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000080 <switch_to_task>:
ffffffff80000080:	50                   	push   %rax
ffffffff80000081:	53                   	push   %rbx
ffffffff80000082:	51                   	push   %rcx
ffffffff80000083:	52                   	push   %rdx
ffffffff80000084:	56                   	push   %rsi
ffffffff80000085:	57                   	push   %rdi
ffffffff80000086:	55                   	push   %rbp
ffffffff80000087:	41 50                	push   %r8
ffffffff80000089:	41 51                	push   %r9
ffffffff8000008b:	41 52                	push   %r10
ffffffff8000008d:	41 53                	push   %r11
ffffffff8000008f:	41 54                	push   %r12
ffffffff80000091:	41 55                	push   %r13
ffffffff80000093:	41 56                	push   %r14
ffffffff80000095:	41 57                	push   %r15

ffffffff80000097 <switch_to_task.end>:
ffffffff80000097:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000009e:	00 00 

ffffffff800000a0 <vmm_read_cr3>:
ffffffff800000a0:	0f 20 d8             	mov    %cr3,%rax
ffffffff800000a3:	c3                   	retq   

ffffffff800000a4 <vmm_write_cr3>:
ffffffff800000a4:	0f 22 df             	mov    %rdi,%cr3
ffffffff800000a7:	c3                   	retq   

ffffffff800000a8 <vmm_flush_tlb>:
ffffffff800000a8:	0f 01 3f             	invlpg (%rdi)
ffffffff800000ab:	c3                   	retq   

ffffffff800000ac <vmm_read_efer>:
ffffffff800000ac:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff800000b1:	0f 32                	rdmsr  
ffffffff800000b3:	c3                   	retq   

ffffffff800000b4 <vmm_enable_nxe>:
ffffffff800000b4:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff800000b9:	0f 32                	rdmsr  
ffffffff800000bb:	0d 00 08 00 00       	or     $0x800,%eax
ffffffff800000c0:	0f 30                	wrmsr  

ffffffff800000c2 <vmm_enable_nxe.end>:
ffffffff800000c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800000c9:	00 00 00 
ffffffff800000cc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff800000d0 <gdt_load>:
ffffffff800000d0:	0f 01 17             	lgdt   (%rdi)
ffffffff800000d3:	55                   	push   %rbp
ffffffff800000d4:	48 89 e5             	mov    %rsp,%rbp
ffffffff800000d7:	6a 10                	pushq  $0x10
ffffffff800000d9:	55                   	push   %rbp
ffffffff800000da:	9c                   	pushfq 
ffffffff800000db:	6a 08                	pushq  $0x8
ffffffff800000dd:	68 e4 00 00 80       	pushq  $0xffffffff800000e4
ffffffff800000e2:	48 cf                	iretq  

ffffffff800000e4 <gdt_load.trampoline>:
ffffffff800000e4:	5d                   	pop    %rbp
ffffffff800000e5:	66 b8 10 00          	mov    $0x10,%ax
ffffffff800000e9:	8e d8                	mov    %eax,%ds
ffffffff800000eb:	8e c0                	mov    %eax,%es
ffffffff800000ed:	8e e0                	mov    %eax,%fs
ffffffff800000ef:	8e e8                	mov    %eax,%gs
ffffffff800000f1:	8e d0                	mov    %eax,%ss
ffffffff800000f3:	66 b8 50 00          	mov    $0x50,%ax
ffffffff800000f7:	0f 00 d8             	ltr    %ax
ffffffff800000fa:	c3                   	retq   

ffffffff800000fb <gdt_load.end>:
ffffffff800000fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80000100 <read_cr2>:
ffffffff80000100:	0f 20 d0             	mov    %cr2,%rax
ffffffff80000103:	c3                   	retq   

ffffffff80000104 <_interrupt_common>:
ffffffff80000104:	fc                   	cld    
ffffffff80000105:	50                   	push   %rax
ffffffff80000106:	53                   	push   %rbx
ffffffff80000107:	51                   	push   %rcx
ffffffff80000108:	52                   	push   %rdx
ffffffff80000109:	56                   	push   %rsi
ffffffff8000010a:	57                   	push   %rdi
ffffffff8000010b:	55                   	push   %rbp
ffffffff8000010c:	41 50                	push   %r8
ffffffff8000010e:	41 51                	push   %r9
ffffffff80000110:	41 52                	push   %r10
ffffffff80000112:	41 53                	push   %r11
ffffffff80000114:	41 54                	push   %r12
ffffffff80000116:	41 55                	push   %r13
ffffffff80000118:	41 56                	push   %r14
ffffffff8000011a:	41 57                	push   %r15
ffffffff8000011c:	48 89 e7             	mov    %rsp,%rdi
ffffffff8000011f:	e8 fc 3c 00 00       	callq  ffffffff80003e20 <interrupt_handler>
ffffffff80000124:	48 89 c4             	mov    %rax,%rsp
ffffffff80000127:	41 5f                	pop    %r15
ffffffff80000129:	41 5e                	pop    %r14
ffffffff8000012b:	41 5d                	pop    %r13
ffffffff8000012d:	41 5c                	pop    %r12
ffffffff8000012f:	41 5b                	pop    %r11
ffffffff80000131:	41 5a                	pop    %r10
ffffffff80000133:	41 59                	pop    %r9
ffffffff80000135:	41 58                	pop    %r8
ffffffff80000137:	5d                   	pop    %rbp
ffffffff80000138:	5f                   	pop    %rdi
ffffffff80000139:	5e                   	pop    %rsi
ffffffff8000013a:	5a                   	pop    %rdx
ffffffff8000013b:	59                   	pop    %rcx
ffffffff8000013c:	5b                   	pop    %rbx
ffffffff8000013d:	58                   	pop    %rax
ffffffff8000013e:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80000142:	48 cf                	iretq  

ffffffff80000144 <_interrupt0>:
ffffffff80000144:	6a 00                	pushq  $0x0
ffffffff80000146:	6a 00                	pushq  $0x0
ffffffff80000148:	eb ba                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff8000014a <_interrupt1>:
ffffffff8000014a:	6a 00                	pushq  $0x0
ffffffff8000014c:	6a 01                	pushq  $0x1
ffffffff8000014e:	eb b4                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff80000150 <_interrupt2>:
ffffffff80000150:	6a 00                	pushq  $0x0
ffffffff80000152:	6a 02                	pushq  $0x2
ffffffff80000154:	eb ae                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff80000156 <_interrupt3>:
ffffffff80000156:	6a 00                	pushq  $0x0
ffffffff80000158:	6a 03                	pushq  $0x3
ffffffff8000015a:	eb a8                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff8000015c <_interrupt4>:
ffffffff8000015c:	6a 00                	pushq  $0x0
ffffffff8000015e:	6a 04                	pushq  $0x4
ffffffff80000160:	eb a2                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff80000162 <_interrupt5>:
ffffffff80000162:	6a 00                	pushq  $0x0
ffffffff80000164:	6a 05                	pushq  $0x5
ffffffff80000166:	eb 9c                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff80000168 <_interrupt6>:
ffffffff80000168:	6a 00                	pushq  $0x0
ffffffff8000016a:	6a 06                	pushq  $0x6
ffffffff8000016c:	eb 96                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff8000016e <_interrupt7>:
ffffffff8000016e:	6a 00                	pushq  $0x0
ffffffff80000170:	6a 07                	pushq  $0x7
ffffffff80000172:	eb 90                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff80000174 <_interrupt8>:
ffffffff80000174:	6a 08                	pushq  $0x8
ffffffff80000176:	eb 8c                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff80000178 <_interrupt9>:
ffffffff80000178:	6a 00                	pushq  $0x0
ffffffff8000017a:	6a 09                	pushq  $0x9
ffffffff8000017c:	eb 86                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff8000017e <_interrupt10>:
ffffffff8000017e:	6a 0a                	pushq  $0xa
ffffffff80000180:	eb 82                	jmp    ffffffff80000104 <_interrupt_common>

ffffffff80000182 <_interrupt11>:
ffffffff80000182:	6a 0b                	pushq  $0xb
ffffffff80000184:	e9 7b ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000189 <_interrupt12>:
ffffffff80000189:	6a 0c                	pushq  $0xc
ffffffff8000018b:	e9 74 ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000190 <_interrupt13>:
ffffffff80000190:	6a 0d                	pushq  $0xd
ffffffff80000192:	e9 6d ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000197 <_interrupt14>:
ffffffff80000197:	6a 0e                	pushq  $0xe
ffffffff80000199:	e9 66 ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff8000019e <_interrupt15>:
ffffffff8000019e:	6a 00                	pushq  $0x0
ffffffff800001a0:	6a 0f                	pushq  $0xf
ffffffff800001a2:	e9 5d ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001a7 <_interrupt16>:
ffffffff800001a7:	6a 00                	pushq  $0x0
ffffffff800001a9:	6a 10                	pushq  $0x10
ffffffff800001ab:	e9 54 ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001b0 <_interrupt17>:
ffffffff800001b0:	6a 11                	pushq  $0x11
ffffffff800001b2:	e9 4d ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001b7 <_interrupt18>:
ffffffff800001b7:	6a 00                	pushq  $0x0
ffffffff800001b9:	6a 12                	pushq  $0x12
ffffffff800001bb:	e9 44 ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001c0 <_interrupt19>:
ffffffff800001c0:	6a 00                	pushq  $0x0
ffffffff800001c2:	6a 13                	pushq  $0x13
ffffffff800001c4:	e9 3b ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001c9 <_interrupt20>:
ffffffff800001c9:	6a 00                	pushq  $0x0
ffffffff800001cb:	6a 14                	pushq  $0x14
ffffffff800001cd:	e9 32 ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001d2 <_interrupt21>:
ffffffff800001d2:	6a 00                	pushq  $0x0
ffffffff800001d4:	6a 15                	pushq  $0x15
ffffffff800001d6:	e9 29 ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001db <_interrupt22>:
ffffffff800001db:	6a 00                	pushq  $0x0
ffffffff800001dd:	6a 16                	pushq  $0x16
ffffffff800001df:	e9 20 ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001e4 <_interrupt23>:
ffffffff800001e4:	6a 00                	pushq  $0x0
ffffffff800001e6:	6a 17                	pushq  $0x17
ffffffff800001e8:	e9 17 ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001ed <_interrupt24>:
ffffffff800001ed:	6a 00                	pushq  $0x0
ffffffff800001ef:	6a 18                	pushq  $0x18
ffffffff800001f1:	e9 0e ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001f6 <_interrupt25>:
ffffffff800001f6:	6a 00                	pushq  $0x0
ffffffff800001f8:	6a 19                	pushq  $0x19
ffffffff800001fa:	e9 05 ff ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800001ff <_interrupt26>:
ffffffff800001ff:	6a 00                	pushq  $0x0
ffffffff80000201:	6a 1a                	pushq  $0x1a
ffffffff80000203:	e9 fc fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000208 <_interrupt27>:
ffffffff80000208:	6a 00                	pushq  $0x0
ffffffff8000020a:	6a 1b                	pushq  $0x1b
ffffffff8000020c:	e9 f3 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000211 <_interrupt28>:
ffffffff80000211:	6a 00                	pushq  $0x0
ffffffff80000213:	6a 1c                	pushq  $0x1c
ffffffff80000215:	e9 ea fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff8000021a <_interrupt29>:
ffffffff8000021a:	6a 00                	pushq  $0x0
ffffffff8000021c:	6a 1d                	pushq  $0x1d
ffffffff8000021e:	e9 e1 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000223 <_interrupt30>:
ffffffff80000223:	6a 1e                	pushq  $0x1e
ffffffff80000225:	e9 da fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff8000022a <_interrupt31>:
ffffffff8000022a:	6a 00                	pushq  $0x0
ffffffff8000022c:	6a 1f                	pushq  $0x1f
ffffffff8000022e:	e9 d1 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000233 <_interrupt32>:
ffffffff80000233:	6a 00                	pushq  $0x0
ffffffff80000235:	6a 20                	pushq  $0x20
ffffffff80000237:	e9 c8 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff8000023c <_interrupt33>:
ffffffff8000023c:	6a 00                	pushq  $0x0
ffffffff8000023e:	6a 21                	pushq  $0x21
ffffffff80000240:	e9 bf fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000245 <_interrupt34>:
ffffffff80000245:	6a 00                	pushq  $0x0
ffffffff80000247:	6a 22                	pushq  $0x22
ffffffff80000249:	e9 b6 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff8000024e <_interrupt35>:
ffffffff8000024e:	6a 00                	pushq  $0x0
ffffffff80000250:	6a 23                	pushq  $0x23
ffffffff80000252:	e9 ad fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000257 <_interrupt36>:
ffffffff80000257:	6a 00                	pushq  $0x0
ffffffff80000259:	6a 24                	pushq  $0x24
ffffffff8000025b:	e9 a4 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000260 <_interrupt37>:
ffffffff80000260:	6a 00                	pushq  $0x0
ffffffff80000262:	6a 25                	pushq  $0x25
ffffffff80000264:	e9 9b fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000269 <_interrupt38>:
ffffffff80000269:	6a 00                	pushq  $0x0
ffffffff8000026b:	6a 26                	pushq  $0x26
ffffffff8000026d:	e9 92 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000272 <_interrupt39>:
ffffffff80000272:	6a 00                	pushq  $0x0
ffffffff80000274:	6a 27                	pushq  $0x27
ffffffff80000276:	e9 89 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff8000027b <_interrupt40>:
ffffffff8000027b:	6a 00                	pushq  $0x0
ffffffff8000027d:	6a 28                	pushq  $0x28
ffffffff8000027f:	e9 80 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000284 <_interrupt41>:
ffffffff80000284:	6a 00                	pushq  $0x0
ffffffff80000286:	6a 29                	pushq  $0x29
ffffffff80000288:	e9 77 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff8000028d <_interrupt42>:
ffffffff8000028d:	6a 00                	pushq  $0x0
ffffffff8000028f:	6a 2a                	pushq  $0x2a
ffffffff80000291:	e9 6e fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff80000296 <_interrupt43>:
ffffffff80000296:	6a 00                	pushq  $0x0
ffffffff80000298:	6a 2b                	pushq  $0x2b
ffffffff8000029a:	e9 65 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff8000029f <_interrupt44>:
ffffffff8000029f:	6a 00                	pushq  $0x0
ffffffff800002a1:	6a 2c                	pushq  $0x2c
ffffffff800002a3:	e9 5c fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800002a8 <_interrupt45>:
ffffffff800002a8:	6a 00                	pushq  $0x0
ffffffff800002aa:	6a 2d                	pushq  $0x2d
ffffffff800002ac:	e9 53 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800002b1 <_interrupt46>:
ffffffff800002b1:	6a 00                	pushq  $0x0
ffffffff800002b3:	6a 2e                	pushq  $0x2e
ffffffff800002b5:	e9 4a fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800002ba <_interrupt47>:
ffffffff800002ba:	6a 00                	pushq  $0x0
ffffffff800002bc:	6a 2f                	pushq  $0x2f
ffffffff800002be:	e9 41 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800002c3 <_interrupt127>:
ffffffff800002c3:	6a 00                	pushq  $0x0
ffffffff800002c5:	6a 7f                	pushq  $0x7f
ffffffff800002c7:	e9 38 fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800002cc <_interrupt128>:
ffffffff800002cc:	6a 00                	pushq  $0x0
ffffffff800002ce:	68 80 00 00 00       	pushq  $0x80
ffffffff800002d3:	e9 2c fe ff ff       	jmpq   ffffffff80000104 <_interrupt_common>

ffffffff800002d8 <isr_stub_table>:
ffffffff800002d8:	44 01 00 80 ff ff ff ff 4a 01 00 80 ff ff ff ff     D.......J.......
ffffffff800002e8:	50 01 00 80 ff ff ff ff 56 01 00 80 ff ff ff ff     P.......V.......
ffffffff800002f8:	5c 01 00 80 ff ff ff ff 62 01 00 80 ff ff ff ff     \.......b.......
ffffffff80000308:	68 01 00 80 ff ff ff ff 6e 01 00 80 ff ff ff ff     h.......n.......
ffffffff80000318:	74 01 00 80 ff ff ff ff 78 01 00 80 ff ff ff ff     t.......x.......
ffffffff80000328:	7e 01 00 80 ff ff ff ff 82 01 00 80 ff ff ff ff     ~...............
ffffffff80000338:	89 01 00 80 ff ff ff ff 90 01 00 80 ff ff ff ff     ................
ffffffff80000348:	97 01 00 80 ff ff ff ff 9e 01 00 80 ff ff ff ff     ................
ffffffff80000358:	a7 01 00 80 ff ff ff ff b0 01 00 80 ff ff ff ff     ................
ffffffff80000368:	b7 01 00 80 ff ff ff ff c0 01 00 80 ff ff ff ff     ................
ffffffff80000378:	c9 01 00 80 ff ff ff ff d2 01 00 80 ff ff ff ff     ................
ffffffff80000388:	db 01 00 80 ff ff ff ff e4 01 00 80 ff ff ff ff     ................
ffffffff80000398:	ed 01 00 80 ff ff ff ff f6 01 00 80 ff ff ff ff     ................
ffffffff800003a8:	ff 01 00 80 ff ff ff ff 08 02 00 80 ff ff ff ff     ................
ffffffff800003b8:	11 02 00 80 ff ff ff ff 1a 02 00 80 ff ff ff ff     ................
ffffffff800003c8:	23 02 00 80 ff ff ff ff 2a 02 00 80 ff ff ff ff     #.......*.......
ffffffff800003d8:	33 02 00 80 ff ff ff ff 3c 02 00 80 ff ff ff ff     3.......<.......
ffffffff800003e8:	45 02 00 80 ff ff ff ff 4e 02 00 80 ff ff ff ff     E.......N.......
ffffffff800003f8:	57 02 00 80 ff ff ff ff 60 02 00 80 ff ff ff ff     W.......`.......
ffffffff80000408:	69 02 00 80 ff ff ff ff 72 02 00 80 ff ff ff ff     i.......r.......
ffffffff80000418:	7b 02 00 80 ff ff ff ff 84 02 00 80 ff ff ff ff     {...............
ffffffff80000428:	8d 02 00 80 ff ff ff ff 96 02 00 80 ff ff ff ff     ................
ffffffff80000438:	9f 02 00 80 ff ff ff ff a8 02 00 80 ff ff ff ff     ................
ffffffff80000448:	b1 02 00 80 ff ff ff ff ba 02 00 80 ff ff ff ff     ................
ffffffff80000458:	c3 02 00 80 ff ff ff ff cc 02 00 80 ff ff ff ff     ................

ffffffff80000468 <idt_load>:
ffffffff80000468:	0f 01 1f             	lidt   (%rdi)
ffffffff8000046b:	fb                   	sti    
ffffffff8000046c:	c3                   	retq   

ffffffff8000046d <int_test>:
ffffffff8000046d:	cd 7f                	int    $0x7f
ffffffff8000046f:	c3                   	retq   

ffffffff80000470 <user_init>:
extern void __syscall_handler();
extern void enable_syscall(uint64_t STAR, void* handler);

void user_init()
{
    enable_syscall(0x00180008, &__syscall_handler);
ffffffff80000470:	48 c7 c6 5c 00 00 80 	mov    $0xffffffff8000005c,%rsi
ffffffff80000477:	bf 08 00 18 00       	mov    $0x180008,%edi
ffffffff8000047c:	e9 94 fb ff ff       	jmpq   ffffffff80000015 <enable_syscall>
ffffffff80000481:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000488:	00 00 00 00 
ffffffff8000048c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000490 <syscall_handler>:
    //enable_sce();
    //set_lstar(__syscall_handler);
}

uint64_t syscall_handler(uint64_t num, uint64_t param1, uint64_t param2, uint64_t param3, uint64_t param4, uint64_t param5)
{
ffffffff80000490:	48 83 ff 10          	cmp    $0x10,%rdi
        case 3:         //close
            break;
        case 0x10:      //ioctl
            break;
        default:
            return -1;
ffffffff80000494:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8000049b:	77 3b                	ja     ffffffff800004d8 <syscall_handler+0x48>
ffffffff8000049d:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff800004a2:	89 f9                	mov    %edi,%ecx
    }

    return 0;
ffffffff800004a4:	31 c0                	xor    %eax,%eax
ffffffff800004a6:	48 d3 e2             	shl    %cl,%rdx
ffffffff800004a9:	f7 c2 0d 00 01 00    	test   $0x1000d,%edx
ffffffff800004af:	75 27                	jne    ffffffff800004d8 <syscall_handler+0x48>
ffffffff800004b1:	83 e2 02             	and    $0x2,%edx
            return -1;
ffffffff800004b4:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff800004bb:	74 1b                	je     ffffffff800004d8 <syscall_handler+0x48>
{
ffffffff800004bd:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff800004c1:	48 89 f7             	mov    %rsi,%rdi
            printf((char*)param1);
ffffffff800004c4:	31 c0                	xor    %eax,%eax
ffffffff800004c6:	e8 e5 32 00 00       	callq  ffffffff800037b0 <printf_>
    return 0;
ffffffff800004cb:	31 c0                	xor    %eax,%eax
}
ffffffff800004cd:	48 83 c4 08          	add    $0x8,%rsp
ffffffff800004d1:	c3                   	retq   
ffffffff800004d2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff800004d8:	f3 c3                	repz retq 
ffffffff800004da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff800004e0 <schedule>:
ffffffff800004e0:	f3 c3                	repz retq 
ffffffff800004e2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800004e9:	00 00 00 00 
ffffffff800004ed:	0f 1f 00             	nopl   (%rax)

ffffffff800004f0 <scheduler_init>:
}

void scheduler_init()
{

ffffffff800004f0:	f3 c3                	repz retq 
ffffffff800004f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800004f9:	00 00 00 
ffffffff800004fc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000500 <_start>:
    //void* term_write_ptr = (void *)term_str_tag->term_write;
    //term_write = term_write_ptr;
    //printf("Terminal Initialized\n");

    //Grab the Framebuffer
    boot_info.tag_framebuffer = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_FRAMEBUFFER_ID);
ffffffff80000500:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
        if (current_tag == NULL) {
ffffffff80000507:	48 85 c0             	test   %rax,%rax
ffffffff8000050a:	74 29                	je     ffffffff80000535 <_start+0x35>
        if (current_tag->identifier == id) {
ffffffff8000050c:	48 8b 08             	mov    (%rax),%rcx
ffffffff8000050f:	48 be fa 08 04 95 d2 	movabs $0x506461d2950408fa,%rsi
ffffffff80000516:	61 64 50 
ffffffff80000519:	48 39 f1             	cmp    %rsi,%rcx
ffffffff8000051c:	0f 84 89 01 00 00    	je     ffffffff800006ab <_start+0x1ab>
ffffffff80000522:	48 89 c2             	mov    %rax,%rdx
ffffffff80000525:	eb 05                	jmp    ffffffff8000052c <_start+0x2c>
ffffffff80000527:	48 39 32             	cmp    %rsi,(%rdx)
ffffffff8000052a:	74 17                	je     ffffffff80000543 <_start+0x43>
        current_tag = (void *)current_tag->next;
ffffffff8000052c:	48 8b 52 08          	mov    0x8(%rdx),%rdx
        if (current_tag == NULL) {
ffffffff80000530:	48 85 d2             	test   %rdx,%rdx
ffffffff80000533:	75 f2                	jne    ffffffff80000527 <_start+0x27>
    boot_info.tag_framebuffer = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_FRAMEBUFFER_ID);
ffffffff80000535:	48 c7 05 b8 a8 00 00 	movq   $0x0,0xa8b8(%rip)        # ffffffff8000adf8 <boot_info+0x18>
ffffffff8000053c:	00 00 00 00 
    if (boot_info.tag_framebuffer == NULL)
    {
    //  printf("Framebuffer Not Found\n");
        for( ;; ) 
            asm("hlt");
ffffffff80000540:	f4                   	hlt    
ffffffff80000541:	eb fd                	jmp    ffffffff80000540 <_start+0x40>
    boot_info.tag_framebuffer = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_FRAMEBUFFER_ID);
ffffffff80000543:	48 89 15 ae a8 00 00 	mov    %rdx,0xa8ae(%rip)        # ffffffff8000adf8 <boot_info+0x18>
        if (current_tag->identifier == id) {
ffffffff8000054a:	48 ba 07 de 12 86 9e 	movabs $0x2187f79e8612de07,%rdx
ffffffff80000551:	f7 87 21 
ffffffff80000554:	48 39 d1             	cmp    %rdx,%rcx
ffffffff80000557:	0f 84 f2 01 00 00    	je     ffffffff8000074f <_start+0x24f>
ffffffff8000055d:	48 89 c2             	mov    %rax,%rdx
ffffffff80000560:	48 be 07 de 12 86 9e 	movabs $0x2187f79e8612de07,%rsi
ffffffff80000567:	f7 87 21 
ffffffff8000056a:	eb 05                	jmp    ffffffff80000571 <_start+0x71>
ffffffff8000056c:	48 39 32             	cmp    %rsi,(%rdx)
ffffffff8000056f:	74 1a                	je     ffffffff8000058b <_start+0x8b>
        current_tag = (void *)current_tag->next;
ffffffff80000571:	48 8b 52 08          	mov    0x8(%rdx),%rdx
        if (current_tag == NULL) {
ffffffff80000575:	48 85 d2             	test   %rdx,%rdx
ffffffff80000578:	75 f2                	jne    ffffffff8000056c <_start+0x6c>
    }
 
    //Memory Map
    boot_info.tag_memmap = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MEMMAP_ID);
ffffffff8000057a:	48 c7 05 6b a8 00 00 	movq   $0x0,0xa86b(%rip)        # ffffffff8000adf0 <boot_info+0x10>
ffffffff80000581:	00 00 00 00 
ffffffff80000585:	0f 1f 00             	nopl   (%rax)
    if (boot_info.tag_memmap == NULL)
    {
    //    printf("Memory Map Not Found\n");
        for( ;; ) 
            asm("hlt");
ffffffff80000588:	f4                   	hlt    
ffffffff80000589:	eb fd                	jmp    ffffffff80000588 <_start+0x88>
    boot_info.tag_memmap = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MEMMAP_ID);
ffffffff8000058b:	48 89 15 5e a8 00 00 	mov    %rdx,0xa85e(%rip)        # ffffffff8000adf0 <boot_info+0x10>
        if (current_tag->identifier == id) {
ffffffff80000592:	48 ba f0 8a 2a 4a 87 	movabs $0x60d78874a2a8af0,%rdx
ffffffff80000599:	78 0d 06 
ffffffff8000059c:	48 39 d1             	cmp    %rdx,%rcx
ffffffff8000059f:	0f 84 9e 01 00 00    	je     ffffffff80000743 <_start+0x243>
ffffffff800005a5:	48 89 c2             	mov    %rax,%rdx
ffffffff800005a8:	48 be f0 8a 2a 4a 87 	movabs $0x60d78874a2a8af0,%rsi
ffffffff800005af:	78 0d 06 
        current_tag = (void *)current_tag->next;
ffffffff800005b2:	48 8b 52 08          	mov    0x8(%rdx),%rdx
        if (current_tag == NULL) {
ffffffff800005b6:	48 85 d2             	test   %rdx,%rdx
ffffffff800005b9:	74 50                	je     ffffffff8000060b <_start+0x10b>
        if (current_tag->identifier == id) {
ffffffff800005bb:	48 39 32             	cmp    %rsi,(%rdx)
ffffffff800005be:	75 f2                	jne    ffffffff800005b2 <_start+0xb2>
    }
 
    //Kernel Base Address
    boot_info.tag_kernel_base_address = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_KERNEL_BASE_ADDRESS_ID);
ffffffff800005c0:	48 89 15 19 a8 00 00 	mov    %rdx,0xa819(%rip)        # ffffffff8000ade0 <boot_info>
        if (current_tag->identifier == id) {
ffffffff800005c7:	48 ba 78 5e 37 0a 93 	movabs $0x9e1786930a375e78,%rdx
ffffffff800005ce:	86 17 9e 
ffffffff800005d1:	48 39 d1             	cmp    %rdx,%rcx
ffffffff800005d4:	0f 84 5d 01 00 00    	je     ffffffff80000737 <_start+0x237>
ffffffff800005da:	48 89 c2             	mov    %rax,%rdx
ffffffff800005dd:	48 be 78 5e 37 0a 93 	movabs $0x9e1786930a375e78,%rsi
ffffffff800005e4:	86 17 9e 
ffffffff800005e7:	eb 05                	jmp    ffffffff800005ee <_start+0xee>
ffffffff800005e9:	48 39 32             	cmp    %rsi,(%rdx)
ffffffff800005ec:	74 35                	je     ffffffff80000623 <_start+0x123>
        current_tag = (void *)current_tag->next;
ffffffff800005ee:	48 8b 52 08          	mov    0x8(%rdx),%rdx
        if (current_tag == NULL) {
ffffffff800005f2:	48 85 d2             	test   %rdx,%rdx
ffffffff800005f5:	75 f2                	jne    ffffffff800005e9 <_start+0xe9>
        for( ;; ) 
            asm("hlt");
    }

    //ACPI RSDP
    boot_info.tag_rsdp = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_RSDP_ID);
ffffffff800005f7:	48 c7 05 06 a8 00 00 	movq   $0x0,0xa806(%rip)        # ffffffff8000ae08 <boot_info+0x28>
ffffffff800005fe:	00 00 00 00 
ffffffff80000602:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    if (boot_info.tag_rsdp == NULL)
    {
        for( ;; )
            asm("hlt");
ffffffff80000608:	f4                   	hlt    
ffffffff80000609:	eb fd                	jmp    ffffffff80000608 <_start+0x108>
    boot_info.tag_kernel_base_address = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_KERNEL_BASE_ADDRESS_ID);
ffffffff8000060b:	48 c7 05 ca a7 00 00 	movq   $0x0,0xa7ca(%rip)        # ffffffff8000ade0 <boot_info>
ffffffff80000612:	00 00 00 00 
ffffffff80000616:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000061d:	00 00 00 
            asm("hlt");
ffffffff80000620:	f4                   	hlt    
ffffffff80000621:	eb fd                	jmp    ffffffff80000620 <_start+0x120>
    boot_info.tag_rsdp = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_RSDP_ID);
ffffffff80000623:	48 89 15 de a7 00 00 	mov    %rdx,0xa7de(%rip)        # ffffffff8000ae08 <boot_info+0x28>
        if (current_tag->identifier == id) {
ffffffff8000062a:	48 ba 8f b5 8c b1 7d 	movabs $0xb0ed257db18cb58f,%rdx
ffffffff80000631:	25 ed b0 
ffffffff80000634:	48 39 d1             	cmp    %rdx,%rcx
ffffffff80000637:	0f 84 ee 00 00 00    	je     ffffffff8000072b <_start+0x22b>
ffffffff8000063d:	48 89 c2             	mov    %rax,%rdx
ffffffff80000640:	48 be 8f b5 8c b1 7d 	movabs $0xb0ed257db18cb58f,%rsi
ffffffff80000647:	25 ed b0 
        current_tag = (void *)current_tag->next;
ffffffff8000064a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
        if (current_tag == NULL) {
ffffffff8000064e:	48 85 d2             	test   %rdx,%rdx
ffffffff80000651:	74 64                	je     ffffffff800006b7 <_start+0x1b7>
        if (current_tag->identifier == id) {
ffffffff80000653:	48 39 32             	cmp    %rsi,(%rdx)
ffffffff80000656:	75 f2                	jne    ffffffff8000064a <_start+0x14a>
    }
    
    //Higher Half Direct Map
    boot_info.tag_hhdm = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_HHDM_ID);
ffffffff80000658:	48 89 15 b9 a7 00 00 	mov    %rdx,0xa7b9(%rip)        # ffffffff8000ae18 <boot_info+0x38>
        if (current_tag->identifier == id) {
ffffffff8000065f:	48 ba bd b6 47 40 a6 	movabs $0x5df266a64047b6bd,%rdx
ffffffff80000666:	66 f2 5d 
ffffffff80000669:	48 39 d1             	cmp    %rdx,%rcx
ffffffff8000066c:	0f 84 a1 00 00 00    	je     ffffffff80000713 <_start+0x213>
ffffffff80000672:	48 89 c2             	mov    %rax,%rdx
ffffffff80000675:	48 be bd b6 47 40 a6 	movabs $0x5df266a64047b6bd,%rsi
ffffffff8000067c:	66 f2 5d 
ffffffff8000067f:	eb 0c                	jmp    ffffffff8000068d <_start+0x18d>
ffffffff80000681:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff80000688:	48 39 32             	cmp    %rsi,(%rdx)
ffffffff8000068b:	74 3e                	je     ffffffff800006cb <_start+0x1cb>
        current_tag = (void *)current_tag->next;
ffffffff8000068d:	48 8b 52 08          	mov    0x8(%rdx),%rdx
        if (current_tag == NULL) {
ffffffff80000691:	48 85 d2             	test   %rdx,%rdx
ffffffff80000694:	75 f2                	jne    ffffffff80000688 <_start+0x188>
        for( ;; )
            asm("hlt");
    }

    //Protected Memory Ranges
    boot_info.tag_pmrs = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_PMRS_ID);
ffffffff80000696:	48 c7 05 7f a7 00 00 	movq   $0x0,0xa77f(%rip)        # ffffffff8000ae20 <boot_info+0x40>
ffffffff8000069d:	00 00 00 00 
ffffffff800006a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if (boot_info.tag_pmrs == NULL)
    {
        for( ;; )
            asm("hlt");
ffffffff800006a8:	f4                   	hlt    
ffffffff800006a9:	eb fd                	jmp    ffffffff800006a8 <_start+0x1a8>
    boot_info.tag_framebuffer = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_FRAMEBUFFER_ID);
ffffffff800006ab:	48 89 05 46 a7 00 00 	mov    %rax,0xa746(%rip)        # ffffffff8000adf8 <boot_info+0x18>
ffffffff800006b2:	e9 a6 fe ff ff       	jmpq   ffffffff8000055d <_start+0x5d>
    boot_info.tag_hhdm = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_HHDM_ID);
ffffffff800006b7:	48 c7 05 56 a7 00 00 	movq   $0x0,0xa756(%rip)        # ffffffff8000ae18 <boot_info+0x38>
ffffffff800006be:	00 00 00 00 
ffffffff800006c2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            asm("hlt");
ffffffff800006c8:	f4                   	hlt    
ffffffff800006c9:	eb fd                	jmp    ffffffff800006c8 <_start+0x1c8>
    boot_info.tag_pmrs = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_PMRS_ID);
ffffffff800006cb:	48 89 15 4e a7 00 00 	mov    %rdx,0xa74e(%rip)        # ffffffff8000ae20 <boot_info+0x40>
        if (current_tag->identifier == id) {
ffffffff800006d2:	48 ba ce 04 de aa 66 	movabs $0x4b6fe466aade04ce,%rdx
ffffffff800006d9:	e4 6f 4b 
ffffffff800006dc:	48 39 d1             	cmp    %rdx,%rcx
ffffffff800006df:	74 3b                	je     ffffffff8000071c <_start+0x21c>
ffffffff800006e1:	48 ba ce 04 de aa 66 	movabs $0x4b6fe466aade04ce,%rdx
ffffffff800006e8:	e4 6f 4b 
ffffffff800006eb:	eb 08                	jmp    ffffffff800006f5 <_start+0x1f5>
ffffffff800006ed:	0f 1f 00             	nopl   (%rax)
ffffffff800006f0:	48 39 10             	cmp    %rdx,(%rax)
ffffffff800006f3:	74 27                	je     ffffffff8000071c <_start+0x21c>
        current_tag = (void *)current_tag->next;
ffffffff800006f5:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (current_tag == NULL) {
ffffffff800006f9:	48 85 c0             	test   %rax,%rax
ffffffff800006fc:	75 f2                	jne    ffffffff800006f0 <_start+0x1f0>
    }


    //Kernel Modules
    boot_info.tag_modules = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MODULES_ID);
ffffffff800006fe:	48 c7 05 f7 a6 00 00 	movq   $0x0,0xa6f7(%rip)        # ffffffff8000ae00 <boot_info+0x20>
ffffffff80000705:	00 00 00 00 
ffffffff80000709:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if (boot_info.tag_modules == NULL)
    {
        for( ;; )
            asm("hlt");
ffffffff80000710:	f4                   	hlt    
ffffffff80000711:	eb fd                	jmp    ffffffff80000710 <_start+0x210>
    boot_info.tag_pmrs = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_PMRS_ID);
ffffffff80000713:	48 89 05 06 a7 00 00 	mov    %rax,0xa706(%rip)        # ffffffff8000ae20 <boot_info+0x40>
ffffffff8000071a:	eb c5                	jmp    ffffffff800006e1 <_start+0x1e1>
{
ffffffff8000071c:	52                   	push   %rdx
    boot_info.tag_modules = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MODULES_ID);
ffffffff8000071d:	48 89 05 dc a6 00 00 	mov    %rax,0xa6dc(%rip)        # ffffffff8000ae00 <boot_info+0x20>
    }

    kernel();
ffffffff80000724:	31 c0                	xor    %eax,%eax
ffffffff80000726:	e8 65 34 00 00       	callq  ffffffff80003b90 <kernel>
    boot_info.tag_hhdm = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_HHDM_ID);
ffffffff8000072b:	48 89 05 e6 a6 00 00 	mov    %rax,0xa6e6(%rip)        # ffffffff8000ae18 <boot_info+0x38>
ffffffff80000732:	e9 3b ff ff ff       	jmpq   ffffffff80000672 <_start+0x172>
    boot_info.tag_rsdp = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_RSDP_ID);
ffffffff80000737:	48 89 05 ca a6 00 00 	mov    %rax,0xa6ca(%rip)        # ffffffff8000ae08 <boot_info+0x28>
ffffffff8000073e:	e9 fa fe ff ff       	jmpq   ffffffff8000063d <_start+0x13d>
    boot_info.tag_kernel_base_address = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_KERNEL_BASE_ADDRESS_ID);
ffffffff80000743:	48 89 05 96 a6 00 00 	mov    %rax,0xa696(%rip)        # ffffffff8000ade0 <boot_info>
ffffffff8000074a:	e9 8b fe ff ff       	jmpq   ffffffff800005da <_start+0xda>
    boot_info.tag_memmap = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MEMMAP_ID);
ffffffff8000074f:	48 89 05 9a a6 00 00 	mov    %rax,0xa69a(%rip)        # ffffffff8000adf0 <boot_info+0x10>
ffffffff80000756:	e9 4a fe ff ff       	jmpq   ffffffff800005a5 <_start+0xa5>
ffffffff8000075b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80000760 <vmm_create_page_table>:
struct PageTable* kernel_cr3 = {0};

uint64_t magic = 0xdeadbeef;

struct PageTable* vmm_create_page_table()
{
ffffffff80000760:	48 83 ec 08          	sub    $0x8,%rsp
    void* page = pmm_allocpage();   //get a page
ffffffff80000764:	31 c0                	xor    %eax,%eax
ffffffff80000766:	e8 95 11 00 00       	callq  ffffffff80001900 <pmm_allocpage>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff8000076b:	48 85 c0             	test   %rax,%rax
ffffffff8000076e:	74 2f                	je     ffffffff8000079f <vmm_create_page_table+0x3f>
ffffffff80000770:	48 8d 88 00 10 00 00 	lea    0x1000(%rax),%rcx
ffffffff80000777:	48 89 c2             	mov    %rax,%rdx
ffffffff8000077a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
static inline void* memset(void* s, uint64_t c, uint64_t len)
{
    unsigned char* p=(uint8_t*)s;
    while(len--)
    {
        *p++ = (unsigned char)c;
ffffffff80000780:	48 83 c2 01          	add    $0x1,%rdx
ffffffff80000784:	c6 42 ff 00          	movb   $0x0,-0x1(%rdx)
    while(len--)
ffffffff80000788:	48 39 ca             	cmp    %rcx,%rdx
ffffffff8000078b:	75 f3                	jne    ffffffff80000780 <vmm_create_page_table+0x20>
    return addr - 0xFFFF800000000000;
}

static inline uint64_t phys_to_hh_data(uint64_t addr)
{
    return 0xFFFF800000000000 + addr;
ffffffff8000078d:	48 ba 00 00 00 00 00 	movabs $0xffff800000000000,%rdx
ffffffff80000794:	80 ff ff 
ffffffff80000797:	48 01 d0             	add    %rdx,%rax

    memset((uint8_t*)page, 0, 4096);    //clear the page
    return (struct PageTable*)phys_to_hh_data((uint64_t)page);
    
    //return (struct PageTable*)phys_to_hh_data((uint64_t)page);
}
ffffffff8000079a:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8000079e:	c3                   	retq   
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff8000079f:	31 c0                	xor    %eax,%eax
ffffffff800007a1:	eb f7                	jmp    ffffffff8000079a <vmm_create_page_table+0x3a>
ffffffff800007a3:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800007aa:	00 00 00 00 
ffffffff800007ae:	66 90                	xchg   %ax,%ax

ffffffff800007b0 <vmm_map_2Mpage>:
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
    }
}

void vmm_map_2Mpage(struct PageTable* pagetable, uint64_t virtual, uint64_t physical, uint64_t flags)
{
ffffffff800007b0:	41 57                	push   %r15
    uint64_t index2, index3, index4;
    vaddr >>= 12;
    //index1 = vaddr & 0x1ff;
    vaddr >>= 9;
    index2 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff800007b2:	49 89 f7             	mov    %rsi,%r15
{
ffffffff800007b5:	41 56                	push   %r14
ffffffff800007b7:	41 55                	push   %r13
ffffffff800007b9:	41 54                	push   %r12
    vaddr >>= 9;
ffffffff800007bb:	49 89 f4             	mov    %rsi,%r12
    index3 = vaddr & 0x1ff;
    vaddr >>= 9;
    index4 = vaddr & 0x1ff;
ffffffff800007be:	48 c1 ee 24          	shr    $0x24,%rsi
{
ffffffff800007c2:	55                   	push   %rbp
ffffffff800007c3:	53                   	push   %rbx
ffffffff800007c4:	81 e6 f8 0f 00 00    	and    $0xff8,%esi
    vaddr >>= 9;
ffffffff800007ca:	49 c1 ec 15          	shr    $0x15,%r12
    vaddr >>= 9;
ffffffff800007ce:	49 c1 ef 1e          	shr    $0x1e,%r15
ffffffff800007d2:	4c 8d 34 37          	lea    (%rdi,%rsi,1),%r14
{
ffffffff800007d6:	48 83 ec 08          	sub    $0x8,%rsp
    index2 = vaddr & 0x1ff;
ffffffff800007da:	41 81 e4 ff 01 00 00 	and    $0x1ff,%r12d
    index3 = vaddr & 0x1ff;
ffffffff800007e1:	41 81 e7 ff 01 00 00 	and    $0x1ff,%r15d
{
ffffffff800007e8:	48 89 d5             	mov    %rdx,%rbp
ffffffff800007eb:	49 89 cd             	mov    %rcx,%r13
    if(pagemap->entry[index] & 1)
ffffffff800007ee:	49 8b 06             	mov    (%r14),%rax
ffffffff800007f1:	a8 01                	test   $0x1,%al
ffffffff800007f3:	74 5b                	je     ffffffff80000850 <vmm_map_2Mpage+0xa0>
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff800007f5:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
ffffffff800007fb:	4e 8d 34 f8          	lea    (%rax,%r15,8),%r14
    if(pagemap->entry[index] & 1)
ffffffff800007ff:	49 8b 06             	mov    (%r14),%rax
ffffffff80000802:	a8 01                	test   $0x1,%al
ffffffff80000804:	74 2a                	je     ffffffff80000830 <vmm_map_2Mpage+0x80>

    PML4 = pagetable;
    PML3 = vmm_get_pagemap(PML4, index4, flags);
    PML2 = vmm_get_pagemap(PML3, index3, flags);

    PML2->entry[index2] = physical | flags | PTE_PAGESIZE;
ffffffff80000806:	40 80 cd 80          	or     $0x80,%bpl
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff8000080a:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
    PML2->entry[index2] = physical | flags | PTE_PAGESIZE;
ffffffff80000810:	49 09 ed             	or     %rbp,%r13
ffffffff80000813:	4e 89 2c e0          	mov    %r13,(%rax,%r12,8)
}
ffffffff80000817:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8000081b:	5b                   	pop    %rbx
ffffffff8000081c:	5d                   	pop    %rbp
ffffffff8000081d:	41 5c                	pop    %r12
ffffffff8000081f:	41 5d                	pop    %r13
ffffffff80000821:	41 5e                	pop    %r14
ffffffff80000823:	41 5f                	pop    %r15
ffffffff80000825:	c3                   	retq   
ffffffff80000826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000082d:	00 00 00 
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff80000830:	31 c0                	xor    %eax,%eax
ffffffff80000832:	e8 29 ff ff ff       	callq  ffffffff80000760 <vmm_create_page_table>
        if(!newentry) printf("Null page allocated!\n");
ffffffff80000837:	48 85 c0             	test   %rax,%rax
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff8000083a:	48 89 c3             	mov    %rax,%rbx
        if(!newentry) printf("Null page allocated!\n");
ffffffff8000083d:	74 31                	je     ffffffff80000870 <vmm_map_2Mpage+0xc0>
        pagemap->entry[index] = newentry | flags;
ffffffff8000083f:	48 89 d8             	mov    %rbx,%rax
ffffffff80000842:	4c 09 e8             	or     %r13,%rax
ffffffff80000845:	49 89 06             	mov    %rax,(%r14)
ffffffff80000848:	eb bc                	jmp    ffffffff80000806 <vmm_map_2Mpage+0x56>
ffffffff8000084a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff80000850:	31 c0                	xor    %eax,%eax
ffffffff80000852:	e8 09 ff ff ff       	callq  ffffffff80000760 <vmm_create_page_table>
        if(!newentry) printf("Null page allocated!\n");
ffffffff80000857:	48 85 c0             	test   %rax,%rax
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff8000085a:	48 89 c3             	mov    %rax,%rbx
        if(!newentry) printf("Null page allocated!\n");
ffffffff8000085d:	74 21                	je     ffffffff80000880 <vmm_map_2Mpage+0xd0>
        pagemap->entry[index] = newentry | flags;
ffffffff8000085f:	48 89 d8             	mov    %rbx,%rax
ffffffff80000862:	4c 09 e8             	or     %r13,%rax
ffffffff80000865:	49 89 06             	mov    %rax,(%r14)
ffffffff80000868:	eb 8b                	jmp    ffffffff800007f5 <vmm_map_2Mpage+0x45>
ffffffff8000086a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        if(!newentry) printf("Null page allocated!\n");
ffffffff80000870:	48 c7 c7 40 51 00 80 	mov    $0xffffffff80005140,%rdi
ffffffff80000877:	31 c0                	xor    %eax,%eax
ffffffff80000879:	e8 32 2f 00 00       	callq  ffffffff800037b0 <printf_>
ffffffff8000087e:	eb bf                	jmp    ffffffff8000083f <vmm_map_2Mpage+0x8f>
ffffffff80000880:	48 c7 c7 40 51 00 80 	mov    $0xffffffff80005140,%rdi
ffffffff80000887:	31 c0                	xor    %eax,%eax
ffffffff80000889:	e8 22 2f 00 00       	callq  ffffffff800037b0 <printf_>
ffffffff8000088e:	eb cf                	jmp    ffffffff8000085f <vmm_map_2Mpage+0xaf>

ffffffff80000890 <vmm_map_4Kpage>:

void vmm_map_4Kpage(struct PageTable* pagetable, uint64_t virtual, uint64_t physical, uint64_t flags)
{
ffffffff80000890:	41 57                	push   %r15
ffffffff80000892:	41 56                	push   %r14
    //Get the indices for the virtual page
    uint64_t vaddr = virtual;
    uint64_t index1, index2, index3, index4;
    vaddr >>= 12;
    index1 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80000894:	49 89 f6             	mov    %rsi,%r14
{
ffffffff80000897:	41 55                	push   %r13
ffffffff80000899:	41 54                	push   %r12
    vaddr >>= 9;
ffffffff8000089b:	49 c1 ee 15          	shr    $0x15,%r14
{
ffffffff8000089f:	55                   	push   %rbp
ffffffff800008a0:	48 89 d5             	mov    %rdx,%rbp
ffffffff800008a3:	53                   	push   %rbx
    index2 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff800008a4:	48 89 f2             	mov    %rsi,%rdx
    vaddr >>= 12;
ffffffff800008a7:	48 89 f3             	mov    %rsi,%rbx
    index3 = vaddr & 0x1ff;
    vaddr >>= 9;
    index4 = vaddr & 0x1ff;
ffffffff800008aa:	48 c1 ee 24          	shr    $0x24,%rsi
ffffffff800008ae:	81 e6 f8 0f 00 00    	and    $0xff8,%esi
{
ffffffff800008b4:	48 83 ec 18          	sub    $0x18,%rsp
    vaddr >>= 12;
ffffffff800008b8:	48 c1 eb 0c          	shr    $0xc,%rbx
ffffffff800008bc:	4c 8d 3c 37          	lea    (%rdi,%rsi,1),%r15
    vaddr >>= 9;
ffffffff800008c0:	48 c1 ea 1e          	shr    $0x1e,%rdx
    index1 = vaddr & 0x1ff;
ffffffff800008c4:	81 e3 ff 01 00 00    	and    $0x1ff,%ebx
    index2 = vaddr & 0x1ff;
ffffffff800008ca:	41 81 e6 ff 01 00 00 	and    $0x1ff,%r14d
    index3 = vaddr & 0x1ff;
ffffffff800008d1:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
{
ffffffff800008d7:	49 89 cd             	mov    %rcx,%r13
    if(pagemap->entry[index] & 1)
ffffffff800008da:	49 8b 07             	mov    (%r15),%rax
ffffffff800008dd:	a8 01                	test   $0x1,%al
ffffffff800008df:	74 7f                	je     ffffffff80000960 <vmm_map_4Kpage+0xd0>
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff800008e1:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
ffffffff800008e7:	4c 8d 3c d0          	lea    (%rax,%rdx,8),%r15
    if(pagemap->entry[index] & 1)
ffffffff800008eb:	49 8b 07             	mov    (%r15),%rax
ffffffff800008ee:	a8 01                	test   $0x1,%al
ffffffff800008f0:	74 4e                	je     ffffffff80000940 <vmm_map_4Kpage+0xb0>
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff800008f2:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
ffffffff800008f8:	4e 8d 34 f0          	lea    (%rax,%r14,8),%r14
    if(pagemap->entry[index] & 1)
ffffffff800008fc:	49 8b 06             	mov    (%r14),%rax
ffffffff800008ff:	a8 01                	test   $0x1,%al
ffffffff80000901:	74 1d                	je     ffffffff80000920 <vmm_map_4Kpage+0x90>
    PML4 = pagetable;
    PML3 = vmm_get_pagemap(PML4, index4, flags);
    PML2 = vmm_get_pagemap(PML3, index3, flags);
    PML1 = vmm_get_pagemap(PML2, index2, flags);

    PML1->entry[index1] = physical | flags;
ffffffff80000903:	4c 09 ed             	or     %r13,%rbp
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff80000906:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
    PML1->entry[index1] = physical | flags;
ffffffff8000090c:	48 89 2c d8          	mov    %rbp,(%rax,%rbx,8)
    //serial_printf(SERIAL_PORT1, "%p, %p, %p, %p\n", PML4->entry[index4], PML3->entry[index3], PML2->entry[index2], PML1->entry[index1]);
    //serial_printf(SERIAL_PORT1, "%p, %d, %d, %d, %d, %p\n", virtual, index4, index3, index2, index1, physical);

    //vmm_flush_tlb((void*)virtual);

}
ffffffff80000910:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80000914:	5b                   	pop    %rbx
ffffffff80000915:	5d                   	pop    %rbp
ffffffff80000916:	41 5c                	pop    %r12
ffffffff80000918:	41 5d                	pop    %r13
ffffffff8000091a:	41 5e                	pop    %r14
ffffffff8000091c:	41 5f                	pop    %r15
ffffffff8000091e:	c3                   	retq   
ffffffff8000091f:	90                   	nop
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff80000920:	31 c0                	xor    %eax,%eax
ffffffff80000922:	e8 39 fe ff ff       	callq  ffffffff80000760 <vmm_create_page_table>
        if(!newentry) printf("Null page allocated!\n");
ffffffff80000927:	48 85 c0             	test   %rax,%rax
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff8000092a:	49 89 c4             	mov    %rax,%r12
        if(!newentry) printf("Null page allocated!\n");
ffffffff8000092d:	74 61                	je     ffffffff80000990 <vmm_map_4Kpage+0x100>
        pagemap->entry[index] = newentry | flags;
ffffffff8000092f:	4c 89 e0             	mov    %r12,%rax
ffffffff80000932:	4c 09 e8             	or     %r13,%rax
ffffffff80000935:	49 89 06             	mov    %rax,(%r14)
ffffffff80000938:	eb c9                	jmp    ffffffff80000903 <vmm_map_4Kpage+0x73>
ffffffff8000093a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff80000940:	31 c0                	xor    %eax,%eax
ffffffff80000942:	e8 19 fe ff ff       	callq  ffffffff80000760 <vmm_create_page_table>
        if(!newentry) printf("Null page allocated!\n");
ffffffff80000947:	48 85 c0             	test   %rax,%rax
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff8000094a:	49 89 c4             	mov    %rax,%r12
        if(!newentry) printf("Null page allocated!\n");
ffffffff8000094d:	74 69                	je     ffffffff800009b8 <vmm_map_4Kpage+0x128>
        pagemap->entry[index] = newentry | flags;
ffffffff8000094f:	4c 89 e0             	mov    %r12,%rax
ffffffff80000952:	4c 09 e8             	or     %r13,%rax
ffffffff80000955:	49 89 07             	mov    %rax,(%r15)
ffffffff80000958:	eb 98                	jmp    ffffffff800008f2 <vmm_map_4Kpage+0x62>
ffffffff8000095a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff80000960:	31 c0                	xor    %eax,%eax
ffffffff80000962:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
ffffffff80000967:	e8 f4 fd ff ff       	callq  ffffffff80000760 <vmm_create_page_table>
        if(!newentry) printf("Null page allocated!\n");
ffffffff8000096c:	48 85 c0             	test   %rax,%rax
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff8000096f:	49 89 c4             	mov    %rax,%r12
        if(!newentry) printf("Null page allocated!\n");
ffffffff80000972:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff80000977:	74 27                	je     ffffffff800009a0 <vmm_map_4Kpage+0x110>
        pagemap->entry[index] = newentry | flags;
ffffffff80000979:	4c 89 e0             	mov    %r12,%rax
ffffffff8000097c:	4c 09 e8             	or     %r13,%rax
ffffffff8000097f:	49 89 07             	mov    %rax,(%r15)
ffffffff80000982:	e9 5a ff ff ff       	jmpq   ffffffff800008e1 <vmm_map_4Kpage+0x51>
ffffffff80000987:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000098e:	00 00 
        if(!newentry) printf("Null page allocated!\n");
ffffffff80000990:	48 c7 c7 40 51 00 80 	mov    $0xffffffff80005140,%rdi
ffffffff80000997:	31 c0                	xor    %eax,%eax
ffffffff80000999:	e8 12 2e 00 00       	callq  ffffffff800037b0 <printf_>
ffffffff8000099e:	eb 8f                	jmp    ffffffff8000092f <vmm_map_4Kpage+0x9f>
ffffffff800009a0:	48 c7 c7 40 51 00 80 	mov    $0xffffffff80005140,%rdi
ffffffff800009a7:	31 c0                	xor    %eax,%eax
ffffffff800009a9:	e8 02 2e 00 00       	callq  ffffffff800037b0 <printf_>
ffffffff800009ae:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff800009b3:	eb c4                	jmp    ffffffff80000979 <vmm_map_4Kpage+0xe9>
ffffffff800009b5:	0f 1f 00             	nopl   (%rax)
ffffffff800009b8:	48 c7 c7 40 51 00 80 	mov    $0xffffffff80005140,%rdi
ffffffff800009bf:	31 c0                	xor    %eax,%eax
ffffffff800009c1:	e8 ea 2d 00 00       	callq  ffffffff800037b0 <printf_>
ffffffff800009c6:	eb 87                	jmp    ffffffff8000094f <vmm_map_4Kpage+0xbf>
ffffffff800009c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff800009cf:	00 

ffffffff800009d0 <vmm_unmap_page>:
    virtual >>= 9;
    index3 = virtual & 0x1ff;
    virtual >>= 9;
    index4 = virtual & 0x1ff;

    if(PML4->entry[index4] & 1)
ffffffff800009d0:	48 b8 00 00 00 00 00 	movabs $0xffff800000000000,%rax
ffffffff800009d7:	80 ff ff 
ffffffff800009da:	48 01 c7             	add    %rax,%rdi
    virtual >>= 9;
ffffffff800009dd:	48 89 f0             	mov    %rsi,%rax
ffffffff800009e0:	48 c1 e8 27          	shr    $0x27,%rax
    index4 = virtual & 0x1ff;
ffffffff800009e4:	25 ff 01 00 00       	and    $0x1ff,%eax
    if(PML4->entry[index4] & 1)
ffffffff800009e9:	48 8b 04 c7          	mov    (%rdi,%rax,8),%rax
ffffffff800009ed:	a8 01                	test   $0x1,%al
ffffffff800009ef:	74 55                	je     ffffffff80000a46 <vmm_unmap_page+0x76>
    virtual >>= 9;
ffffffff800009f1:	48 89 f2             	mov    %rsi,%rdx
    {
        PML3 = (struct PageTable*)((PML4->entry[index4] >> 12) * 4096);
        if(PML3->entry[index3] & 1)
ffffffff800009f4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
    virtual >>= 9;
ffffffff800009fa:	48 c1 ea 1e          	shr    $0x1e,%rdx
    index3 = virtual & 0x1ff;
ffffffff800009fe:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
        if(PML3->entry[index3] & 1)
ffffffff80000a04:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
ffffffff80000a08:	a8 01                	test   $0x1,%al
ffffffff80000a0a:	74 3a                	je     ffffffff80000a46 <vmm_unmap_page+0x76>
    virtual >>= 9;
ffffffff80000a0c:	48 89 f2             	mov    %rsi,%rdx
        {
            PML2 = (struct PageTable*)((PML3->entry[index3] >> 12) * 4096);
            if(PML2->entry[index2] & 1)
ffffffff80000a0f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
    virtual >>= 9;
ffffffff80000a15:	48 c1 ea 15          	shr    $0x15,%rdx
    index2 = virtual & 0x1ff;
ffffffff80000a19:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
            if(PML2->entry[index2] & 1)
ffffffff80000a1f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
ffffffff80000a23:	a8 01                	test   $0x1,%al
ffffffff80000a25:	74 1f                	je     ffffffff80000a46 <vmm_unmap_page+0x76>
    index1 = virtual & 0x1ff;
ffffffff80000a27:	48 c1 ee 09          	shr    $0x9,%rsi
            {
                PML1 = (struct PageTable*)((PML2->entry[index2] >> 12) * 4096);
ffffffff80000a2b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff80000a31:	81 e6 f8 0f 00 00    	and    $0xff8,%esi
ffffffff80000a37:	48 01 c6             	add    %rax,%rsi
                if(PML1->entry[index1] & 1)
ffffffff80000a3a:	f6 06 01             	testb  $0x1,(%rsi)
ffffffff80000a3d:	74 07                	je     ffffffff80000a46 <vmm_unmap_page+0x76>
                {
                    PML1->entry[index1] = 0x00;
ffffffff80000a3f:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
                }
            }
        }
    }
}
ffffffff80000a46:	f3 c3                	repz retq 
ffffffff80000a48:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80000a4f:	00 

ffffffff80000a50 <vmm_pagewalk>:
uint64_t vmm_pagewalk(uint64_t vaddr, uint64_t* cr3)
{
    uint64_t* PML4 = (uint64_t*)(phys_to_hh_data((uint64_t)cr3));
    
    uint64_t index1, index2, index3, index4;
    vaddr >>= 12;
ffffffff80000a50:	49 89 f8             	mov    %rdi,%r8
    index1 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80000a53:	48 89 f9             	mov    %rdi,%rcx
    index2 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80000a56:	48 89 fa             	mov    %rdi,%rdx
    index3 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80000a59:	48 c1 ef 27          	shr    $0x27,%rdi
    index4 = vaddr & 0x1ff;
   
    uint64_t* PDPTE = (uint64_t*)((phys_to_hh_data(PML4[index4]) >> 12) * 4096);
ffffffff80000a5d:	48 b8 00 00 00 00 00 	movabs $0xffff800000000000,%rax
ffffffff80000a64:	80 ff ff 
{
ffffffff80000a67:	53                   	push   %rbx
    index4 = vaddr & 0x1ff;
ffffffff80000a68:	81 e7 ff 01 00 00    	and    $0x1ff,%edi
    vaddr >>= 9;
ffffffff80000a6e:	48 c1 ea 1e          	shr    $0x1e,%rdx
    vaddr >>= 9;
ffffffff80000a72:	48 c1 e9 15          	shr    $0x15,%rcx
    uint64_t* PDPTE = (uint64_t*)((phys_to_hh_data(PML4[index4]) >> 12) * 4096);
ffffffff80000a76:	48 8d 34 fe          	lea    (%rsi,%rdi,8),%rsi
    index3 = vaddr & 0x1ff;
ffffffff80000a7a:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    index2 = vaddr & 0x1ff;
ffffffff80000a80:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
    vaddr >>= 12;
ffffffff80000a86:	49 c1 e8 0c          	shr    $0xc,%r8
ffffffff80000a8a:	48 8b 1c 06          	mov    (%rsi,%rax,1),%rbx
    index1 = vaddr & 0x1ff;
ffffffff80000a8e:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
ffffffff80000a95:	48 01 c3             	add    %rax,%rbx
ffffffff80000a98:	48 89 de             	mov    %rbx,%rsi
    uint64_t* PDE = (uint64_t*)((phys_to_hh_data(PDPTE[index3]) >> 12) * 4096);
ffffffff80000a9b:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
ffffffff80000aa2:	48 8b 1c d6          	mov    (%rsi,%rdx,8),%rbx
ffffffff80000aa6:	48 01 c3             	add    %rax,%rbx
ffffffff80000aa9:	48 89 de             	mov    %rbx,%rsi
    uint64_t* PTE = (uint64_t*)((phys_to_hh_data(PDE[index2]) >> 12) * 4096);
ffffffff80000aac:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
ffffffff80000ab3:	48 8b 1c ce          	mov    (%rsi,%rcx,8),%rbx
ffffffff80000ab7:	48 01 c3             	add    %rax,%rbx
ffffffff80000aba:	48 89 de             	mov    %rbx,%rsi
    return addr - 0xFFFF800000000000;
ffffffff80000abd:	48 bb 00 00 00 00 00 	movabs $0x800000000000,%rbx
ffffffff80000ac4:	80 00 00 
    uint64_t* PD = (uint64_t*)((phys_to_hh_data(PTE[index1]) >> 12) * 4096);
ffffffff80000ac7:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
    return 0xFFFF800000000000 + addr;
ffffffff80000ace:	4a 03 04 c6          	add    (%rsi,%r8,8),%rax

    uint64_t pageaddr = hh_data_to_phys((uint64_t)PD);
    
    printf("%d  %d  %d  %d  %p\n", index4, index3, index2, index1, pageaddr);
ffffffff80000ad2:	48 89 fe             	mov    %rdi,%rsi
ffffffff80000ad5:	48 c7 c7 56 51 00 80 	mov    $0xffffffff80005156,%rdi
    uint64_t* PD = (uint64_t*)((phys_to_hh_data(PTE[index1]) >> 12) * 4096);
ffffffff80000adc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
    return addr - 0xFFFF800000000000;
ffffffff80000ae2:	48 01 c3             	add    %rax,%rbx
    printf("%d  %d  %d  %d  %p\n", index4, index3, index2, index1, pageaddr);
ffffffff80000ae5:	31 c0                	xor    %eax,%eax
ffffffff80000ae7:	49 89 d9             	mov    %rbx,%r9
ffffffff80000aea:	e8 c1 2c 00 00       	callq  ffffffff800037b0 <printf_>
    
    
    pageaddr >>= 12;
    pageaddr *= 4096;
ffffffff80000aef:	48 89 d8             	mov    %rbx,%rax

    return pageaddr;
}
ffffffff80000af2:	5b                   	pop    %rbx
ffffffff80000af3:	c3                   	retq   
ffffffff80000af4:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000afb:	00 00 00 00 
ffffffff80000aff:	90                   	nop

ffffffff80000b00 <vmm_PMLwalk>:

void vmm_PMLwalk(struct PageTable* pagetable)
{
ffffffff80000b00:	41 57                	push   %r15
ffffffff80000b02:	41 56                	push   %r14
ffffffff80000b04:	48 89 fa             	mov    %rdi,%rdx
ffffffff80000b07:	41 55                	push   %r13
ffffffff80000b09:	41 54                	push   %r12
    struct PageTable* PML4 = pagetable;
    struct PageTable* PML3 = NULL;
    struct PageTable* PML2 = NULL;
    struct PageTable* PML1 = NULL;

    serial_printf(SERIAL_PORT1, "Begin Pagewalk\r\nPML 4 %p\r\n", (uint64_t)PML4);
ffffffff80000b0b:	48 c7 c6 6a 51 00 80 	mov    $0xffffffff8000516a,%rsi
{
ffffffff80000b12:	55                   	push   %rbp
ffffffff80000b13:	53                   	push   %rbx
    serial_printf(SERIAL_PORT1, "Begin Pagewalk\r\nPML 4 %p\r\n", (uint64_t)PML4);
ffffffff80000b14:	31 c0                	xor    %eax,%eax
                                PML1 = (struct PageTable*)(PML3->entry[k] & ~(0x1FF));
                                for(uint64_t l = 0; l < 512; l++)
                                {
                                    if(PML1->entry[l] & 0x01)
                                    {
                                        serial_printf(SERIAL_PORT1, "1,%p,%d,%p\r\n", PML1, l, PML1->entry[l]);
ffffffff80000b16:	48 c7 c3 ac 51 00 80 	mov    $0xffffffff800051ac,%rbx
{
ffffffff80000b1d:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff80000b21:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
    serial_printf(SERIAL_PORT1, "Begin Pagewalk\r\nPML 4 %p\r\n", (uint64_t)PML4);
ffffffff80000b26:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80000b2b:	e8 50 2e 00 00       	callq  ffffffff80003980 <serial_printf>
    for(uint64_t i = 0; i < 512; i++)
ffffffff80000b30:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
ffffffff80000b37:	00 00 
ffffffff80000b39:	eb 1c                	jmp    ffffffff80000b57 <vmm_PMLwalk+0x57>
ffffffff80000b3b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
ffffffff80000b40:	48 83 44 24 08 01    	addq   $0x1,0x8(%rsp)
ffffffff80000b46:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff80000b4b:	48 3d 00 02 00 00    	cmp    $0x200,%rax
ffffffff80000b51:	0f 84 17 01 00 00    	je     ffffffff80000c6e <vmm_PMLwalk+0x16e>
        if(pagetable->entry[i] & 0x01)
ffffffff80000b57:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
ffffffff80000b5c:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
ffffffff80000b61:	4c 8b 04 c8          	mov    (%rax,%rcx,8),%r8
ffffffff80000b65:	41 f6 c0 01          	test   $0x1,%r8b
ffffffff80000b69:	74 d5                	je     ffffffff80000b40 <vmm_PMLwalk+0x40>
                serial_printf(SERIAL_PORT1, "4,%p,%d,%p\r\n",pagetable, i, pagetable->entry[i]);
ffffffff80000b6b:	49 89 cf             	mov    %rcx,%r15
ffffffff80000b6e:	49 89 c6             	mov    %rax,%r14
ffffffff80000b71:	48 89 c2             	mov    %rax,%rdx
ffffffff80000b74:	48 c7 c6 85 51 00 80 	mov    $0xffffffff80005185,%rsi
ffffffff80000b7b:	31 c0                	xor    %eax,%eax
ffffffff80000b7d:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80000b82:	e8 f9 2d 00 00       	callq  ffffffff80003980 <serial_printf>
                PML3 = (struct PageTable*)(pagetable->entry[i] & ~(0x1FF));
ffffffff80000b87:	4b 8b 04 fe          	mov    (%r14,%r15,8),%rax
                for(uint64_t j = 0; j < 512; j++)
ffffffff80000b8b:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
ffffffff80000b92:	00 
                PML3 = (struct PageTable*)(pagetable->entry[i] & ~(0x1FF));
ffffffff80000b93:	49 89 c5             	mov    %rax,%r13
ffffffff80000b96:	49 81 e5 00 fe ff ff 	and    $0xfffffffffffffe00,%r13
ffffffff80000b9d:	eb 12                	jmp    ffffffff80000bb1 <vmm_PMLwalk+0xb1>
ffffffff80000b9f:	90                   	nop
                for(uint64_t j = 0; j < 512; j++)
ffffffff80000ba0:	48 83 04 24 01       	addq   $0x1,(%rsp)
ffffffff80000ba5:	48 8b 04 24          	mov    (%rsp),%rax
ffffffff80000ba9:	48 3d 00 02 00 00    	cmp    $0x200,%rax
ffffffff80000baf:	74 8f                	je     ffffffff80000b40 <vmm_PMLwalk+0x40>
                    if(PML3->entry[j] & 0x01)
ffffffff80000bb1:	48 8b 04 24          	mov    (%rsp),%rax
ffffffff80000bb5:	4d 8b 44 c5 00       	mov    0x0(%r13,%rax,8),%r8
ffffffff80000bba:	41 f6 c0 01          	test   $0x1,%r8b
ffffffff80000bbe:	74 e0                	je     ffffffff80000ba0 <vmm_PMLwalk+0xa0>
                        serial_printf(SERIAL_PORT1, "3,%p,%d,%p\r\n",PML3, j, PML3->entry[j]);
ffffffff80000bc0:	49 89 c6             	mov    %rax,%r14
ffffffff80000bc3:	48 89 c1             	mov    %rax,%rcx
ffffffff80000bc6:	4c 89 ea             	mov    %r13,%rdx
ffffffff80000bc9:	31 c0                	xor    %eax,%eax
ffffffff80000bcb:	48 c7 c6 92 51 00 80 	mov    $0xffffffff80005192,%rsi
ffffffff80000bd2:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80000bd7:	e8 a4 2d 00 00       	callq  ffffffff80003980 <serial_printf>
                        PML2 = (struct PageTable*)(PML3->entry[j] & ~(0x1FF));
ffffffff80000bdc:	4b 8b 44 f5 00       	mov    0x0(%r13,%r14,8),%rax
                        for(uint64_t k = 0; k < 512; k++)
ffffffff80000be1:	31 ed                	xor    %ebp,%ebp
                        PML2 = (struct PageTable*)(PML3->entry[j] & ~(0x1FF));
ffffffff80000be3:	49 89 c4             	mov    %rax,%r12
ffffffff80000be6:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
ffffffff80000beb:	49 81 e4 00 fe ff ff 	and    $0xfffffffffffffe00,%r12
ffffffff80000bf2:	eb 11                	jmp    ffffffff80000c05 <vmm_PMLwalk+0x105>
ffffffff80000bf4:	0f 1f 40 00          	nopl   0x0(%rax)
                        for(uint64_t k = 0; k < 512; k++)
ffffffff80000bf8:	48 83 c5 01          	add    $0x1,%rbp
ffffffff80000bfc:	48 81 fd 00 02 00 00 	cmp    $0x200,%rbp
ffffffff80000c03:	74 9b                	je     ffffffff80000ba0 <vmm_PMLwalk+0xa0>
                            if(PML2->entry[k] & 0x01)
ffffffff80000c05:	4d 8b 04 ec          	mov    (%r12,%rbp,8),%r8
ffffffff80000c09:	41 f6 c0 01          	test   $0x1,%r8b
ffffffff80000c0d:	74 e9                	je     ffffffff80000bf8 <vmm_PMLwalk+0xf8>
                                serial_printf(SERIAL_PORT1, "2,%p,%d,%p\r\n",PML2, k, PML2->entry[k]);
ffffffff80000c0f:	48 89 e9             	mov    %rbp,%rcx
ffffffff80000c12:	4c 89 e2             	mov    %r12,%rdx
ffffffff80000c15:	48 c7 c6 9f 51 00 80 	mov    $0xffffffff8000519f,%rsi
ffffffff80000c1c:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80000c21:	31 c0                	xor    %eax,%eax
                                for(uint64_t l = 0; l < 512; l++)
ffffffff80000c23:	45 31 ff             	xor    %r15d,%r15d
                                serial_printf(SERIAL_PORT1, "2,%p,%d,%p\r\n",PML2, k, PML2->entry[k]);
ffffffff80000c26:	e8 55 2d 00 00       	callq  ffffffff80003980 <serial_printf>
                                PML1 = (struct PageTable*)(PML3->entry[k] & ~(0x1FF));
ffffffff80000c2b:	4d 8b 74 ed 00       	mov    0x0(%r13,%rbp,8),%r14
ffffffff80000c30:	49 81 e6 00 fe ff ff 	and    $0xfffffffffffffe00,%r14
ffffffff80000c37:	eb 14                	jmp    ffffffff80000c4d <vmm_PMLwalk+0x14d>
ffffffff80000c39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                                for(uint64_t l = 0; l < 512; l++)
ffffffff80000c40:	49 83 c7 01          	add    $0x1,%r15
ffffffff80000c44:	49 81 ff 00 02 00 00 	cmp    $0x200,%r15
ffffffff80000c4b:	74 ab                	je     ffffffff80000bf8 <vmm_PMLwalk+0xf8>
                                    if(PML1->entry[l] & 0x01)
ffffffff80000c4d:	4f 8b 04 fe          	mov    (%r14,%r15,8),%r8
ffffffff80000c51:	41 f6 c0 01          	test   $0x1,%r8b
ffffffff80000c55:	74 e9                	je     ffffffff80000c40 <vmm_PMLwalk+0x140>
                                        serial_printf(SERIAL_PORT1, "1,%p,%d,%p\r\n", PML1, l, PML1->entry[l]);
ffffffff80000c57:	4c 89 f9             	mov    %r15,%rcx
ffffffff80000c5a:	4c 89 f2             	mov    %r14,%rdx
ffffffff80000c5d:	48 89 de             	mov    %rbx,%rsi
ffffffff80000c60:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80000c65:	31 c0                	xor    %eax,%eax
ffffffff80000c67:	e8 14 2d 00 00       	callq  ffffffff80003980 <serial_printf>
ffffffff80000c6c:	eb d2                	jmp    ffffffff80000c40 <vmm_PMLwalk+0x140>
                }//PML3
            }
    }//PML4

    serial_printf(SERIAL_PORT1, "End Pagewalk\r\n");
}
ffffffff80000c6e:	48 83 c4 28          	add    $0x28,%rsp
    serial_printf(SERIAL_PORT1, "End Pagewalk\r\n");
ffffffff80000c72:	48 c7 c6 b9 51 00 80 	mov    $0xffffffff800051b9,%rsi
ffffffff80000c79:	bf f8 03 00 00       	mov    $0x3f8,%edi
}
ffffffff80000c7e:	5b                   	pop    %rbx
ffffffff80000c7f:	5d                   	pop    %rbp
ffffffff80000c80:	41 5c                	pop    %r12
ffffffff80000c82:	41 5d                	pop    %r13
ffffffff80000c84:	41 5e                	pop    %r14
ffffffff80000c86:	41 5f                	pop    %r15
    serial_printf(SERIAL_PORT1, "End Pagewalk\r\n");
ffffffff80000c88:	31 c0                	xor    %eax,%eax
ffffffff80000c8a:	e9 f1 2c 00 00       	jmpq   ffffffff80003980 <serial_printf>
ffffffff80000c8f:	90                   	nop

ffffffff80000c90 <vmm_init>:

void vmm_init()
{
ffffffff80000c90:	41 57                	push   %r15
ffffffff80000c92:	41 56                	push   %r14
    kernel_cr3 = (struct PageTable*)vmm_read_cr3();
ffffffff80000c94:	31 c0                	xor    %eax,%eax
{
ffffffff80000c96:	41 55                	push   %r13
ffffffff80000c98:	41 54                	push   %r12
ffffffff80000c9a:	55                   	push   %rbp
ffffffff80000c9b:	53                   	push   %rbx
ffffffff80000c9c:	48 83 ec 28          	sub    $0x28,%rsp
    kernel_cr3 = (struct PageTable*)vmm_read_cr3();
ffffffff80000ca0:	e8 fb f3 ff ff       	callq  ffffffff800000a0 <vmm_read_cr3>
    printf("CR3: %p\n", (uint64_t)kernel_cr3);
ffffffff80000ca5:	48 c7 c7 c8 51 00 80 	mov    $0xffffffff800051c8,%rdi
ffffffff80000cac:	48 89 c6             	mov    %rax,%rsi
    kernel_cr3 = (struct PageTable*)vmm_read_cr3();
ffffffff80000caf:	48 89 05 ca fd 00 00 	mov    %rax,0xfdca(%rip)        # ffffffff80010a80 <kernel_cr3>
    printf("CR3: %p\n", (uint64_t)kernel_cr3);
ffffffff80000cb6:	31 c0                	xor    %eax,%eax
ffffffff80000cb8:	e8 f3 2a 00 00       	callq  ffffffff800037b0 <printf_>
    uint32_t efer = vmm_read_efer();
ffffffff80000cbd:	31 c0                	xor    %eax,%eax
ffffffff80000cbf:	e8 e8 f3 ff ff       	callq  ffffffff800000ac <vmm_read_efer>
    uint32_t NXE = efer & (1 << 11);
ffffffff80000cc4:	89 c2                	mov    %eax,%edx
    printf("EFER: %p  NXE: %d\n", efer, NXE);
ffffffff80000cc6:	89 c6                	mov    %eax,%esi
ffffffff80000cc8:	48 c7 c7 d1 51 00 80 	mov    $0xffffffff800051d1,%rdi
    uint32_t NXE = efer & (1 << 11);
ffffffff80000ccf:	81 e2 00 08 00 00    	and    $0x800,%edx
    printf("EFER: %p  NXE: %d\n", efer, NXE);
ffffffff80000cd5:	31 c0                	xor    %eax,%eax
ffffffff80000cd7:	e8 d4 2a 00 00       	callq  ffffffff800037b0 <printf_>
 
    //Create the Kernel PML4 table
    RootPageDirectory = vmm_create_page_table();
ffffffff80000cdc:	31 c0                	xor    %eax,%eax
ffffffff80000cde:	e8 7d fa ff ff       	callq  ffffffff80000760 <vmm_create_page_table>
ffffffff80000ce3:	48 89 05 9e fd 00 00 	mov    %rax,0xfd9e(%rip)        # ffffffff80010a88 <RootPageDirectory>

    //Figure out where the kernel is and how big it is from the boot_info struct
    uint64_t kernel_physical = boot_info.tag_kernel_base_address->physical_base_address;
ffffffff80000cea:	48 8b 05 ef a0 00 00 	mov    0xa0ef(%rip),%rax        # ffffffff8000ade0 <boot_info>
    uint64_t kernel_virtual = boot_info.tag_kernel_base_address->virtual_base_address;
    uint64_t kernel_offset = kernel_virtual - kernel_physical;
ffffffff80000cf1:	4c 8b 78 18          	mov    0x18(%rax),%r15
ffffffff80000cf5:	4c 2b 78 10          	sub    0x10(%rax),%r15
    PTE_READWRITE           Writable if set
    PTE_USER_SUPERVISOR     User accessable if set
    PTE_EXECUTE_DISABLE     Disables execute if set (if EFER:11 is set)
*/

    for(uint64_t i = 0; i < boot_info.tag_pmrs->entries; i++)
ffffffff80000cf9:	48 8b 05 20 a1 00 00 	mov    0xa120(%rip),%rax        # ffffffff8000ae20 <boot_info+0x40>
ffffffff80000d00:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
    uint64_t kernel_offset = kernel_virtual - kernel_physical;
ffffffff80000d05:	4c 89 7c 24 18       	mov    %r15,0x18(%rsp)
    for(uint64_t i = 0; i < boot_info.tag_pmrs->entries; i++)
ffffffff80000d0a:	0f 84 e8 00 00 00    	je     ffffffff80000df8 <vmm_init+0x168>
ffffffff80000d10:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
ffffffff80000d17:	00 00 
ffffffff80000d19:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    {
        uint64_t virt = boot_info.tag_pmrs->pmrs[i].base;
ffffffff80000d20:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
            flags |= PTE_READWRITE;
        }

        flags |= PTE_PRESENT;
        
        DEBUG_MSG("Base: %p  Length: %x  Flags: %x\n", boot_info.tag_pmrs->pmrs[i].base, boot_info.tag_pmrs->pmrs[i].length, boot_info.tag_pmrs->pmrs[i].permissions);
ffffffff80000d25:	48 c7 c6 28 52 00 80 	mov    $0xffffffff80005228,%rsi
        uint64_t virt = boot_info.tag_pmrs->pmrs[i].base;
ffffffff80000d2c:	48 8d 2c 7f          	lea    (%rdi,%rdi,2),%rbp
ffffffff80000d30:	48 c1 e5 03          	shl    $0x3,%rbp
ffffffff80000d34:	48 01 e8             	add    %rbp,%rax
ffffffff80000d37:	4c 8b 60 18          	mov    0x18(%rax),%r12
        uint64_t perms = boot_info.tag_pmrs->pmrs[i].permissions;
ffffffff80000d3b:	4c 8b 40 28          	mov    0x28(%rax),%r8
        DEBUG_MSG("Base: %p  Length: %x  Flags: %x\n", boot_info.tag_pmrs->pmrs[i].base, boot_info.tag_pmrs->pmrs[i].length, boot_info.tag_pmrs->pmrs[i].permissions);
ffffffff80000d3f:	48 8b 48 20          	mov    0x20(%rax),%rcx
        uint64_t phys = virt - kernel_offset;
ffffffff80000d43:	4c 89 e7             	mov    %r12,%rdi
ffffffff80000d46:	48 2b 7c 24 18       	sub    0x18(%rsp),%rdi
        if(perms & 0x02) //is read/write bit set?
ffffffff80000d4b:	4c 89 c2             	mov    %r8,%rdx
ffffffff80000d4e:	83 e2 02             	and    $0x2,%edx
ffffffff80000d51:	48 83 fa 01          	cmp    $0x1,%rdx
        DEBUG_MSG("Base: %p  Length: %x  Flags: %x\n", boot_info.tag_pmrs->pmrs[i].base, boot_info.tag_pmrs->pmrs[i].length, boot_info.tag_pmrs->pmrs[i].permissions);
ffffffff80000d55:	4c 89 e2             	mov    %r12,%rdx
        if(perms & 0x02) //is read/write bit set?
ffffffff80000d58:	48 19 db             	sbb    %rbx,%rbx
        DEBUG_MSG("Base: %p  Length: %x  Flags: %x\n", boot_info.tag_pmrs->pmrs[i].base, boot_info.tag_pmrs->pmrs[i].length, boot_info.tag_pmrs->pmrs[i].permissions);
ffffffff80000d5b:	31 c0                	xor    %eax,%eax
        uint64_t phys = virt - kernel_offset;
ffffffff80000d5d:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
        DEBUG_MSG("Base: %p  Length: %x  Flags: %x\n", boot_info.tag_pmrs->pmrs[i].base, boot_info.tag_pmrs->pmrs[i].length, boot_info.tag_pmrs->pmrs[i].permissions);
ffffffff80000d62:	bf f8 03 00 00       	mov    $0x3f8,%edi
        if(perms & 0x02) //is read/write bit set?
ffffffff80000d67:	48 83 e3 fe          	and    $0xfffffffffffffffe,%rbx
        DEBUG_MSG("Base: %p  Length: %x  Flags: %x\n", boot_info.tag_pmrs->pmrs[i].base, boot_info.tag_pmrs->pmrs[i].length, boot_info.tag_pmrs->pmrs[i].permissions);
ffffffff80000d6b:	e8 10 2c 00 00       	callq  ffffffff80003980 <serial_printf>
        for(uint64_t j = 0; j < boot_info.tag_pmrs->pmrs[i].length; j+=0x1000)
ffffffff80000d70:	48 8b 05 a9 a0 00 00 	mov    0xa0a9(%rip),%rax        # ffffffff8000ae20 <boot_info+0x40>
        if(perms & 0x02) //is read/write bit set?
ffffffff80000d77:	48 83 c3 03          	add    $0x3,%rbx
        for(uint64_t j = 0; j < boot_info.tag_pmrs->pmrs[i].length; j+=0x1000)
ffffffff80000d7b:	48 83 7c 28 20 00    	cmpq   $0x0,0x20(%rax,%rbp,1)
ffffffff80000d81:	74 60                	je     ffffffff80000de3 <vmm_init+0x153>
ffffffff80000d83:	45 31 ff             	xor    %r15d,%r15d
ffffffff80000d86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80000d8d:	00 00 00 
        {
            vmm_map_4Kpage(RootPageDirectory, virt + j, phys + j, flags);
ffffffff80000d90:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff80000d95:	4f 8d 34 3c          	lea    (%r12,%r15,1),%r14
ffffffff80000d99:	48 8b 3d e8 fc 00 00 	mov    0xfce8(%rip),%rdi        # ffffffff80010a88 <RootPageDirectory>
ffffffff80000da0:	48 89 d9             	mov    %rbx,%rcx
ffffffff80000da3:	4c 89 f6             	mov    %r14,%rsi
ffffffff80000da6:	4e 8d 2c 38          	lea    (%rax,%r15,1),%r13
        for(uint64_t j = 0; j < boot_info.tag_pmrs->pmrs[i].length; j+=0x1000)
ffffffff80000daa:	49 81 c7 00 10 00 00 	add    $0x1000,%r15
            vmm_map_4Kpage(RootPageDirectory, virt + j, phys + j, flags);
ffffffff80000db1:	4c 89 ea             	mov    %r13,%rdx
ffffffff80000db4:	e8 d7 fa ff ff       	callq  ffffffff80000890 <vmm_map_4Kpage>
            DEBUG_MSG("Kernel : %p %p %x\n", virt + j, phys + j, flags); 
ffffffff80000db9:	31 c0                	xor    %eax,%eax
ffffffff80000dbb:	49 89 d8             	mov    %rbx,%r8
ffffffff80000dbe:	4c 89 e9             	mov    %r13,%rcx
ffffffff80000dc1:	4c 89 f2             	mov    %r14,%rdx
ffffffff80000dc4:	48 c7 c6 e4 51 00 80 	mov    $0xffffffff800051e4,%rsi
ffffffff80000dcb:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80000dd0:	e8 ab 2b 00 00       	callq  ffffffff80003980 <serial_printf>
        for(uint64_t j = 0; j < boot_info.tag_pmrs->pmrs[i].length; j+=0x1000)
ffffffff80000dd5:	48 8b 05 44 a0 00 00 	mov    0xa044(%rip),%rax        # ffffffff8000ae20 <boot_info+0x40>
ffffffff80000ddc:	4c 39 7c 28 20       	cmp    %r15,0x20(%rax,%rbp,1)
ffffffff80000de1:	77 ad                	ja     ffffffff80000d90 <vmm_init+0x100>
    for(uint64_t i = 0; i < boot_info.tag_pmrs->entries; i++)
ffffffff80000de3:	48 83 44 24 10 01    	addq   $0x1,0x10(%rsp)
ffffffff80000de9:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
ffffffff80000dee:	48 39 48 10          	cmp    %rcx,0x10(%rax)
ffffffff80000df2:	0f 87 28 ff ff ff    	ja     ffffffff80000d20 <vmm_init+0x90>
    //{
    //    vmm_map_4Kpage(RootPageDirectory, kernel_virt + (0x1000 * i), kernel_phys + (0x1000 * i), PTE_PRESENT | PTE_READWRITE);
    //}

    //Map Physical Memory to 0xFFFF8...
    printf("HHDM: %p\n", boot_info.tag_hhdm->addr);
ffffffff80000df8:	48 8b 05 19 a0 00 00 	mov    0xa019(%rip),%rax        # ffffffff8000ae18 <boot_info+0x38>
ffffffff80000dff:	48 c7 c7 f7 51 00 80 	mov    $0xffffffff800051f7,%rdi
ffffffff80000e06:	48 8b 70 10          	mov    0x10(%rax),%rsi
ffffffff80000e0a:	31 c0                	xor    %eax,%eax
ffffffff80000e0c:	e8 9f 29 00 00       	callq  ffffffff800037b0 <printf_>
    for(uint64_t i = 0; i < pmm_info.totalmem ; i+=0x1000)
ffffffff80000e11:	48 8b 2d 48 a0 00 00 	mov    0xa048(%rip),%rbp        # ffffffff8000ae60 <pmm_info>
ffffffff80000e18:	48 85 ed             	test   %rbp,%rbp
ffffffff80000e1b:	74 31                	je     ffffffff80000e4e <vmm_init+0x1be>
ffffffff80000e1d:	31 db                	xor    %ebx,%ebx
ffffffff80000e1f:	90                   	nop
    {   
        vmm_map_4Kpage(RootPageDirectory, (boot_info.tag_hhdm->addr + i), i, PTE_PRESENT | PTE_READWRITE);
ffffffff80000e20:	48 8b 05 f1 9f 00 00 	mov    0x9ff1(%rip),%rax        # ffffffff8000ae18 <boot_info+0x38>
ffffffff80000e27:	48 8b 3d 5a fc 00 00 	mov    0xfc5a(%rip),%rdi        # ffffffff80010a88 <RootPageDirectory>
ffffffff80000e2e:	48 89 da             	mov    %rbx,%rdx
ffffffff80000e31:	b9 03 00 00 00       	mov    $0x3,%ecx
ffffffff80000e36:	48 8b 70 10          	mov    0x10(%rax),%rsi
ffffffff80000e3a:	48 01 de             	add    %rbx,%rsi
    for(uint64_t i = 0; i < pmm_info.totalmem ; i+=0x1000)
ffffffff80000e3d:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
        vmm_map_4Kpage(RootPageDirectory, (boot_info.tag_hhdm->addr + i), i, PTE_PRESENT | PTE_READWRITE);
ffffffff80000e44:	e8 47 fa ff ff       	callq  ffffffff80000890 <vmm_map_4Kpage>
    for(uint64_t i = 0; i < pmm_info.totalmem ; i+=0x1000)
ffffffff80000e49:	48 39 eb             	cmp    %rbp,%rbx
ffffffff80000e4c:	72 d2                	jb     ffffffff80000e20 <vmm_init+0x190>
    }

    DEBUG_MSG("New CR3: %p -- & %p \n", (uint64_t)RootPageDirectory, &RootPageDirectory);
ffffffff80000e4e:	48 8b 15 33 fc 00 00 	mov    0xfc33(%rip),%rdx        # ffffffff80010a88 <RootPageDirectory>
ffffffff80000e55:	48 c7 c1 88 0a 01 80 	mov    $0xffffffff80010a88,%rcx
ffffffff80000e5c:	48 c7 c6 01 52 00 80 	mov    $0xffffffff80005201,%rsi
ffffffff80000e63:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80000e68:	31 c0                	xor    %eax,%eax
ffffffff80000e6a:	e8 11 2b 00 00       	callq  ffffffff80003980 <serial_printf>
    printf("New CR3: %p -- & %p \n", (uint64_t)RootPageDirectory, &RootPageDirectory);
ffffffff80000e6f:	48 8b 35 12 fc 00 00 	mov    0xfc12(%rip),%rsi        # ffffffff80010a88 <RootPageDirectory>
ffffffff80000e76:	48 c7 c2 88 0a 01 80 	mov    $0xffffffff80010a88,%rdx
ffffffff80000e7d:	48 c7 c7 01 52 00 80 	mov    $0xffffffff80005201,%rdi
ffffffff80000e84:	31 c0                	xor    %eax,%eax
ffffffff80000e86:	e8 25 29 00 00       	callq  ffffffff800037b0 <printf_>
    //c=pmm_allocpage();
    //d=pmm_allocpage();

    //printf("%p, %p, %p, %p", a,b,c,d);

    vmm_PMLwalk(kernel_cr3);
ffffffff80000e8b:	48 8b 3d ee fb 00 00 	mov    0xfbee(%rip),%rdi        # ffffffff80010a80 <kernel_cr3>
ffffffff80000e92:	e8 69 fc ff ff       	callq  ffffffff80000b00 <vmm_PMLwalk>

    DEBUG_MSG("New PML4\n");
ffffffff80000e97:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80000e9c:	48 c7 c6 17 52 00 80 	mov    $0xffffffff80005217,%rsi
ffffffff80000ea3:	31 c0                	xor    %eax,%eax
ffffffff80000ea5:	e8 d6 2a 00 00       	callq  ffffffff80003980 <serial_printf>
    vmm_PMLwalk(RootPageDirectory);
ffffffff80000eaa:	48 8b 3d d7 fb 00 00 	mov    0xfbd7(%rip),%rdi        # ffffffff80010a88 <RootPageDirectory>

    //cycle through page entries


    
}
ffffffff80000eb1:	48 83 c4 28          	add    $0x28,%rsp
ffffffff80000eb5:	5b                   	pop    %rbx
ffffffff80000eb6:	5d                   	pop    %rbp
ffffffff80000eb7:	41 5c                	pop    %r12
ffffffff80000eb9:	41 5d                	pop    %r13
ffffffff80000ebb:	41 5e                	pop    %r14
ffffffff80000ebd:	41 5f                	pop    %r15
    vmm_PMLwalk(RootPageDirectory);
ffffffff80000ebf:	e9 3c fc ff ff       	jmpq   ffffffff80000b00 <vmm_PMLwalk>
ffffffff80000ec4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80000ecb:	00 00 00 
ffffffff80000ece:	66 90                	xchg   %ax,%ax

ffffffff80000ed0 <liballoc_lock>:



int liballoc_lock()
{
    asm("cli");
ffffffff80000ed0:	fa                   	cli    
    return 0;
}
ffffffff80000ed1:	31 c0                	xor    %eax,%eax
ffffffff80000ed3:	c3                   	retq   
ffffffff80000ed4:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000edb:	00 00 00 00 
ffffffff80000edf:	90                   	nop

ffffffff80000ee0 <liballoc_unlock>:


int liballoc_unlock()
{
    asm("sti");
ffffffff80000ee0:	fb                   	sti    
    return 0;
}
ffffffff80000ee1:	31 c0                	xor    %eax,%eax
ffffffff80000ee3:	c3                   	retq   
ffffffff80000ee4:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000eeb:	00 00 00 00 
ffffffff80000eef:	90                   	nop

ffffffff80000ef0 <liballoc_free>:

int liballoc_free(void* page, size_t count)
{
    return 0;
}
ffffffff80000ef0:	31 c0                	xor    %eax,%eax
ffffffff80000ef2:	c3                   	retq   
ffffffff80000ef3:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000efa:	00 00 00 00 
ffffffff80000efe:	66 90                	xchg   %ax,%ax

ffffffff80000f00 <liballoc_alloc>:

void* liballoc_alloc(size_t count)
{
    for(uint64_t i = 0; i < count; i++)
ffffffff80000f00:	48 85 ff             	test   %rdi,%rdi
ffffffff80000f03:	74 6b                	je     ffffffff80000f70 <liballoc_alloc+0x70>
{
ffffffff80000f05:	55                   	push   %rbp
ffffffff80000f06:	53                   	push   %rbx
ffffffff80000f07:	48 89 fd             	mov    %rdi,%rbp
    for(uint64_t i = 0; i < count; i++)
ffffffff80000f0a:	31 db                	xor    %ebx,%ebx
{
ffffffff80000f0c:	48 83 ec 08          	sub    $0x8,%rsp
    {
        vmm_map_4Kpage(RootPageDirectory, (kernel_heap_top + 4096), (uint64_t)pmm_allocpage(), PTE_PRESENT | PTE_READWRITE);
ffffffff80000f10:	31 c0                	xor    %eax,%eax
    for(uint64_t i = 0; i < count; i++)
ffffffff80000f12:	48 83 c3 01          	add    $0x1,%rbx
        vmm_map_4Kpage(RootPageDirectory, (kernel_heap_top + 4096), (uint64_t)pmm_allocpage(), PTE_PRESENT | PTE_READWRITE);
ffffffff80000f16:	e8 e5 09 00 00       	callq  ffffffff80001900 <pmm_allocpage>
ffffffff80000f1b:	48 8b 0d 26 69 00 00 	mov    0x6926(%rip),%rcx        # ffffffff80007848 <kernel_heap_top>
ffffffff80000f22:	48 8b 3d 5f fb 00 00 	mov    0xfb5f(%rip),%rdi        # ffffffff80010a88 <RootPageDirectory>
ffffffff80000f29:	48 89 c2             	mov    %rax,%rdx
ffffffff80000f2c:	48 8d b1 00 10 00 00 	lea    0x1000(%rcx),%rsi
ffffffff80000f33:	b9 03 00 00 00       	mov    $0x3,%ecx
ffffffff80000f38:	e8 53 f9 ff ff       	callq  ffffffff80000890 <vmm_map_4Kpage>
        kernel_heap_top += 4096;
ffffffff80000f3d:	48 8b 05 04 69 00 00 	mov    0x6904(%rip),%rax        # ffffffff80007848 <kernel_heap_top>
ffffffff80000f44:	48 05 00 10 00 00    	add    $0x1000,%rax
    for(uint64_t i = 0; i < count; i++)
ffffffff80000f4a:	48 39 dd             	cmp    %rbx,%rbp
        kernel_heap_top += 4096;
ffffffff80000f4d:	48 89 05 f4 68 00 00 	mov    %rax,0x68f4(%rip)        # ffffffff80007848 <kernel_heap_top>
    for(uint64_t i = 0; i < count; i++)
ffffffff80000f54:	75 ba                	jne    ffffffff80000f10 <liballoc_alloc+0x10>
    }
    return (void*)(phys_to_hh_data((uint64_t)kernel_heap_top));
ffffffff80000f56:	48 83 c4 08          	add    $0x8,%rsp
    return 0xFFFF800000000000 + addr;
ffffffff80000f5a:	48 ba 00 00 00 00 00 	movabs $0xffff800000000000,%rdx
ffffffff80000f61:	80 ff ff 
ffffffff80000f64:	48 01 d0             	add    %rdx,%rax
ffffffff80000f67:	5b                   	pop    %rbx
ffffffff80000f68:	5d                   	pop    %rbp
ffffffff80000f69:	c3                   	retq   
ffffffff80000f6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff80000f70:	48 8b 05 d1 68 00 00 	mov    0x68d1(%rip),%rax        # ffffffff80007848 <kernel_heap_top>
ffffffff80000f77:	48 ba 00 00 00 00 00 	movabs $0xffff800000000000,%rdx
ffffffff80000f7e:	80 ff ff 
ffffffff80000f81:	48 01 d0             	add    %rdx,%rax
ffffffff80000f84:	c3                   	retq   
ffffffff80000f85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80000f8c:	00 00 00 
ffffffff80000f8f:	90                   	nop

ffffffff80000f90 <allocate_new_page>:
	unsigned int st;
	struct liballoc_major *maj;

		// This is how much space is required.
		st  = size + sizeof(struct liballoc_major);
		st += sizeof(struct liballoc_minor);
ffffffff80000f90:	83 c7 50             	add    $0x50,%edi
{
ffffffff80000f93:	53                   	push   %rbx
ffffffff80000f94:	bb 10 00 00 00       	mov    $0x10,%ebx
ffffffff80000f99:	89 f8                	mov    %edi,%eax

				// Perfect amount of space?
		if ( (st % l_pageSize) == 0 )
ffffffff80000f9b:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
ffffffff80000fa1:	c1 e8 0c             	shr    $0xc,%eax
			st  = st / (l_pageSize);
		else
			st  = st / (l_pageSize) + 1;
ffffffff80000fa4:	83 ff 01             	cmp    $0x1,%edi
ffffffff80000fa7:	83 d8 ff             	sbb    $0xffffffff,%eax
ffffffff80000faa:	83 f8 10             	cmp    $0x10,%eax
ffffffff80000fad:	0f 43 d8             	cmovae %eax,%ebx

		
		// Make sure it's >= the minimum size.
		if ( st < l_pageCount ) st = l_pageCount;
		
		maj = (struct liballoc_major*)liballoc_alloc( st );
ffffffff80000fb0:	89 df                	mov    %ebx,%edi
ffffffff80000fb2:	e8 49 ff ff ff       	callq  ffffffff80000f00 <liballoc_alloc>

		if ( maj == NULL ) 
ffffffff80000fb7:	48 85 c0             	test   %rax,%rax
ffffffff80000fba:	74 34                	je     ffffffff80000ff0 <allocate_new_page+0x60>
			return NULL;	// uh oh, we ran out of memory.
		}
		
		maj->prev 	= NULL;
		maj->next 	= NULL;
		maj->pages 	= st;
ffffffff80000fbc:	89 58 10             	mov    %ebx,0x10(%rax)
		maj->size 	= st * l_pageSize;
ffffffff80000fbf:	c1 e3 0c             	shl    $0xc,%ebx
		maj->prev 	= NULL;
ffffffff80000fc2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		maj->next 	= NULL;
ffffffff80000fc9:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff80000fd0:	00 
		maj->size 	= st * l_pageSize;
ffffffff80000fd1:	89 58 14             	mov    %ebx,0x14(%rax)
		maj->usage 	= sizeof(struct liballoc_major);
ffffffff80000fd4:	c7 40 18 28 00 00 00 	movl   $0x28,0x18(%rax)
		maj->first 	= NULL;
ffffffff80000fdb:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff80000fe2:	00 

		l_allocated += maj->size;
ffffffff80000fe3:	48 01 1d c6 fa 00 00 	add    %rbx,0xfac6(%rip)        # ffffffff80010ab0 <l_allocated>
		FLUSH();
		#endif
	
		
      return maj;
}
ffffffff80000fea:	5b                   	pop    %rbx
ffffffff80000feb:	c3                   	retq   
ffffffff80000fec:	0f 1f 40 00          	nopl   0x0(%rax)
			l_warningCount += 1;
ffffffff80000ff0:	48 83 05 a8 fa 00 00 	addq   $0x1,0xfaa8(%rip)        # ffffffff80010aa0 <l_warningCount>
ffffffff80000ff7:	01 
}
ffffffff80000ff8:	5b                   	pop    %rbx
ffffffff80000ff9:	c3                   	retq   
ffffffff80000ffa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80001000 <kmalloc>:

	


void *PREFIX(malloc)(size_t req_size)
{
ffffffff80001000:	41 57                	push   %r15
ffffffff80001002:	41 56                	push   %r14
ffffffff80001004:	41 55                	push   %r13
ffffffff80001006:	41 54                	push   %r12
ffffffff80001008:	49 89 fd             	mov    %rdi,%r13
ffffffff8000100b:	55                   	push   %rbp
ffffffff8000100c:	53                   	push   %rbx
ffffffff8000100d:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80001011:	eb 1a                	jmp    ffffffff8000102d <kmalloc+0x2d>
ffffffff80001013:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		#if defined DEBUG || defined INFO
		printf( "liballoc: WARNING: alloc( 0 ) called from %x\n",
							__builtin_return_address(0) );
		FLUSH();
		#endif
		liballoc_unlock();
ffffffff80001018:	31 c0                	xor    %eax,%eax
		return PREFIX(malloc)(1);
ffffffff8000101a:	41 bd 01 00 00 00    	mov    $0x1,%r13d
		l_warningCount += 1;
ffffffff80001020:	48 83 05 78 fa 00 00 	addq   $0x1,0xfa78(%rip)        # ffffffff80010aa0 <l_warningCount>
ffffffff80001027:	01 
		liballoc_unlock();
ffffffff80001028:	e8 b3 fe ff ff       	callq  ffffffff80000ee0 <liballoc_unlock>
		size += ALIGNMENT + ALIGN_INFO;
ffffffff8000102d:	4d 8d 65 20          	lea    0x20(%r13),%r12
	liballoc_lock();
ffffffff80001031:	31 c0                	xor    %eax,%eax
ffffffff80001033:	e8 98 fe ff ff       	callq  ffffffff80000ed0 <liballoc_lock>
	if ( size == 0 )
ffffffff80001038:	4d 85 e4             	test   %r12,%r12
ffffffff8000103b:	74 db                	je     ffffffff80001018 <kmalloc+0x18>
	}
	

	if ( l_memRoot == NULL )
ffffffff8000103d:	48 8b 35 7c fa 00 00 	mov    0xfa7c(%rip),%rsi        # ffffffff80010ac0 <l_memRoot>
ffffffff80001044:	48 85 f6             	test   %rsi,%rsi
ffffffff80001047:	0f 84 c3 02 00 00    	je     ffffffff80001310 <kmalloc+0x310>

	maj = l_memRoot;
	startedBet = 0;
	
	// Start at the best bet....
	if ( l_bestBet != NULL )
ffffffff8000104d:	48 8b 15 64 fa 00 00 	mov    0xfa64(%rip),%rdx        # ffffffff80010ab8 <l_bestBet>
ffffffff80001054:	49 8d 5d 48          	lea    0x48(%r13),%rbx
ffffffff80001058:	48 85 d2             	test   %rdx,%rdx
ffffffff8000105b:	0f 84 3f 02 00 00    	je     ffffffff800012a0 <kmalloc+0x2a0>
	{
		bestSize = l_bestBet->size - l_bestBet->usage;
ffffffff80001061:	8b 42 14             	mov    0x14(%rdx),%eax
ffffffff80001064:	8b 4a 18             	mov    0x18(%rdx),%ecx

		if ( bestSize > (size + sizeof(struct liballoc_minor)))
		{
			maj = l_bestBet;
			startedBet = 1;
ffffffff80001067:	41 bf 01 00 00 00    	mov    $0x1,%r15d
		bestSize = l_bestBet->size - l_bestBet->usage;
ffffffff8000106d:	41 89 c6             	mov    %eax,%r14d
ffffffff80001070:	41 29 ce             	sub    %ecx,%r14d
		if ( bestSize > (size + sizeof(struct liballoc_minor)))
ffffffff80001073:	49 39 de             	cmp    %rbx,%r14
ffffffff80001076:	0f 86 b4 01 00 00    	jbe    ffffffff80001230 <kmalloc+0x230>
		}
	}
	
	while ( maj != NULL )
	{
		diff  = maj->size - maj->usage;	
ffffffff8000107c:	29 c8                	sub    %ecx,%eax
										// free memory in the block

		if ( bestSize < diff )
ffffffff8000107e:	4c 39 f0             	cmp    %r14,%rax
ffffffff80001081:	76 0a                	jbe    ffffffff8000108d <kmalloc+0x8d>
		{
			// Hmm.. this one has more memory then our bestBet. Remember!
			l_bestBet = maj;
ffffffff80001083:	48 89 15 2e fa 00 00 	mov    %rdx,0xfa2e(%rip)        # ffffffff80010ab8 <l_bestBet>
ffffffff8000108a:	49 89 c6             	mov    %rax,%r14
		
		
#ifdef USE_CASE1
			
		// CASE 1:  There is not enough space in this major block.
		if ( diff < (size + sizeof( struct liballoc_minor )) )
ffffffff8000108d:	48 39 d8             	cmp    %rbx,%rax
ffffffff80001090:	73 22                	jae    ffffffff800010b4 <kmalloc+0xb4>
			printf( "CASE 1: Insufficient space in block %x\n", maj);
			FLUSH();
			#endif
				
				// Another major block next to this one?
			if ( maj->next != NULL ) 
ffffffff80001092:	48 8b 42 08          	mov    0x8(%rdx),%rax
ffffffff80001096:	48 85 c0             	test   %rax,%rax
ffffffff80001099:	0f 84 b9 00 00 00    	je     ffffffff80001158 <kmalloc+0x158>
ffffffff8000109f:	48 89 c2             	mov    %rax,%rdx
ffffffff800010a2:	8b 42 14             	mov    0x14(%rdx),%eax
ffffffff800010a5:	8b 4a 18             	mov    0x18(%rdx),%ecx
		diff  = maj->size - maj->usage;	
ffffffff800010a8:	29 c8                	sub    %ecx,%eax
		if ( bestSize < diff )
ffffffff800010aa:	4c 39 f0             	cmp    %r14,%rax
ffffffff800010ad:	77 d4                	ja     ffffffff80001083 <kmalloc+0x83>
		if ( diff < (size + sizeof( struct liballoc_minor )) )
ffffffff800010af:	48 39 d8             	cmp    %rbx,%rax
ffffffff800010b2:	72 de                	jb     ffffffff80001092 <kmalloc+0x92>
ffffffff800010b4:	48 89 d5             	mov    %rdx,%rbp
#endif

#ifdef USE_CASE2
		
		// CASE 2: It's a brand new block.
		if ( maj->first == NULL )
ffffffff800010b7:	48 8b 55 20          	mov    0x20(%rbp),%rdx
ffffffff800010bb:	48 85 d2             	test   %rdx,%rdx
ffffffff800010be:	0f 84 7d 01 00 00    	je     ffffffff80001241 <kmalloc+0x241>
				
#ifdef USE_CASE3

		// CASE 3: Block in use and enough space at the start of the block.
		diff =  (uintptr_t)(maj->first);
		diff -= (uintptr_t)maj;
ffffffff800010c4:	48 89 d0             	mov    %rdx,%rax
ffffffff800010c7:	48 29 e8             	sub    %rbp,%rax
		diff -= sizeof(struct liballoc_major);
ffffffff800010ca:	48 83 e8 28          	sub    $0x28,%rax

		if ( diff >= (size + sizeof(struct liballoc_minor)) )
ffffffff800010ce:	48 39 d8             	cmp    %rbx,%rax
ffffffff800010d1:	0f 83 62 02 00 00    	jae    ffffffff80001339 <kmalloc+0x339>
		
			// Looping within the block now...
		while ( min != NULL )
		{
				// CASE 4.1: End of minors in a block. Space from last and end?
				if ( min->next == NULL )
ffffffff800010d7:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
ffffffff800010db:	8b 72 1c             	mov    0x1c(%rdx),%esi
ffffffff800010de:	48 85 c9             	test   %rcx,%rcx
ffffffff800010e1:	74 25                	je     ffffffff80001108 <kmalloc+0x108>
				// CASE 4.2: Is there space between two minors?
				if ( min->next != NULL )
				{
					// is the difference between here and next big enough?
					diff  = (uintptr_t)(min->next);
					diff -= (uintptr_t)min;
ffffffff800010e3:	48 89 c8             	mov    %rcx,%rax
ffffffff800010e6:	48 29 d0             	sub    %rdx,%rax
					diff -= sizeof( struct liballoc_minor );
ffffffff800010e9:	48 83 e8 28          	sub    $0x28,%rax
					diff -= min->size;
ffffffff800010ed:	48 29 f0             	sub    %rsi,%rax
										// minus our existing usage.

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
ffffffff800010f0:	48 39 d8             	cmp    %rbx,%rax
ffffffff800010f3:	0f 83 b7 00 00 00    	jae    ffffffff800011b0 <kmalloc+0x1b0>
ffffffff800010f9:	48 89 ca             	mov    %rcx,%rdx
				if ( min->next == NULL )
ffffffff800010fc:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
ffffffff80001100:	8b 72 1c             	mov    0x1c(%rdx),%esi
ffffffff80001103:	48 85 c9             	test   %rcx,%rcx
ffffffff80001106:	75 db                	jne    ffffffff800010e3 <kmalloc+0xe3>
					diff = (uintptr_t)(maj) + maj->size;
ffffffff80001108:	8b 45 14             	mov    0x14(%rbp),%eax
					diff -= sizeof( struct liballoc_minor );
ffffffff8000110b:	48 8d 44 05 d8       	lea    -0x28(%rbp,%rax,1),%rax
ffffffff80001110:	48 29 d0             	sub    %rdx,%rax
					diff -= min->size; 
ffffffff80001113:	48 29 f0             	sub    %rsi,%rax
					if ( diff >= (size + sizeof( struct liballoc_minor )) )
ffffffff80001116:	48 39 d8             	cmp    %rbx,%rax
ffffffff80001119:	0f 83 99 01 00 00    	jae    ffffffff800012b8 <kmalloc+0x2b8>
#endif

#ifdef USE_CASE5

		// CASE 5: Block full! Ensure next block and loop.
		if ( maj->next == NULL ) 
ffffffff8000111f:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff80001123:	48 85 d2             	test   %rdx,%rdx
ffffffff80001126:	0f 85 76 ff ff ff    	jne    ffffffff800010a2 <kmalloc+0xa2>
			#ifdef DEBUG
			printf( "CASE 5: block full\n");
			FLUSH();
			#endif

			if ( startedBet == 1 )
ffffffff8000112c:	41 83 ff 01          	cmp    $0x1,%r15d
ffffffff80001130:	74 5e                	je     ffffffff80001190 <kmalloc+0x190>
				startedBet = 0;
				continue;
			}
				
			// we've run out. we need more...
			maj->next = allocate_new_page( size );		// next one guaranteed to be okay
ffffffff80001132:	44 89 e7             	mov    %r12d,%edi
ffffffff80001135:	e8 56 fe ff ff       	callq  ffffffff80000f90 <allocate_new_page>
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
ffffffff8000113a:	48 85 c0             	test   %rax,%rax
			maj->next = allocate_new_page( size );		// next one guaranteed to be okay
ffffffff8000113d:	48 89 c2             	mov    %rax,%rdx
ffffffff80001140:	48 89 45 08          	mov    %rax,0x8(%rbp)
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
ffffffff80001144:	0f 84 e1 01 00 00    	je     ffffffff8000132b <kmalloc+0x32b>
			maj->next->prev = maj;
ffffffff8000114a:	48 89 28             	mov    %rbp,(%rax)
ffffffff8000114d:	e9 50 ff ff ff       	jmpq   ffffffff800010a2 <kmalloc+0xa2>
ffffffff80001152:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			if ( startedBet == 1 )		// If we started at the best bet,
ffffffff80001158:	41 83 ff 01          	cmp    $0x1,%r15d
ffffffff8000115c:	74 32                	je     ffffffff80001190 <kmalloc+0x190>
			maj->next = allocate_new_page( size );	// next one will be okay.
ffffffff8000115e:	44 89 e7             	mov    %r12d,%edi
ffffffff80001161:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
ffffffff80001166:	e8 25 fe ff ff       	callq  ffffffff80000f90 <allocate_new_page>
ffffffff8000116b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
			if ( maj->next == NULL ) break;			// no more memory.
ffffffff80001170:	48 85 c0             	test   %rax,%rax
			maj->next = allocate_new_page( size );	// next one will be okay.
ffffffff80001173:	48 89 c5             	mov    %rax,%rbp
ffffffff80001176:	48 89 42 08          	mov    %rax,0x8(%rdx)
			if ( maj->next == NULL ) break;			// no more memory.
ffffffff8000117a:	0f 84 ab 01 00 00    	je     ffffffff8000132b <kmalloc+0x32b>
			maj->next->prev = maj;
ffffffff80001180:	48 89 10             	mov    %rdx,(%rax)
ffffffff80001183:	e9 2f ff ff ff       	jmpq   ffffffff800010b7 <kmalloc+0xb7>
ffffffff80001188:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000118f:	00 
				maj = l_memRoot;
ffffffff80001190:	48 8b 15 29 f9 00 00 	mov    0xf929(%rip),%rdx        # ffffffff80010ac0 <l_memRoot>
	while ( maj != NULL )
ffffffff80001197:	48 85 d2             	test   %rdx,%rdx
ffffffff8000119a:	0f 84 8b 01 00 00    	je     ffffffff8000132b <kmalloc+0x32b>
ffffffff800011a0:	45 31 ff             	xor    %r15d,%r15d
ffffffff800011a3:	e9 fa fe ff ff       	jmpq   ffffffff800010a2 <kmalloc+0xa2>
ffffffff800011a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff800011af:	00 
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff800011b0:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
						l_inuse += size;
ffffffff800011b4:	4c 01 25 ed f8 00 00 	add    %r12,0xf8ed(%rip)        # ffffffff80010aa8 <l_inuse>
						new_min->next = min->next;
ffffffff800011bb:	48 89 4b 30          	mov    %rcx,0x30(%rbx)
						min->next->prev = new_min;
ffffffff800011bf:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff800011c3:	48 8d 43 28          	lea    0x28(%rbx),%rax
						new_min->magic = LIBALLOC_MAGIC;
ffffffff800011c7:	c7 43 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rbx)
						ALIGN( p );
ffffffff800011ce:	48 83 c3 60          	add    $0x60,%rbx
						new_min->prev = min;
ffffffff800011d2:	48 89 53 c8          	mov    %rdx,-0x38(%rbx)
						new_min->size = size;
ffffffff800011d6:	44 89 63 e4          	mov    %r12d,-0x1c(%rbx)
						new_min->req_size = req_size;
ffffffff800011da:	44 89 6b e8          	mov    %r13d,-0x18(%rbx)
						new_min->block = maj;
ffffffff800011de:	48 89 6b d8          	mov    %rbp,-0x28(%rbx)
						min->next->prev = new_min;
ffffffff800011e2:	48 89 01             	mov    %rax,(%rcx)
						min->next = new_min;
ffffffff800011e5:	48 89 42 08          	mov    %rax,0x8(%rdx)
						ALIGN( p );
ffffffff800011e9:	48 89 da             	mov    %rbx,%rdx
						maj->usage += size + sizeof( struct liballoc_minor );
ffffffff800011ec:	41 8d 44 24 28       	lea    0x28(%r12),%eax
ffffffff800011f1:	01 45 18             	add    %eax,0x18(%rbp)
						ALIGN( p );
ffffffff800011f4:	83 e2 0f             	and    $0xf,%edx
ffffffff800011f7:	0f 84 93 00 00 00    	je     ffffffff80001290 <kmalloc+0x290>
ffffffff800011fd:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80001202:	48 29 d0             	sub    %rdx,%rax
ffffffff80001205:	48 01 c3             	add    %rax,%rbx
ffffffff80001208:	83 c0 10             	add    $0x10,%eax
ffffffff8000120b:	88 43 f0             	mov    %al,-0x10(%rbx)
						liballoc_unlock();		// release the lock
ffffffff8000120e:	31 c0                	xor    %eax,%eax
ffffffff80001210:	e8 cb fc ff ff       	callq  ffffffff80000ee0 <liballoc_unlock>
	printf( "liballoc: WARNING: PREFIX(malloc)( %i ) returning NULL.\n", size);
	liballoc_dump();
	FLUSH();
	#endif
	return NULL;
}
ffffffff80001215:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80001219:	48 89 d8             	mov    %rbx,%rax
ffffffff8000121c:	5b                   	pop    %rbx
ffffffff8000121d:	5d                   	pop    %rbp
ffffffff8000121e:	41 5c                	pop    %r12
ffffffff80001220:	41 5d                	pop    %r13
ffffffff80001222:	41 5e                	pop    %r14
ffffffff80001224:	41 5f                	pop    %r15
ffffffff80001226:	c3                   	retq   
ffffffff80001227:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000122e:	00 00 
ffffffff80001230:	8b 46 14             	mov    0x14(%rsi),%eax
ffffffff80001233:	8b 4e 18             	mov    0x18(%rsi),%ecx
		if ( bestSize > (size + sizeof(struct liballoc_minor)))
ffffffff80001236:	48 89 f2             	mov    %rsi,%rdx
	startedBet = 0;
ffffffff80001239:	45 31 ff             	xor    %r15d,%r15d
ffffffff8000123c:	e9 3b fe ff ff       	jmpq   ffffffff8000107c <kmalloc+0x7c>
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
ffffffff80001241:	48 8d 45 28          	lea    0x28(%rbp),%rax
			maj->first->magic 		= LIBALLOC_MAGIC;
ffffffff80001245:	c7 45 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rbp)
			maj->first->prev 		= NULL;
ffffffff8000124c:	48 c7 45 28 00 00 00 	movq   $0x0,0x28(%rbp)
ffffffff80001253:	00 
			maj->first->next 		= NULL;
ffffffff80001254:	48 c7 45 30 00 00 00 	movq   $0x0,0x30(%rbp)
ffffffff8000125b:	00 
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
ffffffff8000125c:	48 89 45 20          	mov    %rax,0x20(%rbp)
			ALIGN( p );
ffffffff80001260:	48 8d 5d 60          	lea    0x60(%rbp),%rbx
			maj->first->block 	= maj;
ffffffff80001264:	48 89 6d 38          	mov    %rbp,0x38(%rbp)
			maj->first->size 	= size;
ffffffff80001268:	44 89 65 44          	mov    %r12d,0x44(%rbp)
			maj->first->req_size 	= req_size;
ffffffff8000126c:	44 89 6d 48          	mov    %r13d,0x48(%rbp)
			maj->usage 			+= size + sizeof( struct liballoc_minor );
ffffffff80001270:	41 8d 44 24 28       	lea    0x28(%r12),%eax
			l_inuse += size;
ffffffff80001275:	4c 01 25 2c f8 00 00 	add    %r12,0xf82c(%rip)        # ffffffff80010aa8 <l_inuse>
			ALIGN( p );
ffffffff8000127c:	48 89 da             	mov    %rbx,%rdx
			maj->usage 			+= size + sizeof( struct liballoc_minor );
ffffffff8000127f:	01 45 18             	add    %eax,0x18(%rbp)
			ALIGN( p );
ffffffff80001282:	83 e2 0f             	and    $0xf,%edx
ffffffff80001285:	0f 85 72 ff ff ff    	jne    ffffffff800011fd <kmalloc+0x1fd>
ffffffff8000128b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
						ALIGN( p );
ffffffff80001290:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80001295:	e9 71 ff ff ff       	jmpq   ffffffff8000120b <kmalloc+0x20b>
ffffffff8000129a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff800012a0:	8b 46 14             	mov    0x14(%rsi),%eax
ffffffff800012a3:	8b 4e 18             	mov    0x18(%rsi),%ecx
	if ( l_bestBet != NULL )
ffffffff800012a6:	48 89 f2             	mov    %rsi,%rdx
	unsigned long long bestSize = 0;
ffffffff800012a9:	45 31 f6             	xor    %r14d,%r14d
	startedBet = 0;
ffffffff800012ac:	45 31 ff             	xor    %r15d,%r15d
ffffffff800012af:	e9 c8 fd ff ff       	jmpq   ffffffff8000107c <kmalloc+0x7c>
ffffffff800012b4:	0f 1f 40 00          	nopl   0x0(%rax)
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff800012b8:	48 01 d6             	add    %rdx,%rsi
						l_inuse += size;
ffffffff800012bb:	4c 01 25 e6 f7 00 00 	add    %r12,0xf7e6(%rip)        # ffffffff80010aa8 <l_inuse>
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff800012c2:	48 8d 46 28          	lea    0x28(%rsi),%rax
						ALIGN( p );
ffffffff800012c6:	48 8d 5e 60          	lea    0x60(%rsi),%rbx
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff800012ca:	48 89 42 08          	mov    %rax,0x8(%rdx)
						maj->usage += size + sizeof( struct liballoc_minor );
ffffffff800012ce:	41 8d 44 24 28       	lea    0x28(%r12),%eax
						min->next->prev = min;
ffffffff800012d3:	48 89 56 28          	mov    %rdx,0x28(%rsi)
						ALIGN( p );
ffffffff800012d7:	48 89 da             	mov    %rbx,%rdx
						min->next = NULL;
ffffffff800012da:	48 c7 46 30 00 00 00 	movq   $0x0,0x30(%rsi)
ffffffff800012e1:	00 
						min->magic = LIBALLOC_MAGIC;
ffffffff800012e2:	c7 46 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rsi)
						min->block = maj;
ffffffff800012e9:	48 89 6e 38          	mov    %rbp,0x38(%rsi)
						min->size = size;
ffffffff800012ed:	44 89 66 44          	mov    %r12d,0x44(%rsi)
						min->req_size = req_size;
ffffffff800012f1:	44 89 6e 48          	mov    %r13d,0x48(%rsi)
						maj->usage += size + sizeof( struct liballoc_minor );
ffffffff800012f5:	01 45 18             	add    %eax,0x18(%rbp)
						ALIGN( p );
ffffffff800012f8:	83 e2 0f             	and    $0xf,%edx
ffffffff800012fb:	0f 85 fc fe ff ff    	jne    ffffffff800011fd <kmalloc+0x1fd>
						ALIGN( p );
ffffffff80001301:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80001306:	e9 00 ff ff ff       	jmpq   ffffffff8000120b <kmalloc+0x20b>
ffffffff8000130b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		l_memRoot = allocate_new_page( size );
ffffffff80001310:	44 89 e7             	mov    %r12d,%edi
ffffffff80001313:	e8 78 fc ff ff       	callq  ffffffff80000f90 <allocate_new_page>
		if ( l_memRoot == NULL )
ffffffff80001318:	48 85 c0             	test   %rax,%rax
		l_memRoot = allocate_new_page( size );
ffffffff8000131b:	48 89 c6             	mov    %rax,%rsi
ffffffff8000131e:	48 89 05 9b f7 00 00 	mov    %rax,0xf79b(%rip)        # ffffffff80010ac0 <l_memRoot>
		if ( l_memRoot == NULL )
ffffffff80001325:	0f 85 22 fd ff ff    	jne    ffffffff8000104d <kmalloc+0x4d>
		  liballoc_unlock();
ffffffff8000132b:	31 c0                	xor    %eax,%eax
		  return NULL;
ffffffff8000132d:	31 db                	xor    %ebx,%ebx
		  liballoc_unlock();
ffffffff8000132f:	e8 ac fb ff ff       	callq  ffffffff80000ee0 <liballoc_unlock>
		  return NULL;
ffffffff80001334:	e9 dc fe ff ff       	jmpq   ffffffff80001215 <kmalloc+0x215>
			maj->first->prev = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
ffffffff80001339:	48 8d 45 28          	lea    0x28(%rbp),%rax
ffffffff8000133d:	48 89 02             	mov    %rax,(%rdx)
			maj->first->prev->next = maj->first;
ffffffff80001340:	48 89 55 30          	mov    %rdx,0x30(%rbp)
			maj->first = maj->first->prev;
ffffffff80001344:	48 89 45 20          	mov    %rax,0x20(%rbp)
			maj->first->magic 	= LIBALLOC_MAGIC;
ffffffff80001348:	c7 45 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rbp)
			maj->first->prev 	= NULL;
ffffffff8000134f:	48 c7 45 28 00 00 00 	movq   $0x0,0x28(%rbp)
ffffffff80001356:	00 
ffffffff80001357:	e9 04 ff ff ff       	jmpq   ffffffff80001260 <kmalloc+0x260>
ffffffff8000135c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001360 <kfree>:
void PREFIX(free)(void *ptr)
{
	struct liballoc_minor *min;
	struct liballoc_major *maj;

	if ( ptr == NULL ) 
ffffffff80001360:	48 85 ff             	test   %rdi,%rdi
ffffffff80001363:	0f 84 d7 00 00 00    	je     ffffffff80001440 <kfree+0xe0>
{
ffffffff80001369:	53                   	push   %rbx
		FLUSH();
		#endif
		return;
	}

	UNALIGN( ptr );
ffffffff8000136a:	48 0f be 47 f0       	movsbq -0x10(%rdi),%rax
ffffffff8000136f:	48 89 fb             	mov    %rdi,%rbx
ffffffff80001372:	48 29 c3             	sub    %rax,%rbx
ffffffff80001375:	48 83 f8 20          	cmp    $0x20,%rax
ffffffff80001379:	48 0f 43 df          	cmovae %rdi,%rbx

	liballoc_lock();		// lockit
ffffffff8000137d:	31 c0                	xor    %eax,%eax
ffffffff8000137f:	e8 4c fb ff ff       	callq  ffffffff80000ed0 <liballoc_lock>


	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));

	
	if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff80001384:	8b 43 f0             	mov    -0x10(%rbx),%eax
	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
ffffffff80001387:	48 8d 73 d8          	lea    -0x28(%rbx),%rsi
	if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff8000138b:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
ffffffff80001390:	74 2e                	je     ffffffff800013c0 <kfree+0x60>
	{
		l_errorCount += 1;

		// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
		if ( 
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80001392:	89 c2                	mov    %eax,%edx
		l_errorCount += 1;
ffffffff80001394:	48 83 05 fc f6 00 00 	addq   $0x1,0xf6fc(%rip)        # ffffffff80010a98 <l_errorCount>
ffffffff8000139b:	01 
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff8000139c:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
		if ( 
ffffffff800013a2:	81 fa de c0 01 00    	cmp    $0x1c0de,%edx
ffffffff800013a8:	0f 84 82 00 00 00    	je     ffffffff80001430 <kfree+0xd0>
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff800013ae:	66 3d de c0          	cmp    $0xc0de,%ax
ffffffff800013b2:	74 7c                	je     ffffffff80001430 <kfree+0xd0>
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
ffffffff800013b4:	3c de                	cmp    $0xde,%al
ffffffff800013b6:	74 78                	je     ffffffff80001430 <kfree+0xd0>
	printf( "OK\n");
	FLUSH();
	#endif
	
	liballoc_unlock();		// release the lock
}
ffffffff800013b8:	5b                   	pop    %rbx
		liballoc_unlock();		// release the lock
ffffffff800013b9:	31 c0                	xor    %eax,%eax
ffffffff800013bb:	e9 20 fb ff ff       	jmpq   ffffffff80000ee0 <liballoc_unlock>
		maj = min->block;
ffffffff800013c0:	48 8b 7b e8          	mov    -0x18(%rbx),%rdi
		l_inuse -= min->size;
ffffffff800013c4:	8b 53 f4             	mov    -0xc(%rbx),%edx
ffffffff800013c7:	48 29 15 da f6 00 00 	sub    %rdx,0xf6da(%rip)        # ffffffff80010aa8 <l_inuse>
		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
ffffffff800013ce:	8b 4f 18             	mov    0x18(%rdi),%ecx
ffffffff800013d1:	29 d1                	sub    %edx,%ecx
		if ( min->next != NULL ) min->next->prev = min->prev;
ffffffff800013d3:	48 8b 53 e0          	mov    -0x20(%rbx),%rdx
		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
ffffffff800013d7:	89 c8                	mov    %ecx,%eax
ffffffff800013d9:	48 8b 4b d8          	mov    -0x28(%rbx),%rcx
ffffffff800013dd:	83 e8 28             	sub    $0x28,%eax
		if ( min->next != NULL ) min->next->prev = min->prev;
ffffffff800013e0:	48 85 d2             	test   %rdx,%rdx
		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
ffffffff800013e3:	89 47 18             	mov    %eax,0x18(%rdi)
		min->magic  = LIBALLOC_DEAD;		// No mojo.
ffffffff800013e6:	c7 43 f0 ad de ad de 	movl   $0xdeaddead,-0x10(%rbx)
		if ( min->next != NULL ) min->next->prev = min->prev;
ffffffff800013ed:	74 06                	je     ffffffff800013f5 <kfree+0x95>
ffffffff800013ef:	48 89 0a             	mov    %rcx,(%rdx)
ffffffff800013f2:	48 8b 0e             	mov    (%rsi),%rcx
		if ( min->prev != NULL ) min->prev->next = min->next;
ffffffff800013f5:	48 85 c9             	test   %rcx,%rcx
ffffffff800013f8:	74 56                	je     ffffffff80001450 <kfree+0xf0>
ffffffff800013fa:	48 89 51 08          	mov    %rdx,0x8(%rcx)
ffffffff800013fe:	48 8b 57 20          	mov    0x20(%rdi),%rdx
	if ( maj->first == NULL )	// Block completely unused.
ffffffff80001402:	48 85 d2             	test   %rdx,%rdx
ffffffff80001405:	48 8b 0d ac f6 00 00 	mov    0xf6ac(%rip),%rcx        # ffffffff80010ab8 <l_bestBet>
ffffffff8000140c:	74 52                	je     ffffffff80001460 <kfree+0x100>
		if ( l_bestBet != NULL )
ffffffff8000140e:	48 85 c9             	test   %rcx,%rcx
ffffffff80001411:	74 a5                	je     ffffffff800013b8 <kfree+0x58>
			int bestSize = l_bestBet->size  - l_bestBet->usage;
ffffffff80001413:	8b 51 14             	mov    0x14(%rcx),%edx
			int majSize = maj->size - maj->usage;
ffffffff80001416:	8b 77 14             	mov    0x14(%rdi),%esi
			int bestSize = l_bestBet->size  - l_bestBet->usage;
ffffffff80001419:	2b 51 18             	sub    0x18(%rcx),%edx
			int majSize = maj->size - maj->usage;
ffffffff8000141c:	29 c6                	sub    %eax,%esi
			if ( majSize > bestSize ) l_bestBet = maj;
ffffffff8000141e:	39 f2                	cmp    %esi,%edx
ffffffff80001420:	7d 96                	jge    ffffffff800013b8 <kfree+0x58>
ffffffff80001422:	48 89 3d 8f f6 00 00 	mov    %rdi,0xf68f(%rip)        # ffffffff80010ab8 <l_bestBet>
ffffffff80001429:	eb 8d                	jmp    ffffffff800013b8 <kfree+0x58>
ffffffff8000142b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
			l_possibleOverruns += 1;
ffffffff80001430:	48 83 05 58 f6 00 00 	addq   $0x1,0xf658(%rip)        # ffffffff80010a90 <l_possibleOverruns>
ffffffff80001437:	01 
		liballoc_unlock();		// release the lock
ffffffff80001438:	31 c0                	xor    %eax,%eax
}
ffffffff8000143a:	5b                   	pop    %rbx
		liballoc_unlock();		// release the lock
ffffffff8000143b:	e9 a0 fa ff ff       	jmpq   ffffffff80000ee0 <liballoc_unlock>
		l_warningCount += 1;
ffffffff80001440:	48 83 05 58 f6 00 00 	addq   $0x1,0xf658(%rip)        # ffffffff80010aa0 <l_warningCount>
ffffffff80001447:	01 
ffffffff80001448:	c3                   	retq   
ffffffff80001449:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		if ( min->prev == NULL ) maj->first = min->next;	
ffffffff80001450:	48 89 57 20          	mov    %rdx,0x20(%rdi)
ffffffff80001454:	eb ac                	jmp    ffffffff80001402 <kfree+0xa2>
ffffffff80001456:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000145d:	00 00 00 
		if ( l_memRoot == maj ) l_memRoot = maj->next;
ffffffff80001460:	48 39 3d 59 f6 00 00 	cmp    %rdi,0xf659(%rip)        # ffffffff80010ac0 <l_memRoot>
ffffffff80001467:	48 8b 47 08          	mov    0x8(%rdi),%rax
ffffffff8000146b:	74 3b                	je     ffffffff800014a8 <kfree+0x148>
		if ( l_bestBet == maj ) l_bestBet = NULL;
ffffffff8000146d:	48 39 cf             	cmp    %rcx,%rdi
ffffffff80001470:	74 46                	je     ffffffff800014b8 <kfree+0x158>
		if ( maj->prev != NULL ) maj->prev->next = maj->next;
ffffffff80001472:	48 8b 17             	mov    (%rdi),%rdx
ffffffff80001475:	48 85 d2             	test   %rdx,%rdx
ffffffff80001478:	74 08                	je     ffffffff80001482 <kfree+0x122>
ffffffff8000147a:	48 89 42 08          	mov    %rax,0x8(%rdx)
ffffffff8000147e:	48 8b 47 08          	mov    0x8(%rdi),%rax
		if ( maj->next != NULL ) maj->next->prev = maj->prev;
ffffffff80001482:	48 85 c0             	test   %rax,%rax
ffffffff80001485:	74 03                	je     ffffffff8000148a <kfree+0x12a>
ffffffff80001487:	48 89 10             	mov    %rdx,(%rax)
		liballoc_free( maj, maj->pages );
ffffffff8000148a:	8b 77 10             	mov    0x10(%rdi),%esi
		l_allocated -= maj->size;
ffffffff8000148d:	8b 47 14             	mov    0x14(%rdi),%eax
ffffffff80001490:	48 29 05 19 f6 00 00 	sub    %rax,0xf619(%rip)        # ffffffff80010ab0 <l_allocated>
		liballoc_free( maj, maj->pages );
ffffffff80001497:	e8 54 fa ff ff       	callq  ffffffff80000ef0 <liballoc_free>
ffffffff8000149c:	e9 17 ff ff ff       	jmpq   ffffffff800013b8 <kfree+0x58>
ffffffff800014a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		if ( l_memRoot == maj ) l_memRoot = maj->next;
ffffffff800014a8:	48 89 05 11 f6 00 00 	mov    %rax,0xf611(%rip)        # ffffffff80010ac0 <l_memRoot>
ffffffff800014af:	eb bc                	jmp    ffffffff8000146d <kfree+0x10d>
ffffffff800014b1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		if ( l_bestBet == maj ) l_bestBet = NULL;
ffffffff800014b8:	48 c7 05 f5 f5 00 00 	movq   $0x0,0xf5f5(%rip)        # ffffffff80010ab8 <l_bestBet>
ffffffff800014bf:	00 00 00 00 
ffffffff800014c3:	eb ad                	jmp    ffffffff80001472 <kfree+0x112>
ffffffff800014c5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800014cc:	00 00 00 00 

ffffffff800014d0 <kcalloc>:
void* PREFIX(calloc)(size_t nobj, size_t size)
{
       int real_size;
       void *p;

       real_size = nobj * size;
ffffffff800014d0:	0f af fe             	imul   %esi,%edi
{
ffffffff800014d3:	53                   	push   %rbx
       
       p = PREFIX(malloc)( real_size );
ffffffff800014d4:	48 63 df             	movslq %edi,%rbx
ffffffff800014d7:	48 89 df             	mov    %rbx,%rdi
ffffffff800014da:	e8 21 fb ff ff       	callq  ffffffff80001000 <kmalloc>
	for ( i = 0; i < n ; i++)
ffffffff800014df:	48 85 db             	test   %rbx,%rbx
ffffffff800014e2:	74 1b                	je     ffffffff800014ff <kcalloc+0x2f>
ffffffff800014e4:	31 c9                	xor    %ecx,%ecx
ffffffff800014e6:	31 d2                	xor    %edx,%edx
ffffffff800014e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff800014ef:	00 
		((char*)s)[i] = c;
ffffffff800014f0:	c6 04 10 00          	movb   $0x0,(%rax,%rdx,1)
	for ( i = 0; i < n ; i++)
ffffffff800014f4:	8d 51 01             	lea    0x1(%rcx),%edx
ffffffff800014f7:	48 39 d3             	cmp    %rdx,%rbx
ffffffff800014fa:	48 89 d1             	mov    %rdx,%rcx
ffffffff800014fd:	77 f1                	ja     ffffffff800014f0 <kcalloc+0x20>

       liballoc_memset( p, 0, real_size );

       return p;
}
ffffffff800014ff:	5b                   	pop    %rbx
ffffffff80001500:	c3                   	retq   
ffffffff80001501:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001508:	00 00 00 00 
ffffffff8000150c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001510 <krealloc>:



void*   PREFIX(realloc)(void *p, size_t size)
{
ffffffff80001510:	41 54                	push   %r12
ffffffff80001512:	55                   	push   %rbp
ffffffff80001513:	53                   	push   %rbx
ffffffff80001514:	48 89 fb             	mov    %rdi,%rbx
ffffffff80001517:	48 83 ec 10          	sub    $0x10,%rsp
	void *ptr;
	struct liballoc_minor *min;
	unsigned int real_size;
	
	// Honour the case of size == 0 => free old and return NULL
	if ( size == 0 )
ffffffff8000151b:	48 85 f6             	test   %rsi,%rsi
ffffffff8000151e:	0f 84 54 01 00 00    	je     ffffffff80001678 <krealloc+0x168>
		PREFIX(free)( p );
		return NULL;
	}

	// In the case of a NULL pointer, return a simple malloc.
	if ( p == NULL ) return PREFIX(malloc)( size );
ffffffff80001524:	48 85 ff             	test   %rdi,%rdi
ffffffff80001527:	49 89 f4             	mov    %rsi,%r12
ffffffff8000152a:	0f 84 e0 00 00 00    	je     ffffffff80001610 <krealloc+0x100>

	// Unalign the pointer if required.
	ptr = p;
	UNALIGN(ptr);
ffffffff80001530:	48 0f be 47 f0       	movsbq -0x10(%rdi),%rax
ffffffff80001535:	48 89 fd             	mov    %rdi,%rbp
ffffffff80001538:	48 29 c5             	sub    %rax,%rbp
ffffffff8000153b:	48 83 f8 20          	cmp    $0x20,%rax
ffffffff8000153f:	48 0f 43 ef          	cmovae %rdi,%rbp

	liballoc_lock();		// lockit
ffffffff80001543:	31 c0                	xor    %eax,%eax
ffffffff80001545:	e8 86 f9 ff ff       	callq  ffffffff80000ed0 <liballoc_lock>

		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));

		// Ensure it is a valid structure.
		if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff8000154a:	8b 45 f0             	mov    -0x10(%rbp),%eax
		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
ffffffff8000154d:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
		if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff80001551:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
ffffffff80001556:	0f 85 c4 00 00 00    	jne    ffffffff80001620 <krealloc+0x110>
		
		// Definitely a memory block.
		
		real_size = min->req_size;

		if ( real_size >= size ) 
ffffffff8000155c:	8b 6d f8             	mov    -0x8(%rbp),%ebp
ffffffff8000155f:	4c 39 e5             	cmp    %r12,%rbp
ffffffff80001562:	0f 83 90 00 00 00    	jae    ffffffff800015f8 <krealloc+0xe8>
			min->req_size = size;
			liballoc_unlock();
			return p;
		}

	liballoc_unlock();
ffffffff80001568:	31 c0                	xor    %eax,%eax
ffffffff8000156a:	e8 71 f9 ff ff       	callq  ffffffff80000ee0 <liballoc_unlock>

	// If we got here then we're reallocating to a block bigger than us.
	ptr = PREFIX(malloc)( size );					// We need to allocate new memory
ffffffff8000156f:	4c 89 e7             	mov    %r12,%rdi
ffffffff80001572:	e8 89 fa ff ff       	callq  ffffffff80001000 <kmalloc>
  while ( n >= sizeof(unsigned int) )
ffffffff80001577:	48 83 fd 03          	cmp    $0x3,%rbp
ffffffff8000157b:	0f 86 e7 00 00 00    	jbe    ffffffff80001668 <krealloc+0x158>
ffffffff80001581:	48 83 ed 04          	sub    $0x4,%rbp
ffffffff80001585:	31 d2                	xor    %edx,%edx
ffffffff80001587:	48 89 ef             	mov    %rbp,%rdi
ffffffff8000158a:	48 c1 ef 02          	shr    $0x2,%rdi
ffffffff8000158e:	48 8d 34 bd 04 00 00 	lea    0x4(,%rdi,4),%rsi
ffffffff80001595:	00 
ffffffff80001596:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000159d:	00 00 00 
      *ldest++ = *lsrc++;
ffffffff800015a0:	8b 0c 13             	mov    (%rbx,%rdx,1),%ecx
ffffffff800015a3:	89 0c 10             	mov    %ecx,(%rax,%rdx,1)
ffffffff800015a6:	48 83 c2 04          	add    $0x4,%rdx
  while ( n >= sizeof(unsigned int) )
ffffffff800015aa:	48 39 f2             	cmp    %rsi,%rdx
ffffffff800015ad:	75 f1                	jne    ffffffff800015a0 <krealloc+0x90>
ffffffff800015af:	48 f7 df             	neg    %rdi
ffffffff800015b2:	4c 8d 04 13          	lea    (%rbx,%rdx,1),%r8
ffffffff800015b6:	48 01 c2             	add    %rax,%rdx
ffffffff800015b9:	48 8d 6c bd 00       	lea    0x0(%rbp,%rdi,4),%rbp
  while ( n > 0 )
ffffffff800015be:	48 85 ed             	test   %rbp,%rbp
ffffffff800015c1:	74 14                	je     ffffffff800015d7 <krealloc+0xc7>
ffffffff800015c3:	31 c9                	xor    %ecx,%ecx
      *cdest++ = *csrc++;
ffffffff800015c5:	41 0f b6 34 08       	movzbl (%r8,%rcx,1),%esi
ffffffff800015ca:	40 88 34 0a          	mov    %sil,(%rdx,%rcx,1)
ffffffff800015ce:	48 83 c1 01          	add    $0x1,%rcx
  while ( n > 0 )
ffffffff800015d2:	48 39 e9             	cmp    %rbp,%rcx
ffffffff800015d5:	75 ee                	jne    ffffffff800015c5 <krealloc+0xb5>
	liballoc_memcpy( ptr, p, real_size );
	PREFIX(free)( p );
ffffffff800015d7:	48 89 df             	mov    %rbx,%rdi
ffffffff800015da:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff800015df:	e8 7c fd ff ff       	callq  ffffffff80001360 <kfree>
ffffffff800015e4:	48 8b 44 24 08       	mov    0x8(%rsp),%rax

	return ptr;
}
ffffffff800015e9:	48 83 c4 10          	add    $0x10,%rsp
ffffffff800015ed:	5b                   	pop    %rbx
ffffffff800015ee:	5d                   	pop    %rbp
ffffffff800015ef:	41 5c                	pop    %r12
ffffffff800015f1:	c3                   	retq   
ffffffff800015f2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			min->req_size = size;
ffffffff800015f8:	44 89 62 20          	mov    %r12d,0x20(%rdx)
			liballoc_unlock();
ffffffff800015fc:	31 c0                	xor    %eax,%eax
ffffffff800015fe:	e8 dd f8 ff ff       	callq  ffffffff80000ee0 <liballoc_unlock>
			return p;
ffffffff80001603:	48 89 d8             	mov    %rbx,%rax
}
ffffffff80001606:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8000160a:	5b                   	pop    %rbx
ffffffff8000160b:	5d                   	pop    %rbp
ffffffff8000160c:	41 5c                	pop    %r12
ffffffff8000160e:	c3                   	retq   
ffffffff8000160f:	90                   	nop
ffffffff80001610:	48 83 c4 10          	add    $0x10,%rsp
	if ( p == NULL ) return PREFIX(malloc)( size );
ffffffff80001614:	48 89 f7             	mov    %rsi,%rdi
}
ffffffff80001617:	5b                   	pop    %rbx
ffffffff80001618:	5d                   	pop    %rbp
ffffffff80001619:	41 5c                	pop    %r12
	if ( p == NULL ) return PREFIX(malloc)( size );
ffffffff8000161b:	e9 e0 f9 ff ff       	jmpq   ffffffff80001000 <kmalloc>
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80001620:	89 c2                	mov    %eax,%edx
			l_errorCount += 1;
ffffffff80001622:	48 83 05 6e f4 00 00 	addq   $0x1,0xf46e(%rip)        # ffffffff80010a98 <l_errorCount>
ffffffff80001629:	01 
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff8000162a:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
			if ( 
ffffffff80001630:	81 fa de c0 01 00    	cmp    $0x1c0de,%edx
ffffffff80001636:	74 20                	je     ffffffff80001658 <krealloc+0x148>
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80001638:	66 3d de c0          	cmp    $0xc0de,%ax
ffffffff8000163c:	74 1a                	je     ffffffff80001658 <krealloc+0x148>
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
ffffffff8000163e:	3c de                	cmp    $0xde,%al
ffffffff80001640:	74 16                	je     ffffffff80001658 <krealloc+0x148>
			liballoc_unlock();		// release the lock
ffffffff80001642:	31 c0                	xor    %eax,%eax
ffffffff80001644:	e8 97 f8 ff ff       	callq  ffffffff80000ee0 <liballoc_unlock>
}
ffffffff80001649:	48 83 c4 10          	add    $0x10,%rsp
			return NULL;
ffffffff8000164d:	31 c0                	xor    %eax,%eax
}
ffffffff8000164f:	5b                   	pop    %rbx
ffffffff80001650:	5d                   	pop    %rbp
ffffffff80001651:	41 5c                	pop    %r12
ffffffff80001653:	c3                   	retq   
ffffffff80001654:	0f 1f 40 00          	nopl   0x0(%rax)
				l_possibleOverruns += 1;
ffffffff80001658:	48 83 05 30 f4 00 00 	addq   $0x1,0xf430(%rip)        # ffffffff80010a90 <l_possibleOverruns>
ffffffff8000165f:	01 
ffffffff80001660:	eb e0                	jmp    ffffffff80001642 <krealloc+0x132>
ffffffff80001662:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	ptr = PREFIX(malloc)( size );					// We need to allocate new memory
ffffffff80001668:	48 89 c2             	mov    %rax,%rdx
  while ( n >= sizeof(unsigned int) )
ffffffff8000166b:	49 89 d8             	mov    %rbx,%r8
ffffffff8000166e:	e9 4b ff ff ff       	jmpq   ffffffff800015be <krealloc+0xae>
ffffffff80001673:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		PREFIX(free)( p );
ffffffff80001678:	e8 e3 fc ff ff       	callq  ffffffff80001360 <kfree>
		return NULL;
ffffffff8000167d:	31 c0                	xor    %eax,%eax
ffffffff8000167f:	eb 85                	jmp    ffffffff80001606 <krealloc+0xf6>
ffffffff80001681:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001688:	00 00 00 
ffffffff8000168b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80001690 <pmm_init>:

//Initialize the Physical Memory Manager
void pmm_init()
{
    //memory map helper variables
    uint64_t mmap_entries = boot_info.tag_memmap->entries;
ffffffff80001690:	48 8b 05 59 97 00 00 	mov    0x9759(%rip),%rax        # ffffffff8000adf0 <boot_info+0x10>
ffffffff80001697:	48 8b 35 c2 97 00 00 	mov    0x97c2(%rip),%rsi        # ffffffff8000ae60 <pmm_info>
ffffffff8000169e:	4c 8b 58 10          	mov    0x10(%rax),%r11
    uint64_t mmap_largest_segment_base = 0;     //Address of the largest segment
    uint64_t mmap_largest_segment_size = 0;     //Size of the largest segment
    //uint8_t* type = NULL;

    //iterate through the memory map, find the largest memory segment, calculate total memory size
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800016a2:	4d 85 db             	test   %r11,%r11
ffffffff800016a5:	0f 84 c5 00 00 00    	je     ffffffff80001770 <pmm_init+0xe0>
{
ffffffff800016ab:	55                   	push   %rbp
ffffffff800016ac:	53                   	push   %rbx
ffffffff800016ad:	48 83 c0 18          	add    $0x18,%rax
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800016b1:	45 31 c9             	xor    %r9d,%r9d
ffffffff800016b4:	31 db                	xor    %ebx,%ebx
    uint64_t mmap_largest_segment_size = 0;     //Size of the largest segment
ffffffff800016b6:	45 31 d2             	xor    %r10d,%r10d
{
ffffffff800016b9:	48 83 ec 08          	sub    $0x8,%rsp
    uint64_t mmap_largest_segment_base = 0;     //Address of the largest segment
ffffffff800016bd:	31 c9                	xor    %ecx,%ecx
ffffffff800016bf:	4c 8b 05 d2 97 00 00 	mov    0x97d2(%rip),%r8        # ffffffff8000ae98 <pmm_vmm_info+0x8>
ffffffff800016c6:	48 8b 3d d3 97 00 00 	mov    0x97d3(%rip),%rdi        # ffffffff8000aea0 <pmm_vmm_info+0x10>
ffffffff800016cd:	eb 1e                	jmp    ffffffff800016ed <pmm_init+0x5d>
ffffffff800016cf:	90                   	nop
        {
            continue;
        }

        //Capture the largest segment size
        if(current_entry->length > mmap_largest_segment_size)
ffffffff800016d0:	4c 39 d2             	cmp    %r10,%rdx
ffffffff800016d3:	76 0b                	jbe    ffffffff800016e0 <pmm_init+0x50>
ffffffff800016d5:	83 fd 01             	cmp    $0x1,%ebp
ffffffff800016d8:	75 06                	jne    ffffffff800016e0 <pmm_init+0x50>
        {
            mmap_largest_segment_base = current_entry->base;
ffffffff800016da:	48 8b 08             	mov    (%rax),%rcx
ffffffff800016dd:	49 89 d2             	mov    %rdx,%r10
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800016e0:	48 83 c3 01          	add    $0x1,%rbx
ffffffff800016e4:	48 83 c0 18          	add    $0x18,%rax
ffffffff800016e8:	49 39 db             	cmp    %rbx,%r11
ffffffff800016eb:	74 2b                	je     ffffffff80001718 <pmm_init+0x88>
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff800016ed:	48 8b 50 08          	mov    0x8(%rax),%rdx
        if(current_entry->type == 0x1002)
ffffffff800016f1:	8b 68 10             	mov    0x10(%rax),%ebp
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff800016f4:	48 01 d6             	add    %rdx,%rsi
        if(current_entry->type == 0x1002)
ffffffff800016f7:	81 fd 02 10 00 00    	cmp    $0x1002,%ebp
ffffffff800016fd:	75 d1                	jne    ffffffff800016d0 <pmm_init+0x40>
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800016ff:	48 83 c3 01          	add    $0x1,%rbx
            pmm_vmm_info.fb_base = current_entry->base;
ffffffff80001703:	4c 8b 00             	mov    (%rax),%r8
ffffffff80001706:	48 83 c0 18          	add    $0x18,%rax
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff8000170a:	49 39 db             	cmp    %rbx,%r11
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff8000170d:	48 89 d7             	mov    %rdx,%rdi
            pmm_vmm_info.fb_base = current_entry->base;
ffffffff80001710:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80001716:	75 d5                	jne    ffffffff800016ed <pmm_init+0x5d>
ffffffff80001718:	45 84 c9             	test   %r9b,%r9b
ffffffff8000171b:	48 89 35 3e 97 00 00 	mov    %rsi,0x973e(%rip)        # ffffffff8000ae60 <pmm_info>
ffffffff80001722:	74 0e                	je     ffffffff80001732 <pmm_init+0xa2>
ffffffff80001724:	4c 89 05 6d 97 00 00 	mov    %r8,0x976d(%rip)        # ffffffff8000ae98 <pmm_vmm_info+0x8>
ffffffff8000172b:	48 89 3d 6e 97 00 00 	mov    %rdi,0x976e(%rip)        # ffffffff8000aea0 <pmm_vmm_info+0x10>
            mmap_largest_segment_size = current_entry->length;
        }
    };

    //Populate the PMM state variables
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff80001732:	48 89 f0             	mov    %rsi,%rax
ffffffff80001735:	48 c1 e8 0c          	shr    $0xc,%rax
ffffffff80001739:	48 89 05 30 97 00 00 	mov    %rax,0x9730(%rip)        # ffffffff8000ae70 <pmm_info+0x10>
    pmm_info.usedpages = pmm_info.totalpages;
ffffffff80001740:	48 89 05 21 97 00 00 	mov    %rax,0x9721(%rip)        # ffffffff8000ae68 <pmm_info+0x8>
    pmm_info.bitmap_size = (pmm_info.totalpages / 8) + 1;
ffffffff80001747:	48 89 f0             	mov    %rsi,%rax
ffffffff8000174a:	48 c1 e8 0f          	shr    $0xf,%rax
ffffffff8000174e:	48 83 c0 01          	add    $0x1,%rax
    
    if(pmm_info.bitmap_size > current_entry->length) 
ffffffff80001752:	48 39 c2             	cmp    %rax,%rdx
    pmm_info.bitmap_size = (pmm_info.totalpages / 8) + 1;
ffffffff80001755:	48 89 05 24 97 00 00 	mov    %rax,0x9724(%rip)        # ffffffff8000ae80 <pmm_info+0x20>
    if(pmm_info.bitmap_size > current_entry->length) 
ffffffff8000175c:	73 4a                	jae    ffffffff800017a8 <pmm_init+0x118>
        {
            printf("Bitmap too large");
ffffffff8000175e:	48 c7 c7 49 52 00 80 	mov    $0xffffffff80005249,%rdi
ffffffff80001765:	31 c0                	xor    %eax,%eax
ffffffff80001767:	e8 44 20 00 00       	callq  ffffffff800037b0 <printf_>
ffffffff8000176c:	eb fe                	jmp    ffffffff8000176c <pmm_init+0xdc>
ffffffff8000176e:	66 90                	xchg   %ax,%ax
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff80001770:	48 89 f0             	mov    %rsi,%rax
ffffffff80001773:	48 c1 e8 0c          	shr    $0xc,%rax
    pmm_info.usedpages = pmm_info.totalpages;
ffffffff80001777:	48 89 05 ea 96 00 00 	mov    %rax,0x96ea(%rip)        # ffffffff8000ae68 <pmm_info+0x8>
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff8000177e:	48 89 05 eb 96 00 00 	mov    %rax,0x96eb(%rip)        # ffffffff8000ae70 <pmm_info+0x10>
    pmm_info.bitmap_size = (pmm_info.totalpages / 8) + 1;
ffffffff80001785:	48 89 f0             	mov    %rsi,%rax
ffffffff80001788:	48 c1 e8 0f          	shr    $0xf,%rax
ffffffff8000178c:	48 83 c0 01          	add    $0x1,%rax
ffffffff80001790:	48 89 05 e9 96 00 00 	mov    %rax,0x96e9(%rip)        # ffffffff8000ae80 <pmm_info+0x20>
    if(pmm_info.bitmap_size > current_entry->length) 
ffffffff80001797:	48 8b 04 25 08 00 00 	mov    0x8,%rax
ffffffff8000179e:	00 
ffffffff8000179f:	0f 0b                	ud2    
ffffffff800017a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff800017a8:	48 b8 00 00 00 00 00 	movabs $0xffff800000000000,%rax
ffffffff800017af:	80 ff ff 
            for(;;){}   //hang
        }
    
    pmm_info.bitmap = (uint8_t*)phys_to_hh_data(mmap_largest_segment_base); 

    printf("Total Memory: %d\n", (pmm_info.totalmem));
ffffffff800017b2:	48 c7 c7 5a 52 00 80 	mov    $0xffffffff8000525a,%rdi
ffffffff800017b9:	48 01 c1             	add    %rax,%rcx
ffffffff800017bc:	31 c0                	xor    %eax,%eax
ffffffff800017be:	48 89 0d b3 96 00 00 	mov    %rcx,0x96b3(%rip)        # ffffffff8000ae78 <pmm_info+0x18>
ffffffff800017c5:	e8 e6 1f 00 00       	callq  ffffffff800037b0 <printf_>
    printf("Total Pages: %d   Used Pages: %d\n", pmm_info.totalpages, pmm_info.usedpages);
ffffffff800017ca:	48 8b 15 97 96 00 00 	mov    0x9697(%rip),%rdx        # ffffffff8000ae68 <pmm_info+0x8>
ffffffff800017d1:	48 8b 35 98 96 00 00 	mov    0x9698(%rip),%rsi        # ffffffff8000ae70 <pmm_info+0x10>
ffffffff800017d8:	48 c7 c7 a8 52 00 80 	mov    $0xffffffff800052a8,%rdi
ffffffff800017df:	31 c0                	xor    %eax,%eax
ffffffff800017e1:	e8 ca 1f 00 00       	callq  ffffffff800037b0 <printf_>
    printf("Bitmap Addr: %p  Bitmap Size (bytes): %d\n", pmm_info.bitmap, pmm_info.bitmap_size);
ffffffff800017e6:	48 8b 15 93 96 00 00 	mov    0x9693(%rip),%rdx        # ffffffff8000ae80 <pmm_info+0x20>
ffffffff800017ed:	48 8b 35 84 96 00 00 	mov    0x9684(%rip),%rsi        # ffffffff8000ae78 <pmm_info+0x18>
ffffffff800017f4:	31 c0                	xor    %eax,%eax
ffffffff800017f6:	48 c7 c7 d0 52 00 80 	mov    $0xffffffff800052d0,%rdi
ffffffff800017fd:	e8 ae 1f 00 00       	callq  ffffffff800037b0 <printf_>

    //Set all bitmap bits to 1
    for (uint64_t i = 0; i < pmm_info.bitmap_size; i++)
ffffffff80001802:	48 83 3d 76 96 00 00 	cmpq   $0x0,0x9676(%rip)        # ffffffff8000ae80 <pmm_info+0x20>
ffffffff80001809:	00 
ffffffff8000180a:	74 1c                	je     ffffffff80001828 <pmm_init+0x198>
ffffffff8000180c:	31 c0                	xor    %eax,%eax
ffffffff8000180e:	66 90                	xchg   %ax,%ax
        {
        pmm_info.bitmap[i] = 0xff;
ffffffff80001810:	48 8b 15 61 96 00 00 	mov    0x9661(%rip),%rdx        # ffffffff8000ae78 <pmm_info+0x18>
ffffffff80001817:	c6 04 02 ff          	movb   $0xff,(%rdx,%rax,1)
    for (uint64_t i = 0; i < pmm_info.bitmap_size; i++)
ffffffff8000181b:	48 83 c0 01          	add    $0x1,%rax
ffffffff8000181f:	48 39 05 5a 96 00 00 	cmp    %rax,0x965a(%rip)        # ffffffff8000ae80 <pmm_info+0x20>
ffffffff80001826:	77 e8                	ja     ffffffff80001810 <pmm_init+0x180>
    

    //printf("Number of MMAP Entries: %d\n", mmap_entries);

    //Iterate through the memory map again, unset bitmap for available memory
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80001828:	31 f6                	xor    %esi,%esi
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff8000182a:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff80001830:	eb 0f                	jmp    ffffffff80001841 <pmm_init+0x1b1>
ffffffff80001832:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80001838:	48 83 c6 01          	add    $0x1,%rsi
ffffffff8000183c:	48 39 de             	cmp    %rbx,%rsi
ffffffff8000183f:	74 69                	je     ffffffff800018aa <pmm_init+0x21a>
    {
        current_entry = &boot_info.tag_memmap->memmap[i];

        if(current_entry->type == 1)
ffffffff80001841:	48 8b 15 a8 95 00 00 	mov    0x95a8(%rip),%rdx        # ffffffff8000adf0 <boot_info+0x10>
ffffffff80001848:	48 8d 04 76          	lea    (%rsi,%rsi,2),%rax
ffffffff8000184c:	48 8d 04 c2          	lea    (%rdx,%rax,8),%rax
ffffffff80001850:	83 78 28 01          	cmpl   $0x1,0x28(%rax)
ffffffff80001854:	75 e2                	jne    ffffffff80001838 <pmm_init+0x1a8>
        {
            uint64_t pages = current_entry->length / 4096;
ffffffff80001856:	48 8b 50 20          	mov    0x20(%rax),%rdx
            uint64_t align = current_entry->base / 4096;
ffffffff8000185a:	48 8b 40 18          	mov    0x18(%rax),%rax
            uint64_t pages = current_entry->length / 4096;
ffffffff8000185e:	48 c1 ea 0c          	shr    $0xc,%rdx
            uint64_t align = current_entry->base / 4096;
ffffffff80001862:	48 c1 e8 0c          	shr    $0xc,%rax
            //printf("Index: %d  Pages: %d\n", align, pages);

            for(uint64_t j = 0; j < pages; j++)
ffffffff80001866:	48 85 d2             	test   %rdx,%rdx
ffffffff80001869:	74 cd                	je     ffffffff80001838 <pmm_init+0x1a8>
ffffffff8000186b:	48 01 c2             	add    %rax,%rdx
ffffffff8000186e:	66 90                	xchg   %ax,%ax
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80001870:	48 89 c7             	mov    %rax,%rdi
ffffffff80001873:	89 c1                	mov    %eax,%ecx
ffffffff80001875:	45 89 c1             	mov    %r8d,%r9d
ffffffff80001878:	48 c1 ef 03          	shr    $0x3,%rdi
ffffffff8000187c:	48 03 3d f5 95 00 00 	add    0x95f5(%rip),%rdi        # ffffffff8000ae78 <pmm_info+0x18>
ffffffff80001883:	83 e1 07             	and    $0x7,%ecx
ffffffff80001886:	41 d3 e1             	shl    %cl,%r9d
                //uint64_t bitindex = align % 8;
                //pmm_info.bitmap[byteindex] &= ~(1 << bitindex);
                
                bitmap_unset(pmm_info.bitmap, align);

                align++;                    //increment page index
ffffffff80001889:	48 83 c0 01          	add    $0x1,%rax
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff8000188d:	44 89 c9             	mov    %r9d,%ecx
ffffffff80001890:	f7 d1                	not    %ecx
ffffffff80001892:	20 0f                	and    %cl,(%rdi)
                pmm_info.usedpages--;       //decrement used page counter
ffffffff80001894:	48 83 2d cc 95 00 00 	subq   $0x1,0x95cc(%rip)        # ffffffff8000ae68 <pmm_info+0x8>
ffffffff8000189b:	01 
            for(uint64_t j = 0; j < pages; j++)
ffffffff8000189c:	48 39 d0             	cmp    %rdx,%rax
ffffffff8000189f:	75 cf                	jne    ffffffff80001870 <pmm_init+0x1e0>
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800018a1:	48 83 c6 01          	add    $0x1,%rsi
ffffffff800018a5:	48 39 de             	cmp    %rbx,%rsi
ffffffff800018a8:	75 97                	jne    ffffffff80001841 <pmm_init+0x1b1>
            }
        }
    }

    //Make certain the NULL page is unavailable
    bitmap_set(pmm_info.bitmap, 0);
ffffffff800018aa:	48 8b 05 c7 95 00 00 	mov    0x95c7(%rip),%rax        # ffffffff8000ae78 <pmm_info+0x18>
    pmm_info.usedpages++;

    printf("Available Pages: %d\n", (pmm_info.totalpages - pmm_info.usedpages));
ffffffff800018b1:	48 c7 c7 6c 52 00 80 	mov    $0xffffffff8000526c,%rdi
    bitmap[bit / 8] |= (1 << (bit % 8));
ffffffff800018b8:	80 08 01             	orb    $0x1,(%rax)
    pmm_info.usedpages++;
ffffffff800018bb:	48 8b 05 a6 95 00 00 	mov    0x95a6(%rip),%rax        # ffffffff8000ae68 <pmm_info+0x8>
    printf("Available Pages: %d\n", (pmm_info.totalpages - pmm_info.usedpages));
ffffffff800018c2:	48 8b 35 a7 95 00 00 	mov    0x95a7(%rip),%rsi        # ffffffff8000ae70 <pmm_info+0x10>
    pmm_info.usedpages++;
ffffffff800018c9:	48 83 c0 01          	add    $0x1,%rax
ffffffff800018cd:	48 89 05 94 95 00 00 	mov    %rax,0x9594(%rip)        # ffffffff8000ae68 <pmm_info+0x8>
    printf("Available Pages: %d\n", (pmm_info.totalpages - pmm_info.usedpages));
ffffffff800018d4:	48 29 c6             	sub    %rax,%rsi
ffffffff800018d7:	31 c0                	xor    %eax,%eax
ffffffff800018d9:	e8 d2 1e 00 00       	callq  ffffffff800037b0 <printf_>
    printf("PMM Initialized\n");

}
ffffffff800018de:	48 83 c4 08          	add    $0x8,%rsp
    printf("PMM Initialized\n");
ffffffff800018e2:	48 c7 c7 81 52 00 80 	mov    $0xffffffff80005281,%rdi
ffffffff800018e9:	31 c0                	xor    %eax,%eax
}
ffffffff800018eb:	5b                   	pop    %rbx
ffffffff800018ec:	5d                   	pop    %rbp
    printf("PMM Initialized\n");
ffffffff800018ed:	e9 be 1e 00 00       	jmpq   ffffffff800037b0 <printf_>
ffffffff800018f2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800018f9:	00 00 00 00 
ffffffff800018fd:	0f 1f 00             	nopl   (%rax)

ffffffff80001900 <pmm_allocpage>:


void* pmm_allocpage()
{
    if(pmm_info.usedpages >= pmm_info.totalpages)
ffffffff80001900:	48 8b 05 69 95 00 00 	mov    0x9569(%rip),%rax        # ffffffff8000ae70 <pmm_info+0x10>
ffffffff80001907:	48 39 05 5a 95 00 00 	cmp    %rax,0x955a(%rip)        # ffffffff8000ae68 <pmm_info+0x8>
{
ffffffff8000190e:	53                   	push   %rbx
    if(pmm_info.usedpages >= pmm_info.totalpages)
ffffffff8000190f:	0f 83 93 00 00 00    	jae    ffffffff800019a8 <pmm_allocpage+0xa8>
        return NULL;
    
    uint64_t index = get_first_unset(pmm_info.bitmap, pmm_info.bitmap_size);
ffffffff80001915:	48 8b 15 64 95 00 00 	mov    0x9564(%rip),%rdx        # ffffffff8000ae80 <pmm_info+0x20>
ffffffff8000191c:	48 8b 3d 55 95 00 00 	mov    0x9555(%rip),%rdi        # ffffffff8000ae78 <pmm_info+0x18>
    for(uint64_t i = 0; i < size; i++)
ffffffff80001923:	48 85 d2             	test   %rdx,%rdx
ffffffff80001926:	0f 84 80 00 00 00    	je     ffffffff800019ac <pmm_allocpage+0xac>
ffffffff8000192c:	31 f6                	xor    %esi,%esi
        if(bitmap[i] != 0xff)
ffffffff8000192e:	0f b6 0c 37          	movzbl (%rdi,%rsi,1),%ecx
ffffffff80001932:	80 f9 ff             	cmp    $0xff,%cl
ffffffff80001935:	74 11                	je     ffffffff80001948 <pmm_allocpage+0x48>
            for(uint64_t j = 0; j < 8; j++)
ffffffff80001937:	31 c0                	xor    %eax,%eax
                if(!(bitmap[i] & (1 << j)))
ffffffff80001939:	0f a3 c1             	bt     %eax,%ecx
ffffffff8000193c:	73 22                	jae    ffffffff80001960 <pmm_allocpage+0x60>
            for(uint64_t j = 0; j < 8; j++)
ffffffff8000193e:	48 83 c0 01          	add    $0x1,%rax
ffffffff80001942:	48 83 f8 08          	cmp    $0x8,%rax
ffffffff80001946:	75 f1                	jne    ffffffff80001939 <pmm_allocpage+0x39>
    for(uint64_t i = 0; i < size; i++)
ffffffff80001948:	48 83 c6 01          	add    $0x1,%rsi
ffffffff8000194c:	48 39 f2             	cmp    %rsi,%rdx
ffffffff8000194f:	75 dd                	jne    ffffffff8000192e <pmm_allocpage+0x2e>
ffffffff80001951:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff80001956:	31 db                	xor    %ebx,%ebx
ffffffff80001958:	31 d2                	xor    %edx,%edx
ffffffff8000195a:	eb 26                	jmp    ffffffff80001982 <pmm_allocpage+0x82>
ffffffff8000195c:	0f 1f 40 00          	nopl   0x0(%rax)
                    return (i * 8) + j;
ffffffff80001960:	48 8d 0c f0          	lea    (%rax,%rsi,8),%rcx
ffffffff80001964:	48 89 c8             	mov    %rcx,%rax
ffffffff80001967:	48 89 ca             	mov    %rcx,%rdx
ffffffff8000196a:	83 e1 07             	and    $0x7,%ecx
ffffffff8000196d:	48 c1 e8 03          	shr    $0x3,%rax
ffffffff80001971:	48 c1 e2 0c          	shl    $0xc,%rdx
ffffffff80001975:	48 01 c7             	add    %rax,%rdi
ffffffff80001978:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8000197d:	48 89 d3             	mov    %rdx,%rbx
ffffffff80001980:	d3 e0                	shl    %cl,%eax
    bitmap[bit / 8] |= (1 << (bit % 8));
ffffffff80001982:	08 07                	or     %al,(%rdi)
    
    bitmap_set(pmm_info.bitmap, index);

    pmm_info.usedpages++;

    DEBUG_MSG("PMM ALLOC: %p\n", (index * PAGE_SIZE));
ffffffff80001984:	48 c7 c6 92 52 00 80 	mov    $0xffffffff80005292,%rsi
ffffffff8000198b:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80001990:	31 c0                	xor    %eax,%eax
    pmm_info.usedpages++;
ffffffff80001992:	48 83 05 ce 94 00 00 	addq   $0x1,0x94ce(%rip)        # ffffffff8000ae68 <pmm_info+0x8>
ffffffff80001999:	01 
    DEBUG_MSG("PMM ALLOC: %p\n", (index * PAGE_SIZE));
ffffffff8000199a:	e8 e1 1f 00 00       	callq  ffffffff80003980 <serial_printf>

    return (void*)(index * PAGE_SIZE);
}
ffffffff8000199f:	48 89 d8             	mov    %rbx,%rax
ffffffff800019a2:	5b                   	pop    %rbx
ffffffff800019a3:	c3                   	retq   
ffffffff800019a4:	0f 1f 40 00          	nopl   0x0(%rax)
        return NULL;
ffffffff800019a8:	31 db                	xor    %ebx,%ebx
ffffffff800019aa:	eb f3                	jmp    ffffffff8000199f <pmm_allocpage+0x9f>
    for(uint64_t i = 0; i < size; i++)
ffffffff800019ac:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff800019b1:	31 db                	xor    %ebx,%ebx
ffffffff800019b3:	eb cd                	jmp    ffffffff80001982 <pmm_allocpage+0x82>
ffffffff800019b5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800019bc:	00 00 00 00 

ffffffff800019c0 <pmm_freepage>:
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800019c0:	48 89 fa             	mov    %rdi,%rdx


void pmm_freepage(void* page)
{
    uint64_t index = (uint64_t)page / PAGE_SIZE;
ffffffff800019c3:	48 c1 ef 0c          	shr    $0xc,%rdi
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800019c7:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff800019cc:	48 c1 ea 0f          	shr    $0xf,%rdx
ffffffff800019d0:	48 03 15 a1 94 00 00 	add    0x94a1(%rip),%rdx        # ffffffff8000ae78 <pmm_info+0x18>
ffffffff800019d7:	89 f9                	mov    %edi,%ecx
ffffffff800019d9:	83 e1 07             	and    $0x7,%ecx
ffffffff800019dc:	d3 e0                	shl    %cl,%eax
ffffffff800019de:	f7 d0                	not    %eax
ffffffff800019e0:	20 02                	and    %al,(%rdx)
    bitmap_unset(pmm_info.bitmap, index);
    pmm_info.usedpages--;
ffffffff800019e2:	48 83 2d 7e 94 00 00 	subq   $0x1,0x947e(%rip)        # ffffffff8000ae68 <pmm_info+0x8>
ffffffff800019e9:	01 
}
ffffffff800019ea:	c3                   	retq   
ffffffff800019eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff800019f0 <pmm_allocpages>:

void* pmm_allocpages(uint64_t count)
{
    if(pmm_info.usedpages >= pmm_info.totalpages)
ffffffff800019f0:	4c 8b 15 71 94 00 00 	mov    0x9471(%rip),%r10        # ffffffff8000ae68 <pmm_info+0x8>
ffffffff800019f7:	4c 3b 15 72 94 00 00 	cmp    0x9472(%rip),%r10        # ffffffff8000ae70 <pmm_info+0x10>
ffffffff800019fe:	73 73                	jae    ffffffff80001a73 <pmm_allocpages+0x83>
        return NULL;
    
    uint64_t index = get_first_unset(pmm_info.bitmap, pmm_info.bitmap_size);
ffffffff80001a00:	48 8b 05 79 94 00 00 	mov    0x9479(%rip),%rax        # ffffffff8000ae80 <pmm_info+0x20>
ffffffff80001a07:	4c 8b 05 6a 94 00 00 	mov    0x946a(%rip),%r8        # ffffffff8000ae78 <pmm_info+0x18>
    for(uint64_t i = 0; i < size; i++)
ffffffff80001a0e:	48 85 c0             	test   %rax,%rax
ffffffff80001a11:	74 28                	je     ffffffff80001a3b <pmm_allocpages+0x4b>
ffffffff80001a13:	31 f6                	xor    %esi,%esi
        if(bitmap[i] != 0xff)
ffffffff80001a15:	41 0f b6 0c 30       	movzbl (%r8,%rsi,1),%ecx
ffffffff80001a1a:	80 f9 ff             	cmp    $0xff,%cl
ffffffff80001a1d:	74 11                	je     ffffffff80001a30 <pmm_allocpages+0x40>
            for(uint64_t j = 0; j < 8; j++)
ffffffff80001a1f:	31 d2                	xor    %edx,%edx
                if(!(bitmap[i] & (1 << j)))
ffffffff80001a21:	0f a3 d1             	bt     %edx,%ecx
ffffffff80001a24:	73 5a                	jae    ffffffff80001a80 <pmm_allocpages+0x90>
            for(uint64_t j = 0; j < 8; j++)
ffffffff80001a26:	48 83 c2 01          	add    $0x1,%rdx
ffffffff80001a2a:	48 83 fa 08          	cmp    $0x8,%rdx
ffffffff80001a2e:	75 f1                	jne    ffffffff80001a21 <pmm_allocpages+0x31>
    for(uint64_t i = 0; i < size; i++)
ffffffff80001a30:	48 83 c6 01          	add    $0x1,%rsi
ffffffff80001a34:	48 39 f0             	cmp    %rsi,%rax
ffffffff80001a37:	75 dc                	jne    ffffffff80001a15 <pmm_allocpages+0x25>
    return 0;
ffffffff80001a39:	31 c0                	xor    %eax,%eax
    for(uint64_t i = 0; i < count; i++)
ffffffff80001a3b:	48 85 ff             	test   %rdi,%rdi
ffffffff80001a3e:	74 50                	je     ffffffff80001a90 <pmm_allocpages+0xa0>
ffffffff80001a40:	31 d2                	xor    %edx,%edx
    {
        if(bitmap_get(pmm_info.bitmap, i) == 1)
ffffffff80001a42:	41 f6 00 01          	testb  $0x1,(%r8)
    return bitmap[bit/8] & (1 << (bit & 8));
ffffffff80001a46:	41 b9 01 00 00 00    	mov    $0x1,%r9d
        if(bitmap_get(pmm_info.bitmap, i) == 1)
ffffffff80001a4c:	74 25                	je     ffffffff80001a73 <pmm_allocpages+0x83>
    for(uint64_t i = 0; i < count; i++)
ffffffff80001a4e:	48 83 c2 01          	add    $0x1,%rdx
ffffffff80001a52:	48 39 d7             	cmp    %rdx,%rdi
ffffffff80001a55:	74 39                	je     ffffffff80001a90 <pmm_allocpages+0xa0>
    return bitmap[bit/8] & (1 << (bit & 8));
ffffffff80001a57:	48 89 d1             	mov    %rdx,%rcx
ffffffff80001a5a:	45 89 cb             	mov    %r9d,%r11d
ffffffff80001a5d:	48 c1 e9 03          	shr    $0x3,%rcx
ffffffff80001a61:	41 0f b6 34 08       	movzbl (%r8,%rcx,1),%esi
ffffffff80001a66:	89 d1                	mov    %edx,%ecx
ffffffff80001a68:	83 e1 08             	and    $0x8,%ecx
ffffffff80001a6b:	41 d3 e3             	shl    %cl,%r11d
        if(bitmap_get(pmm_info.bitmap, i) == 1)
ffffffff80001a6e:	44 85 de             	test   %r11d,%esi
ffffffff80001a71:	75 db                	jne    ffffffff80001a4e <pmm_allocpages+0x5e>
        return NULL;
ffffffff80001a73:	31 c0                	xor    %eax,%eax
    }

    pmm_info.usedpages += count;

    return (void*)(index * PAGE_SIZE);
}
ffffffff80001a75:	c3                   	retq   
ffffffff80001a76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001a7d:	00 00 00 
                    return (i * 8) + j;
ffffffff80001a80:	48 8d 04 f2          	lea    (%rdx,%rsi,8),%rax
ffffffff80001a84:	eb b5                	jmp    ffffffff80001a3b <pmm_allocpages+0x4b>
ffffffff80001a86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001a8d:	00 00 00 
    pmm_info.usedpages += count;
ffffffff80001a90:	4c 01 d7             	add    %r10,%rdi
    return (void*)(index * PAGE_SIZE);
ffffffff80001a93:	48 c1 e0 0c          	shl    $0xc,%rax
    pmm_info.usedpages += count;
ffffffff80001a97:	48 89 3d ca 93 00 00 	mov    %rdi,0x93ca(%rip)        # ffffffff8000ae68 <pmm_info+0x8>
    return (void*)(index * PAGE_SIZE);
ffffffff80001a9e:	c3                   	retq   
ffffffff80001a9f:	90                   	nop

ffffffff80001aa0 <pmm_freepages>:

uint64_t pmm_freepages(void* page, uint64_t count)
{
    uint64_t pg = (uint64_t)page;

    for(uint64_t i=0; i < count; i++)
ffffffff80001aa0:	48 85 f6             	test   %rsi,%rsi
ffffffff80001aa3:	74 44                	je     ffffffff80001ae9 <pmm_freepages+0x49>
ffffffff80001aa5:	45 31 c0             	xor    %r8d,%r8d
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80001aa8:	41 b9 01 00 00 00    	mov    $0x1,%r9d
ffffffff80001aae:	66 90                	xchg   %ax,%ax
ffffffff80001ab0:	48 89 f8             	mov    %rdi,%rax
    uint64_t index = (uint64_t)page / PAGE_SIZE;
ffffffff80001ab3:	48 89 f9             	mov    %rdi,%rcx
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80001ab6:	44 89 ca             	mov    %r9d,%edx
ffffffff80001ab9:	48 c1 e8 0f          	shr    $0xf,%rax
ffffffff80001abd:	48 03 05 b4 93 00 00 	add    0x93b4(%rip),%rax        # ffffffff8000ae78 <pmm_info+0x18>
    uint64_t index = (uint64_t)page / PAGE_SIZE;
ffffffff80001ac4:	48 c1 e9 0c          	shr    $0xc,%rcx
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80001ac8:	83 e1 07             	and    $0x7,%ecx
    for(uint64_t i=0; i < count; i++)
ffffffff80001acb:	49 83 c0 01          	add    $0x1,%r8
    {
        pmm_freepage((void*)pg);
        pg += 0x1000;
ffffffff80001acf:	48 81 c7 00 10 00 00 	add    $0x1000,%rdi
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80001ad6:	d3 e2                	shl    %cl,%edx
ffffffff80001ad8:	f7 d2                	not    %edx
ffffffff80001ada:	20 10                	and    %dl,(%rax)
    pmm_info.usedpages--;
ffffffff80001adc:	48 83 2d 84 93 00 00 	subq   $0x1,0x9384(%rip)        # ffffffff8000ae68 <pmm_info+0x8>
ffffffff80001ae3:	01 
    for(uint64_t i=0; i < count; i++)
ffffffff80001ae4:	4c 39 c6             	cmp    %r8,%rsi
ffffffff80001ae7:	75 c7                	jne    ffffffff80001ab0 <pmm_freepages+0x10>
    }

    return 0;
}
ffffffff80001ae9:	31 c0                	xor    %eax,%eax
ffffffff80001aeb:	c3                   	retq   
ffffffff80001aec:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001af0 <pmm_get_free_memory>:

uint64_t pmm_get_free_memory()
{
    return (pmm_info.totalpages - pmm_info.usedpages) * PAGE_SIZE;
ffffffff80001af0:	48 8b 05 79 93 00 00 	mov    0x9379(%rip),%rax        # ffffffff8000ae70 <pmm_info+0x10>
ffffffff80001af7:	48 2b 05 6a 93 00 00 	sub    0x936a(%rip),%rax        # ffffffff8000ae68 <pmm_info+0x8>
ffffffff80001afe:	48 c1 e0 0c          	shl    $0xc,%rax
}
ffffffff80001b02:	c3                   	retq   
ffffffff80001b03:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001b0a:	00 00 00 00 
ffffffff80001b0e:	66 90                	xchg   %ax,%ax

ffffffff80001b10 <pmm_get_total_memory>:

uint64_t pmm_get_total_memory()
{   
    return (pmm_info.totalpages) * PAGE_SIZE;
ffffffff80001b10:	48 8b 05 59 93 00 00 	mov    0x9359(%rip),%rax        # ffffffff8000ae70 <pmm_info+0x10>
ffffffff80001b17:	48 c1 e0 0c          	shl    $0xc,%rax
ffffffff80001b1b:	c3                   	retq   
ffffffff80001b1c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001b20 <outb>:
#include <stdint.h>
#include <stddef.h>

void outb(uint16_t port, uint8_t val)
{
    asm volatile ( "outb %0, %1" : : "a"(val), "Nd"(port) );
ffffffff80001b20:	89 f0                	mov    %esi,%eax
ffffffff80001b22:	89 fa                	mov    %edi,%edx
ffffffff80001b24:	ee                   	out    %al,(%dx)
}
ffffffff80001b25:	c3                   	retq   
ffffffff80001b26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001b2d:	00 00 00 

ffffffff80001b30 <inb>:

uint8_t inb(uint16_t port)
{
    uint8_t ret;
    asm volatile ( "inb %1, %0"
ffffffff80001b30:	89 fa                	mov    %edi,%edx
ffffffff80001b32:	ec                   	in     (%dx),%al
                   : "=a"(ret)
                   : "Nd"(port) );
    return ret;
}
ffffffff80001b33:	c3                   	retq   
ffffffff80001b34:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001b3b:	00 00 00 00 
ffffffff80001b3f:	90                   	nop

ffffffff80001b40 <io_wait>:
    asm volatile ( "inb %1, %0"
ffffffff80001b40:	e4 80                	in     $0x80,%al

void io_wait()
{
    inb(0x80);
ffffffff80001b42:	c3                   	retq   
ffffffff80001b43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001b4a:	00 00 00 
ffffffff80001b4d:	0f 1f 00             	nopl   (%rax)

ffffffff80001b50 <fb_init>:



void fb_init()
{
    fb_info.base = boot_info.tag_framebuffer->framebuffer_addr;
ffffffff80001b50:	48 8b 15 a1 92 00 00 	mov    0x92a1(%rip),%rdx        # ffffffff8000adf8 <boot_info+0x18>
ffffffff80001b57:	48 8b 42 10          	mov    0x10(%rdx),%rax
    fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
    fb_info.width = boot_info.tag_framebuffer->framebuffer_width;
ffffffff80001b5b:	0f b7 4a 18          	movzwl 0x18(%rdx),%ecx
    fb_info.pitch = boot_info.tag_framebuffer->framebuffer_pitch;
ffffffff80001b5f:	0f b7 72 1c          	movzwl 0x1c(%rdx),%esi
    fb_info.base = boot_info.tag_framebuffer->framebuffer_addr;
ffffffff80001b63:	48 89 05 c6 92 00 00 	mov    %rax,0x92c6(%rip)        # ffffffff8000ae30 <fb_info>
    fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
ffffffff80001b6a:	0f b7 42 1a          	movzwl 0x1a(%rdx),%eax
    fb_info.bpp = boot_info.tag_framebuffer->framebuffer_bpp;
ffffffff80001b6e:	0f b7 52 1e          	movzwl 0x1e(%rdx),%edx
    fb_info.width = boot_info.tag_framebuffer->framebuffer_width;
ffffffff80001b72:	66 89 0d c1 92 00 00 	mov    %cx,0x92c1(%rip)        # ffffffff8000ae3a <fb_info+0xa>
    fb_info.pitch = boot_info.tag_framebuffer->framebuffer_pitch;
ffffffff80001b79:	66 89 35 bc 92 00 00 	mov    %si,0x92bc(%rip)        # ffffffff8000ae3c <fb_info+0xc>
    fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
ffffffff80001b80:	66 89 05 b1 92 00 00 	mov    %ax,0x92b1(%rip)        # ffffffff8000ae38 <fb_info+0x8>
    fb_info.max_pixels = fb_info.height * fb_info.width;
ffffffff80001b87:	0f af c1             	imul   %ecx,%eax
    fb_info.bpp = boot_info.tag_framebuffer->framebuffer_bpp;
ffffffff80001b8a:	66 89 15 ad 92 00 00 	mov    %dx,0x92ad(%rip)        # ffffffff8000ae3e <fb_info+0xe>
    fb_info.max_pixels = fb_info.height * fb_info.width;
ffffffff80001b91:	89 05 a9 92 00 00    	mov    %eax,0x92a9(%rip)        # ffffffff8000ae40 <fb_info+0x10>
    //printf("FB Base: %p", fb_info.base);
    //printf("FB Height: %d  FB Width: %d\n", fb_info.height, fb_info.width);
    //printf("FB BPP: %d   FB Pitch: %d\n", fb_info.bpp, fb_info.pitch);

    //fb_putpixel(100,100,FB_COLOR_WHITE);
}
ffffffff80001b97:	c3                   	retq   
ffffffff80001b98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80001b9f:	00 

ffffffff80001ba0 <fb_putpixel>:

void fb_putpixel(uint32_t x, uint32_t y, enum fb_color col)
{
    uint64_t index = y * (fb_info.pitch / (fb_info.bpp / 8)) + x;
ffffffff80001ba0:	0f b7 0d 97 92 00 00 	movzwl 0x9297(%rip),%ecx        # ffffffff8000ae3e <fb_info+0xe>
ffffffff80001ba7:	0f b7 05 8e 92 00 00 	movzwl 0x928e(%rip),%eax        # ffffffff8000ae3c <fb_info+0xc>
{
ffffffff80001bae:	41 89 d0             	mov    %edx,%r8d
    uint64_t index = y * (fb_info.pitch / (fb_info.bpp / 8)) + x;
ffffffff80001bb1:	31 d2                	xor    %edx,%edx
ffffffff80001bb3:	66 c1 e9 03          	shr    $0x3,%cx
ffffffff80001bb7:	66 f7 f1             	div    %cx
ffffffff80001bba:	0f b7 c0             	movzwl %ax,%eax
ffffffff80001bbd:	0f af c6             	imul   %esi,%eax
ffffffff80001bc0:	8d 14 38             	lea    (%rax,%rdi,1),%edx
    //if(index > fb_info.max_pixels) return;
    *((uint32_t*)fb_info.base + index) = col;
ffffffff80001bc3:	48 8b 05 66 92 00 00 	mov    0x9266(%rip),%rax        # ffffffff8000ae30 <fb_info>
ffffffff80001bca:	44 89 04 90          	mov    %r8d,(%rax,%rdx,4)
}
ffffffff80001bce:	c3                   	retq   
ffffffff80001bcf:	90                   	nop

ffffffff80001bd0 <fb_clearscreen>:

void fb_clearscreen(enum fb_color col)
{
    for (uint64_t i = 0; i < (fb_info.height*fb_info.width); i++)
ffffffff80001bd0:	0f b7 05 61 92 00 00 	movzwl 0x9261(%rip),%eax        # ffffffff8000ae38 <fb_info+0x8>
ffffffff80001bd7:	0f b7 15 5c 92 00 00 	movzwl 0x925c(%rip),%edx        # ffffffff8000ae3a <fb_info+0xa>
ffffffff80001bde:	0f af c2             	imul   %edx,%eax
ffffffff80001be1:	85 c0                	test   %eax,%eax
ffffffff80001be3:	48 63 c8             	movslq %eax,%rcx
ffffffff80001be6:	74 1f                	je     ffffffff80001c07 <fb_clearscreen+0x37>
    {
        *((uint32_t*)fb_info.base + i) = col;
ffffffff80001be8:	48 8b 15 41 92 00 00 	mov    0x9241(%rip),%rdx        # ffffffff8000ae30 <fb_info>
    for (uint64_t i = 0; i < (fb_info.height*fb_info.width); i++)
ffffffff80001bef:	31 c0                	xor    %eax,%eax
ffffffff80001bf1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff80001bf8:	48 83 c0 01          	add    $0x1,%rax
        *((uint32_t*)fb_info.base + i) = col;
ffffffff80001bfc:	89 3a                	mov    %edi,(%rdx)
ffffffff80001bfe:	48 83 c2 04          	add    $0x4,%rdx
    for (uint64_t i = 0; i < (fb_info.height*fb_info.width); i++)
ffffffff80001c02:	48 39 c8             	cmp    %rcx,%rax
ffffffff80001c05:	75 f1                	jne    ffffffff80001bf8 <fb_clearscreen+0x28>
    }
}
ffffffff80001c07:	f3 c3                	repz retq 
ffffffff80001c09:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80001c10 <fb_drawline>:

void fb_drawline(uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, enum fb_color col)
{

ffffffff80001c10:	f3 c3                	repz retq 
ffffffff80001c12:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001c19:	00 00 00 
ffffffff80001c1c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001c20 <console_input>:

    //write the output buffer to screen
}

void console_input(KEY_INFO_t key)
{
ffffffff80001c20:	89 f8                	mov    %edi,%eax
ffffffff80001c22:	0f b6 fc             	movzbl %ah,%edi
    con_input_buffer.index++;
ffffffff80001c25:	48 8b 05 c4 a2 00 00 	mov    0xa2c4(%rip),%rax        # ffffffff8000bef0 <con_input_buffer+0x10>
ffffffff80001c2c:	48 8d 50 01          	lea    0x1(%rax),%rdx
ffffffff80001c30:	48 89 15 b9 a2 00 00 	mov    %rdx,0xa2b9(%rip)        # ffffffff8000bef0 <con_input_buffer+0x10>
    con_input_buffer.buffer[con_input_buffer.index] = key.ascii;
ffffffff80001c37:	48 8b 15 a2 a2 00 00 	mov    0xa2a2(%rip),%rdx        # ffffffff8000bee0 <con_input_buffer>
ffffffff80001c3e:	40 88 7c 02 01       	mov    %dil,0x1(%rdx,%rax,1)
    

    con_output_buffer.buffer[con_output_buffer.index] = key.ascii;
ffffffff80001c43:	48 8b 05 86 a2 00 00 	mov    0xa286(%rip),%rax        # ffffffff8000bed0 <con_output_buffer+0x10>
ffffffff80001c4a:	48 8b 15 6f a2 00 00 	mov    0xa26f(%rip),%rdx        # ffffffff8000bec0 <con_output_buffer>
ffffffff80001c51:	40 88 3c 02          	mov    %dil,(%rdx,%rax,1)
    con_output_buffer.index++;
ffffffff80001c55:	48 8b 05 74 a2 00 00 	mov    0xa274(%rip),%rax        # ffffffff8000bed0 <con_output_buffer+0x10>
ffffffff80001c5c:	48 8d 50 01          	lea    0x1(%rax),%rdx
ffffffff80001c60:	48 89 15 69 a2 00 00 	mov    %rdx,0xa269(%rip)        # ffffffff8000bed0 <con_output_buffer+0x10>
    con_output_buffer.buffer[con_output_buffer.index] = 0x00;
ffffffff80001c67:	48 8b 15 52 a2 00 00 	mov    0xa252(%rip),%rdx        # ffffffff8000bec0 <con_output_buffer>
ffffffff80001c6e:	c6 44 02 01 00       	movb   $0x0,0x1(%rdx,%rax,1)
    return;
ffffffff80001c73:	c3                   	retq   
ffffffff80001c74:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001c7b:	00 00 00 00 
ffffffff80001c7f:	90                   	nop

ffffffff80001c80 <putchar>:
    switch(c)
ffffffff80001c80:	40 80 ff 0a          	cmp    $0xa,%dil
ffffffff80001c84:	0f 84 28 01 00 00    	je     ffffffff80001db2 <putchar+0x132>
ffffffff80001c8a:	40 80 ff 0d          	cmp    $0xd,%dil
ffffffff80001c8e:	0f 84 ed 00 00 00    	je     ffffffff80001d81 <putchar+0x101>
ffffffff80001c94:	40 80 ff 09          	cmp    $0x9,%dil
ffffffff80001c98:	0f 84 be 00 00 00    	je     ffffffff80001d5c <putchar+0xdc>
{
ffffffff80001c9e:	41 57                	push   %r15
ffffffff80001ca0:	41 56                	push   %r14
ffffffff80001ca2:	89 f8                	mov    %edi,%eax
ffffffff80001ca4:	41 55                	push   %r13
ffffffff80001ca6:	41 54                	push   %r12
    uint8_t* glyph = (uint8_t*)&_binary_zapl16_psf_start + 4 + (c * PSF1_FONT_HEIGHT);
ffffffff80001ca8:	48 c1 e0 04          	shl    $0x4,%rax
{
ffffffff80001cac:	55                   	push   %rbp
ffffffff80001cad:	53                   	push   %rbx
    uint8_t* glyph = (uint8_t*)&_binary_zapl16_psf_start + 4 + (c * PSF1_FONT_HEIGHT);
ffffffff80001cae:	25 f0 0f 00 00       	and    $0xff0,%eax
ffffffff80001cb3:	4c 8d a8 24 79 00 80 	lea    -0x7fff86dc(%rax),%r13
ffffffff80001cba:	48 05 34 79 00 80    	add    $0xffffffff80007934,%rax
{
ffffffff80001cc0:	48 83 ec 18          	sub    $0x18,%rsp
    console_drawchar(c, console_info.cursor_x, console_info.cursor_y, console_info.foreground_color, console_info.background_color);
ffffffff80001cc4:	8b 0d 3e a2 00 00    	mov    0xa23e(%rip),%ecx        # ffffffff8000bf08 <console_info+0x8>
ffffffff80001cca:	0f b7 1d 41 a2 00 00 	movzwl 0xa241(%rip),%ebx        # ffffffff8000bf12 <console_info+0x12>
ffffffff80001cd1:	44 8b 25 34 a2 00 00 	mov    0xa234(%rip),%r12d        # ffffffff8000bf0c <console_info+0xc>
ffffffff80001cd8:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff80001cdd:	89 0c 24             	mov    %ecx,(%rsp)
ffffffff80001ce0:	0f b7 0d 29 a2 00 00 	movzwl 0xa229(%rip),%ecx        # ffffffff8000bf10 <console_info+0x10>
ffffffff80001ce7:	8d 69 08             	lea    0x8(%rcx),%ebp
ffffffff80001cea:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
ffffffff80001cee:	66 90                	xchg   %ax,%ax
        row = glyph[i];
ffffffff80001cf0:	45 0f b6 75 00       	movzbl 0x0(%r13),%r14d
ffffffff80001cf5:	44 8b 7c 24 04       	mov    0x4(%rsp),%r15d
ffffffff80001cfa:	eb 1d                	jmp    ffffffff80001d19 <putchar+0x99>
ffffffff80001cfc:	0f 1f 40 00          	nopl   0x0(%rax)
                fb_putpixel(x+j, y+i, background);
ffffffff80001d00:	44 89 ff             	mov    %r15d,%edi
ffffffff80001d03:	44 89 e2             	mov    %r12d,%edx
ffffffff80001d06:	89 de                	mov    %ebx,%esi
ffffffff80001d08:	41 83 c7 01          	add    $0x1,%r15d
            row = row << 1;
ffffffff80001d0c:	45 01 f6             	add    %r14d,%r14d
                fb_putpixel(x+j, y+i, background);
ffffffff80001d0f:	e8 8c fe ff ff       	callq  ffffffff80001ba0 <fb_putpixel>
        for (uint32_t j = 0; j < 8; j++)
ffffffff80001d14:	44 39 fd             	cmp    %r15d,%ebp
ffffffff80001d17:	74 1e                	je     ffffffff80001d37 <putchar+0xb7>
            if(row & 0x80)
ffffffff80001d19:	45 84 f6             	test   %r14b,%r14b
ffffffff80001d1c:	79 e2                	jns    ffffffff80001d00 <putchar+0x80>
                fb_putpixel(x+j, y+i, foreground);
ffffffff80001d1e:	8b 14 24             	mov    (%rsp),%edx
ffffffff80001d21:	44 89 ff             	mov    %r15d,%edi
ffffffff80001d24:	89 de                	mov    %ebx,%esi
ffffffff80001d26:	41 83 c7 01          	add    $0x1,%r15d
            row = row << 1;
ffffffff80001d2a:	45 01 f6             	add    %r14d,%r14d
                fb_putpixel(x+j, y+i, foreground);
ffffffff80001d2d:	e8 6e fe ff ff       	callq  ffffffff80001ba0 <fb_putpixel>
        for (uint32_t j = 0; j < 8; j++)
ffffffff80001d32:	44 39 fd             	cmp    %r15d,%ebp
ffffffff80001d35:	75 e2                	jne    ffffffff80001d19 <putchar+0x99>
ffffffff80001d37:	49 83 c5 01          	add    $0x1,%r13
ffffffff80001d3b:	83 c3 01             	add    $0x1,%ebx
    for (uint32_t i = 0; i < 16; i++)
ffffffff80001d3e:	4c 39 6c 24 08       	cmp    %r13,0x8(%rsp)
ffffffff80001d43:	75 ab                	jne    ffffffff80001cf0 <putchar+0x70>
    console_info.cursor_x += 8;
ffffffff80001d45:	66 83 05 c3 a1 00 00 	addw   $0x8,0xa1c3(%rip)        # ffffffff8000bf10 <console_info+0x10>
ffffffff80001d4c:	08 
}
ffffffff80001d4d:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80001d51:	5b                   	pop    %rbx
ffffffff80001d52:	5d                   	pop    %rbp
ffffffff80001d53:	41 5c                	pop    %r12
ffffffff80001d55:	41 5d                	pop    %r13
ffffffff80001d57:	41 5e                	pop    %r14
ffffffff80001d59:	41 5f                	pop    %r15
ffffffff80001d5b:	c3                   	retq   
            if((console_info.cursor_x += (PSF1_FONT_WIDTH * 4)) < fb_info.width)
ffffffff80001d5c:	0f b7 05 ad a1 00 00 	movzwl 0xa1ad(%rip),%eax        # ffffffff8000bf10 <console_info+0x10>
ffffffff80001d63:	0f b7 15 d0 90 00 00 	movzwl 0x90d0(%rip),%edx        # ffffffff8000ae3a <fb_info+0xa>
ffffffff80001d6a:	8d 48 20             	lea    0x20(%rax),%ecx
ffffffff80001d6d:	66 39 d1             	cmp    %dx,%cx
ffffffff80001d70:	0f 83 4f 01 00 00    	jae    ffffffff80001ec5 <putchar+0x245>
                console_info.cursor_x += (PSF1_FONT_WIDTH * 4);
ffffffff80001d76:	83 c0 40             	add    $0x40,%eax
ffffffff80001d79:	66 89 05 90 a1 00 00 	mov    %ax,0xa190(%rip)        # ffffffff8000bf10 <console_info+0x10>
                return;
ffffffff80001d80:	c3                   	retq   
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001d81:	0f b7 05 8a a1 00 00 	movzwl 0xa18a(%rip),%eax        # ffffffff8000bf12 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001d88:	0f b7 15 a9 90 00 00 	movzwl 0x90a9(%rip),%edx        # ffffffff8000ae38 <fb_info+0x8>
    console_info.cursor_x = 0;
ffffffff80001d8f:	31 f6                	xor    %esi,%esi
ffffffff80001d91:	66 89 35 78 a1 00 00 	mov    %si,0xa178(%rip)        # ffffffff8000bf10 <console_info+0x10>
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001d98:	83 c0 10             	add    $0x10,%eax
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001d9b:	8d 4a f1             	lea    -0xf(%rdx),%ecx
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001d9e:	66 89 05 6d a1 00 00 	mov    %ax,0xa16d(%rip)        # ffffffff8000bf12 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001da5:	0f b7 c0             	movzwl %ax,%eax
ffffffff80001da8:	39 c1                	cmp    %eax,%ecx
ffffffff80001daa:	0f 8e 9d 00 00 00    	jle    ffffffff80001e4d <putchar+0x1cd>
ffffffff80001db0:	f3 c3                	repz retq 
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001db2:	0f b7 05 59 a1 00 00 	movzwl 0xa159(%rip),%eax        # ffffffff8000bf12 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001db9:	0f b7 15 78 90 00 00 	movzwl 0x9078(%rip),%edx        # ffffffff8000ae38 <fb_info+0x8>
    console_info.cursor_x = 0;
ffffffff80001dc0:	31 ff                	xor    %edi,%edi
ffffffff80001dc2:	66 89 3d 47 a1 00 00 	mov    %di,0xa147(%rip)        # ffffffff8000bf10 <console_info+0x10>
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001dc9:	83 c0 10             	add    $0x10,%eax
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001dcc:	8d 4a f1             	lea    -0xf(%rdx),%ecx
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001dcf:	66 89 05 3c a1 00 00 	mov    %ax,0xa13c(%rip)        # ffffffff8000bf12 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001dd6:	0f b7 c0             	movzwl %ax,%eax
ffffffff80001dd9:	39 c1                	cmp    %eax,%ecx
ffffffff80001ddb:	7f d3                	jg     ffffffff80001db0 <putchar+0x130>
    start_index = fb_info.width * 16 * 4;
ffffffff80001ddd:	0f b7 05 56 90 00 00 	movzwl 0x9056(%rip),%eax        # ffffffff8000ae3a <fb_info+0xa>
    uint32_t* base = (uint32_t*)fb_info.base;
ffffffff80001de4:	4c 8b 05 45 90 00 00 	mov    0x9045(%rip),%r8        # ffffffff8000ae30 <fb_info>
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff80001deb:	0f af d0             	imul   %eax,%edx
    start_index = fb_info.width * 16 * 4;
ffffffff80001dee:	89 c1                	mov    %eax,%ecx
ffffffff80001df0:	c1 e1 06             	shl    $0x6,%ecx
ffffffff80001df3:	48 63 c9             	movslq %ecx,%rcx
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff80001df6:	48 63 c2             	movslq %edx,%rax
    end_index = fb_info.height * fb_info.width - 1;
ffffffff80001df9:	83 ea 01             	sub    $0x1,%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001dfc:	48 29 c8             	sub    %rcx,%rax
    end_index = fb_info.height * fb_info.width - 1;
ffffffff80001dff:	48 63 d2             	movslq %edx,%rdx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001e02:	48 89 c7             	mov    %rax,%rdi
ffffffff80001e05:	74 20                	je     ffffffff80001e27 <putchar+0x1a7>
ffffffff80001e07:	4d 8d 0c 80          	lea    (%r8,%rax,4),%r9
ffffffff80001e0b:	48 c1 e1 02          	shl    $0x2,%rcx
ffffffff80001e0f:	4c 89 c0             	mov    %r8,%rax
ffffffff80001e12:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        base[i] = base[start_index + i];
ffffffff80001e18:	8b 34 08             	mov    (%rax,%rcx,1),%esi
ffffffff80001e1b:	48 83 c0 04          	add    $0x4,%rax
ffffffff80001e1f:	89 70 fc             	mov    %esi,-0x4(%rax)
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001e22:	4c 39 c8             	cmp    %r9,%rax
ffffffff80001e25:	75 f1                	jne    ffffffff80001e18 <putchar+0x198>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001e27:	48 8d 47 01          	lea    0x1(%rdi),%rax
ffffffff80001e2b:	48 39 c2             	cmp    %rax,%rdx
ffffffff80001e2e:	76 80                	jbe    ffffffff80001db0 <putchar+0x130>
        base[i] = console_info.background_color;
ffffffff80001e30:	8b 0d d6 a0 00 00    	mov    0xa0d6(%rip),%ecx        # ffffffff8000bf0c <console_info+0xc>
ffffffff80001e36:	49 8d 04 80          	lea    (%r8,%rax,4),%rax
ffffffff80001e3a:	49 8d 14 90          	lea    (%r8,%rdx,4),%rdx
ffffffff80001e3e:	66 90                	xchg   %ax,%ax
ffffffff80001e40:	89 08                	mov    %ecx,(%rax)
ffffffff80001e42:	48 83 c0 04          	add    $0x4,%rax
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001e46:	48 39 c2             	cmp    %rax,%rdx
ffffffff80001e49:	75 f5                	jne    ffffffff80001e40 <putchar+0x1c0>
ffffffff80001e4b:	f3 c3                	repz retq 
    start_index = fb_info.width * 16 * 4;
ffffffff80001e4d:	0f b7 05 e6 8f 00 00 	movzwl 0x8fe6(%rip),%eax        # ffffffff8000ae3a <fb_info+0xa>
    uint32_t* base = (uint32_t*)fb_info.base;
ffffffff80001e54:	4c 8b 05 d5 8f 00 00 	mov    0x8fd5(%rip),%r8        # ffffffff8000ae30 <fb_info>
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff80001e5b:	0f af d0             	imul   %eax,%edx
    start_index = fb_info.width * 16 * 4;
ffffffff80001e5e:	89 c1                	mov    %eax,%ecx
ffffffff80001e60:	c1 e1 06             	shl    $0x6,%ecx
ffffffff80001e63:	48 63 c9             	movslq %ecx,%rcx
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff80001e66:	48 63 c2             	movslq %edx,%rax
    end_index = fb_info.height * fb_info.width - 1;
ffffffff80001e69:	83 ea 01             	sub    $0x1,%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001e6c:	48 29 c8             	sub    %rcx,%rax
    end_index = fb_info.height * fb_info.width - 1;
ffffffff80001e6f:	48 63 d2             	movslq %edx,%rdx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001e72:	48 89 c7             	mov    %rax,%rdi
ffffffff80001e75:	74 20                	je     ffffffff80001e97 <putchar+0x217>
ffffffff80001e77:	4d 8d 0c 80          	lea    (%r8,%rax,4),%r9
ffffffff80001e7b:	48 c1 e1 02          	shl    $0x2,%rcx
ffffffff80001e7f:	4c 89 c0             	mov    %r8,%rax
ffffffff80001e82:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        base[i] = base[start_index + i];
ffffffff80001e88:	8b 34 08             	mov    (%rax,%rcx,1),%esi
ffffffff80001e8b:	48 83 c0 04          	add    $0x4,%rax
ffffffff80001e8f:	89 70 fc             	mov    %esi,-0x4(%rax)
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001e92:	4c 39 c8             	cmp    %r9,%rax
ffffffff80001e95:	75 f1                	jne    ffffffff80001e88 <putchar+0x208>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001e97:	48 8d 47 01          	lea    0x1(%rdi),%rax
ffffffff80001e9b:	48 39 c2             	cmp    %rax,%rdx
ffffffff80001e9e:	0f 86 0c ff ff ff    	jbe    ffffffff80001db0 <putchar+0x130>
        base[i] = console_info.background_color;
ffffffff80001ea4:	8b 0d 62 a0 00 00    	mov    0xa062(%rip),%ecx        # ffffffff8000bf0c <console_info+0xc>
ffffffff80001eaa:	49 8d 04 80          	lea    (%r8,%rax,4),%rax
ffffffff80001eae:	49 8d 14 90          	lea    (%r8,%rdx,4),%rdx
ffffffff80001eb2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff80001eb8:	89 08                	mov    %ecx,(%rax)
ffffffff80001eba:	48 83 c0 04          	add    $0x4,%rax
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001ebe:	48 39 d0             	cmp    %rdx,%rax
ffffffff80001ec1:	75 f5                	jne    ffffffff80001eb8 <putchar+0x238>
ffffffff80001ec3:	f3 c3                	repz retq 
    console_info.cursor_x = 0;
ffffffff80001ec5:	31 c9                	xor    %ecx,%ecx
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001ec7:	0f b7 05 44 a0 00 00 	movzwl 0xa044(%rip),%eax        # ffffffff8000bf12 <console_info+0x12>
    console_info.cursor_x = 0;
ffffffff80001ece:	66 89 0d 3b a0 00 00 	mov    %cx,0xa03b(%rip)        # ffffffff8000bf10 <console_info+0x10>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001ed5:	0f b7 0d 5c 8f 00 00 	movzwl 0x8f5c(%rip),%ecx        # ffffffff8000ae38 <fb_info+0x8>
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001edc:	83 c0 10             	add    $0x10,%eax
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001edf:	8d 71 f1             	lea    -0xf(%rcx),%esi
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001ee2:	66 89 05 29 a0 00 00 	mov    %ax,0xa029(%rip)        # ffffffff8000bf12 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001ee9:	0f b7 c0             	movzwl %ax,%eax
ffffffff80001eec:	39 c6                	cmp    %eax,%esi
ffffffff80001eee:	7e 0d                	jle    ffffffff80001efd <putchar+0x27d>
                console_info.cursor_x += (PSF1_FONT_WIDTH * 4);
ffffffff80001ef0:	b8 20 00 00 00       	mov    $0x20,%eax
ffffffff80001ef5:	66 89 05 14 a0 00 00 	mov    %ax,0xa014(%rip)        # ffffffff8000bf10 <console_info+0x10>
ffffffff80001efc:	c3                   	retq   
    start_index = fb_info.width * 16 * 4;
ffffffff80001efd:	89 d0                	mov    %edx,%eax
    uint32_t* base = (uint32_t*)fb_info.base;
ffffffff80001eff:	48 8b 3d 2a 8f 00 00 	mov    0x8f2a(%rip),%rdi        # ffffffff8000ae30 <fb_info>
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff80001f06:	0f af d1             	imul   %ecx,%edx
    start_index = fb_info.width * 16 * 4;
ffffffff80001f09:	c1 e0 06             	shl    $0x6,%eax
ffffffff80001f0c:	48 98                	cltq   
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff80001f0e:	48 63 f2             	movslq %edx,%rsi
    end_index = fb_info.height * fb_info.width - 1;
ffffffff80001f11:	83 ea 01             	sub    $0x1,%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001f14:	48 29 c6             	sub    %rax,%rsi
    end_index = fb_info.height * fb_info.width - 1;
ffffffff80001f17:	48 63 d2             	movslq %edx,%rdx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001f1a:	74 20                	je     ffffffff80001f3c <putchar+0x2bc>
ffffffff80001f1c:	4c 8d 0c b7          	lea    (%rdi,%rsi,4),%r9
ffffffff80001f20:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
ffffffff80001f27:	00 
ffffffff80001f28:	48 89 f8             	mov    %rdi,%rax
        base[i] = base[start_index + i];
ffffffff80001f2b:	44 8b 04 01          	mov    (%rcx,%rax,1),%r8d
ffffffff80001f2f:	48 83 c0 04          	add    $0x4,%rax
ffffffff80001f33:	44 89 40 fc          	mov    %r8d,-0x4(%rax)
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001f37:	49 39 c1             	cmp    %rax,%r9
ffffffff80001f3a:	75 ef                	jne    ffffffff80001f2b <putchar+0x2ab>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001f3c:	48 8d 46 01          	lea    0x1(%rsi),%rax
ffffffff80001f40:	48 39 c2             	cmp    %rax,%rdx
ffffffff80001f43:	76 ab                	jbe    ffffffff80001ef0 <putchar+0x270>
        base[i] = console_info.background_color;
ffffffff80001f45:	8b 0d c1 9f 00 00    	mov    0x9fc1(%rip),%ecx        # ffffffff8000bf0c <console_info+0xc>
ffffffff80001f4b:	48 8d 04 87          	lea    (%rdi,%rax,4),%rax
ffffffff80001f4f:	48 8d 14 97          	lea    (%rdi,%rdx,4),%rdx
ffffffff80001f53:	89 08                	mov    %ecx,(%rax)
ffffffff80001f55:	48 83 c0 04          	add    $0x4,%rax
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001f59:	48 39 d0             	cmp    %rdx,%rax
ffffffff80001f5c:	75 f5                	jne    ffffffff80001f53 <putchar+0x2d3>
ffffffff80001f5e:	eb 90                	jmp    ffffffff80001ef0 <putchar+0x270>

ffffffff80001f60 <putstring>:
{
ffffffff80001f60:	53                   	push   %rbx
ffffffff80001f61:	48 89 fb             	mov    %rdi,%rbx
    while(*str)
ffffffff80001f64:	0f b6 3f             	movzbl (%rdi),%edi
ffffffff80001f67:	40 84 ff             	test   %dil,%dil
ffffffff80001f6a:	74 15                	je     ffffffff80001f81 <putstring+0x21>
ffffffff80001f6c:	0f 1f 40 00          	nopl   0x0(%rax)
        str++;
ffffffff80001f70:	48 83 c3 01          	add    $0x1,%rbx
        putchar(*str);
ffffffff80001f74:	e8 07 fd ff ff       	callq  ffffffff80001c80 <putchar>
    while(*str)
ffffffff80001f79:	0f b6 3b             	movzbl (%rbx),%edi
ffffffff80001f7c:	40 84 ff             	test   %dil,%dil
ffffffff80001f7f:	75 ef                	jne    ffffffff80001f70 <putstring+0x10>
}
ffffffff80001f81:	5b                   	pop    %rbx
ffffffff80001f82:	c3                   	retq   
ffffffff80001f83:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001f8a:	00 00 00 00 
ffffffff80001f8e:	66 90                	xchg   %ax,%ax

ffffffff80001f90 <console_init>:
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80001f90:	0f b7 05 a1 8e 00 00 	movzwl 0x8ea1(%rip),%eax        # ffffffff8000ae38 <fb_info+0x8>
    uint64_t index = y * fb_info.width;
ffffffff80001f97:	0f b7 3d 9c 8e 00 00 	movzwl 0x8e9c(%rip),%edi        # ffffffff8000ae3a <fb_info+0xa>
    console_info.font = (struct PSF1_FONT*)&_binary_zapl16_psf_start;
ffffffff80001f9e:	48 c7 05 6f 9f 00 00 	movq   $0xffffffff80007920,0x9f6f(%rip)        # ffffffff8000bf18 <console_info+0x18>
ffffffff80001fa5:	20 79 00 80 
    console_info.foreground_color = FB_COLOR_WHITE;
ffffffff80001fa9:	c7 05 55 9f 00 00 ff 	movl   $0xffffffff,0x9f55(%rip)        # ffffffff8000bf08 <console_info+0x8>
ffffffff80001fb0:	ff ff ff 
    console_info.background_color = FB_COLOR_BLACK;
ffffffff80001fb3:	c7 05 4f 9f 00 00 00 	movl   $0xff000000,0x9f4f(%rip)        # ffffffff8000bf0c <console_info+0xc>
ffffffff80001fba:	00 00 ff 
    console_info.cursor_x = 0;
ffffffff80001fbd:	c7 05 49 9f 00 00 00 	movl   $0x0,0x9f49(%rip)        # ffffffff8000bf10 <console_info+0x10>
ffffffff80001fc4:	00 00 00 
    con_output_buffer.buffer = console_buffer;
ffffffff80001fc7:	48 c7 05 ee 9e 00 00 	movq   $0xffffffff8000aec0,0x9eee(%rip)        # ffffffff8000bec0 <con_output_buffer>
ffffffff80001fce:	c0 ae 00 80 
    con_output_buffer.buffer_size = sizeof(console_buffer);
ffffffff80001fd2:	48 c7 05 eb 9e 00 00 	movq   $0x1000,0x9eeb(%rip)        # ffffffff8000bec8 <con_output_buffer+0x8>
ffffffff80001fd9:	00 10 00 00 
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80001fdd:	89 c2                	mov    %eax,%edx
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80001fdf:	66 c1 e8 02          	shr    $0x2,%ax
    con_output_buffer.index = 0;
ffffffff80001fe3:	48 c7 05 e2 9e 00 00 	movq   $0x0,0x9ee2(%rip)        # ffffffff8000bed0 <con_output_buffer+0x10>
ffffffff80001fea:	00 00 00 00 
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80001fee:	0f b7 c0             	movzwl %ax,%eax
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80001ff1:	66 c1 ea 04          	shr    $0x4,%dx
    con_input_buffer.buffer = cmd_buffer;
ffffffff80001ff5:	48 c7 05 e0 9e 00 00 	movq   $0xffffffff8000bf40,0x9ee0(%rip)        # ffffffff8000bee0 <con_input_buffer>
ffffffff80001ffc:	40 bf 00 80 
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80002000:	8d 04 40             	lea    (%rax,%rax,2),%eax
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80002003:	0f b7 d2             	movzwl %dx,%edx
    con_input_buffer.buffer_size = sizeof(cmd_buffer);
ffffffff80002006:	48 c7 05 d7 9e 00 00 	movq   $0x100,0x9ed7(%rip)        # ffffffff8000bee8 <con_input_buffer+0x8>
ffffffff8000200d:	00 01 00 00 
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80002011:	89 15 ed 9e 00 00    	mov    %edx,0x9eed(%rip)        # ffffffff8000bf04 <console_info+0x4>
    uint64_t index = y * fb_info.width;
ffffffff80002017:	48 89 f9             	mov    %rdi,%rcx
    console_draw_hline(console_info.start_pos, FB_COLOR_YELLOW);
ffffffff8000201a:	48 63 d0             	movslq %eax,%rdx
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff8000201d:	89 05 dd 9e 00 00    	mov    %eax,0x9edd(%rip)        # ffffffff8000bf00 <console_info>
    uint64_t index = y * fb_info.width;
ffffffff80002023:	48 0f af d7          	imul   %rdi,%rdx
    for(int i = 0; i < fb_info.width; i++)
ffffffff80002027:	66 85 ff             	test   %di,%di
ffffffff8000202a:	74 53                	je     ffffffff8000207f <console_init+0xef>
        *((uint32_t*)fb_info.base + index + i) = color;
ffffffff8000202c:	48 8b 35 fd 8d 00 00 	mov    0x8dfd(%rip),%rsi        # ffffffff8000ae30 <fb_info>
ffffffff80002033:	83 e9 01             	sub    $0x1,%ecx
ffffffff80002036:	4c 8d 46 04          	lea    0x4(%rsi),%r8
ffffffff8000203a:	48 8d 04 96          	lea    (%rsi,%rdx,4),%rax
ffffffff8000203e:	48 01 ca             	add    %rcx,%rdx
ffffffff80002041:	49 8d 14 90          	lea    (%r8,%rdx,4),%rdx
ffffffff80002045:	0f 1f 00             	nopl   (%rax)
ffffffff80002048:	c7 00 00 ff ff ff    	movl   $0xffffff00,(%rax)
ffffffff8000204e:	48 83 c0 04          	add    $0x4,%rax
    for(int i = 0; i < fb_info.width; i++)
ffffffff80002052:	48 39 d0             	cmp    %rdx,%rax
ffffffff80002055:	75 f1                	jne    ffffffff80002048 <console_init+0xb8>
    console_draw_hline(console_info.start_pos + 1, FB_COLOR_YELLOW);
ffffffff80002057:	8b 05 a3 9e 00 00    	mov    0x9ea3(%rip),%eax        # ffffffff8000bf00 <console_info>
ffffffff8000205d:	8d 50 01             	lea    0x1(%rax),%edx
    uint64_t index = y * fb_info.width;
ffffffff80002060:	48 0f af d7          	imul   %rdi,%rdx
ffffffff80002064:	48 01 d1             	add    %rdx,%rcx
ffffffff80002067:	48 8d 04 96          	lea    (%rsi,%rdx,4),%rax
ffffffff8000206b:	49 8d 14 88          	lea    (%r8,%rcx,4),%rdx
ffffffff8000206f:	90                   	nop
        *((uint32_t*)fb_info.base + index + i) = color;
ffffffff80002070:	c7 00 00 ff ff ff    	movl   $0xffffff00,(%rax)
ffffffff80002076:	48 83 c0 04          	add    $0x4,%rax
    for(int i = 0; i < fb_info.width; i++)
ffffffff8000207a:	48 39 c2             	cmp    %rax,%rdx
ffffffff8000207d:	75 f1                	jne    ffffffff80002070 <console_init+0xe0>
    kbd_set_target(console_input);
ffffffff8000207f:	48 c7 c7 20 1c 00 80 	mov    $0xffffffff80001c20,%rdi
ffffffff80002086:	e9 75 02 00 00       	jmpq   ffffffff80002300 <kbd_set_target>
ffffffff8000208b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80002090 <console_exec>:
    for(int i = console_info.start_pos + (fb_info.width * 2); i < (fb_info.height * fb_info.width); i++)
ffffffff80002090:	0f b7 05 a3 8d 00 00 	movzwl 0x8da3(%rip),%eax        # ffffffff8000ae3a <fb_info+0xa>
ffffffff80002097:	8b 15 63 9e 00 00    	mov    0x9e63(%rip),%edx        # ffffffff8000bf00 <console_info>
ffffffff8000209d:	8d 34 42             	lea    (%rdx,%rax,2),%esi
ffffffff800020a0:	0f b7 15 91 8d 00 00 	movzwl 0x8d91(%rip),%edx        # ffffffff8000ae38 <fb_info+0x8>
ffffffff800020a7:	0f af d0             	imul   %eax,%edx
ffffffff800020aa:	39 d6                	cmp    %edx,%esi
ffffffff800020ac:	7d 2d                	jge    ffffffff800020db <console_exec+0x4b>
        *((uint32_t*)fb_info.base + i) = console_info.background_color;
ffffffff800020ae:	48 8b 3d 7b 8d 00 00 	mov    0x8d7b(%rip),%rdi        # ffffffff8000ae30 <fb_info>
ffffffff800020b5:	83 ea 01             	sub    $0x1,%edx
ffffffff800020b8:	4c 63 c6             	movslq %esi,%r8
ffffffff800020bb:	29 f2                	sub    %esi,%edx
ffffffff800020bd:	8b 0d 49 9e 00 00    	mov    0x9e49(%rip),%ecx        # ffffffff8000bf0c <console_info+0xc>
ffffffff800020c3:	4c 01 c2             	add    %r8,%rdx
ffffffff800020c6:	4a 8d 04 87          	lea    (%rdi,%r8,4),%rax
ffffffff800020ca:	48 8d 54 97 04       	lea    0x4(%rdi,%rdx,4),%rdx
ffffffff800020cf:	90                   	nop
ffffffff800020d0:	89 08                	mov    %ecx,(%rax)
ffffffff800020d2:	48 83 c0 04          	add    $0x4,%rax
    for(int i = console_info.start_pos + (fb_info.width * 2); i < (fb_info.height * fb_info.width); i++)
ffffffff800020d6:	48 39 d0             	cmp    %rdx,%rax
ffffffff800020d9:	75 f5                	jne    ffffffff800020d0 <console_exec+0x40>
}
ffffffff800020db:	f3 c3                	repz retq 
ffffffff800020dd:	0f 1f 00             	nopl   (%rax)

ffffffff800020e0 <stty_sendcmd>:
#include <serial.h>



void stty_sendcmd(uint16_t cmd)
{
ffffffff800020e0:	48 83 ec 08          	sub    $0x8,%rsp
    serial_write(SERIAL_PORT1, 0x1B);
ffffffff800020e4:	be 1b 00 00 00       	mov    $0x1b,%esi
ffffffff800020e9:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800020ee:	e8 7d 01 00 00       	callq  ffffffff80002270 <serial_write>
    serial_write(SERIAL_PORT1, 0x5B);
ffffffff800020f3:	be 5b 00 00 00       	mov    $0x5b,%esi
ffffffff800020f8:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800020fd:	e8 6e 01 00 00       	callq  ffffffff80002270 <serial_write>
    serial_write(SERIAL_PORT1, '[');
ffffffff80002102:	be 5b 00 00 00       	mov    $0x5b,%esi
ffffffff80002107:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000210c:	e8 5f 01 00 00       	callq  ffffffff80002270 <serial_write>
    serial_write(SERIAL_PORT1, 'H');
ffffffff80002111:	be 48 00 00 00       	mov    $0x48,%esi
ffffffff80002116:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000211b:	e8 50 01 00 00       	callq  ffffffff80002270 <serial_write>
    serial_write(SERIAL_PORT1, '~');
ffffffff80002120:	be 7e 00 00 00       	mov    $0x7e,%esi
ffffffff80002125:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8000212a:	48 83 c4 08          	add    $0x8,%rsp
    serial_write(SERIAL_PORT1, '~');
ffffffff8000212e:	e9 3d 01 00 00       	jmpq   ffffffff80002270 <serial_write>
ffffffff80002133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000213a:	00 00 00 
ffffffff8000213d:	0f 1f 00             	nopl   (%rax)

ffffffff80002140 <serial_init>:
#include <io.h>

char serial_buffer[256];

uint64_t serial_init(uint16_t port)
{
ffffffff80002140:	41 55                	push   %r13
ffffffff80002142:	41 54                	push   %r12
    outb(port + 1, 0x00);
ffffffff80002144:	44 8d 67 01          	lea    0x1(%rdi),%r12d
{
ffffffff80002148:	55                   	push   %rbp
ffffffff80002149:	53                   	push   %rbx
ffffffff8000214a:	89 fb                	mov    %edi,%ebx
    outb(port + 3, 0x80);
ffffffff8000214c:	8d 6b 03             	lea    0x3(%rbx),%ebp
    outb(port + 1, 0x00);
ffffffff8000214f:	45 0f b7 e4          	movzwl %r12w,%r12d
ffffffff80002153:	31 f6                	xor    %esi,%esi
{
ffffffff80002155:	48 83 ec 08          	sub    $0x8,%rsp
    outb(port + 1, 0x00);
ffffffff80002159:	44 89 e7             	mov    %r12d,%edi
    outb(port + 0, 0x00);
ffffffff8000215c:	44 0f b7 eb          	movzwl %bx,%r13d
    outb(port + 3, 0x80);
ffffffff80002160:	0f b7 ed             	movzwl %bp,%ebp
    outb(port + 1, 0x00);
ffffffff80002163:	e8 b8 f9 ff ff       	callq  ffffffff80001b20 <outb>
    outb(port + 3, 0x80);
ffffffff80002168:	be 80 00 00 00       	mov    $0x80,%esi
ffffffff8000216d:	89 ef                	mov    %ebp,%edi
ffffffff8000216f:	e8 ac f9 ff ff       	callq  ffffffff80001b20 <outb>
    outb(port + 0, 0x00);
ffffffff80002174:	31 f6                	xor    %esi,%esi
ffffffff80002176:	44 89 ef             	mov    %r13d,%edi
ffffffff80002179:	e8 a2 f9 ff ff       	callq  ffffffff80001b20 <outb>
    outb(port + 1, 0x00);
ffffffff8000217e:	31 f6                	xor    %esi,%esi
ffffffff80002180:	44 89 e7             	mov    %r12d,%edi
ffffffff80002183:	e8 98 f9 ff ff       	callq  ffffffff80001b20 <outb>
    outb(port + 3, 0x03);
ffffffff80002188:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff8000218d:	89 ef                	mov    %ebp,%edi
ffffffff8000218f:	e8 8c f9 ff ff       	callq  ffffffff80001b20 <outb>
    outb(port + 2, 0xC7);
ffffffff80002194:	8d 7b 02             	lea    0x2(%rbx),%edi
    outb(port + 4, 0x0B);
ffffffff80002197:	83 c3 04             	add    $0x4,%ebx
    outb(port + 2, 0xC7);
ffffffff8000219a:	be c7 00 00 00       	mov    $0xc7,%esi
    outb(port + 4, 0x0B);
ffffffff8000219f:	0f b7 db             	movzwl %bx,%ebx
    outb(port + 2, 0xC7);
ffffffff800021a2:	0f b7 ff             	movzwl %di,%edi
ffffffff800021a5:	e8 76 f9 ff ff       	callq  ffffffff80001b20 <outb>
    outb(port + 4, 0x0B);
ffffffff800021aa:	be 0b 00 00 00       	mov    $0xb,%esi
ffffffff800021af:	89 df                	mov    %ebx,%edi
ffffffff800021b1:	e8 6a f9 ff ff       	callq  ffffffff80001b20 <outb>

    if(inb(port + 0) != 0xAE)
ffffffff800021b6:	44 89 ef             	mov    %r13d,%edi
ffffffff800021b9:	e8 72 f9 ff ff       	callq  ffffffff80001b30 <inb>
ffffffff800021be:	3c ae                	cmp    $0xae,%al
ffffffff800021c0:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff800021c5:	74 11                	je     ffffffff800021d8 <serial_init+0x98>
        return 1;
    }

    outb(port + 4, 0x0F);
    return 0;
}
ffffffff800021c7:	48 83 c4 08          	add    $0x8,%rsp
ffffffff800021cb:	48 89 d0             	mov    %rdx,%rax
ffffffff800021ce:	5b                   	pop    %rbx
ffffffff800021cf:	5d                   	pop    %rbp
ffffffff800021d0:	41 5c                	pop    %r12
ffffffff800021d2:	41 5d                	pop    %r13
ffffffff800021d4:	c3                   	retq   
ffffffff800021d5:	0f 1f 00             	nopl   (%rax)
    outb(port + 4, 0x0F);
ffffffff800021d8:	89 df                	mov    %ebx,%edi
ffffffff800021da:	be 0f 00 00 00       	mov    $0xf,%esi
ffffffff800021df:	e8 3c f9 ff ff       	callq  ffffffff80001b20 <outb>
}
ffffffff800021e4:	48 83 c4 08          	add    $0x8,%rsp
    return 0;
ffffffff800021e8:	31 d2                	xor    %edx,%edx
}
ffffffff800021ea:	5b                   	pop    %rbx
ffffffff800021eb:	48 89 d0             	mov    %rdx,%rax
ffffffff800021ee:	5d                   	pop    %rbp
ffffffff800021ef:	41 5c                	pop    %r12
ffffffff800021f1:	41 5d                	pop    %r13
ffffffff800021f3:	c3                   	retq   
ffffffff800021f4:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800021fb:	00 00 00 00 
ffffffff800021ff:	90                   	nop

ffffffff80002200 <serial_received>:

uint64_t serial_received(uint16_t port)
{
    return inb(port + 5) & 1;
ffffffff80002200:	83 c7 05             	add    $0x5,%edi
{
ffffffff80002203:	48 83 ec 08          	sub    $0x8,%rsp
    return inb(port + 5) & 1;
ffffffff80002207:	0f b7 ff             	movzwl %di,%edi
ffffffff8000220a:	e8 21 f9 ff ff       	callq  ffffffff80001b30 <inb>
}
ffffffff8000220f:	48 83 c4 08          	add    $0x8,%rsp
    return inb(port + 5) & 1;
ffffffff80002213:	83 e0 01             	and    $0x1,%eax
}
ffffffff80002216:	c3                   	retq   
ffffffff80002217:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000221e:	00 00 

ffffffff80002220 <serial_read>:

uint8_t serial_read(uint16_t port)
{
ffffffff80002220:	55                   	push   %rbp
ffffffff80002221:	53                   	push   %rbx
ffffffff80002222:	0f b7 ef             	movzwl %di,%ebp
ffffffff80002225:	83 c7 05             	add    $0x5,%edi
ffffffff80002228:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff8000222c:	0f b7 df             	movzwl %di,%ebx
ffffffff8000222f:	90                   	nop
    return inb(port + 5) & 1;
ffffffff80002230:	89 df                	mov    %ebx,%edi
ffffffff80002232:	e8 f9 f8 ff ff       	callq  ffffffff80001b30 <inb>
    while(serial_received(port) == 0);
ffffffff80002237:	a8 01                	test   $0x1,%al
ffffffff80002239:	74 f5                	je     ffffffff80002230 <serial_read+0x10>

    return inb(port);
}
ffffffff8000223b:	48 83 c4 08          	add    $0x8,%rsp
    return inb(port);
ffffffff8000223f:	89 ef                	mov    %ebp,%edi
}
ffffffff80002241:	5b                   	pop    %rbx
ffffffff80002242:	5d                   	pop    %rbp
    return inb(port);
ffffffff80002243:	e9 e8 f8 ff ff       	jmpq   ffffffff80001b30 <inb>
ffffffff80002248:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000224f:	00 

ffffffff80002250 <serial_is_tx_empty>:

uint64_t serial_is_tx_empty(uint16_t port)
{
    return inb(port + 5) & 0x20;
ffffffff80002250:	83 c7 05             	add    $0x5,%edi
{
ffffffff80002253:	48 83 ec 08          	sub    $0x8,%rsp
    return inb(port + 5) & 0x20;
ffffffff80002257:	0f b7 ff             	movzwl %di,%edi
ffffffff8000225a:	e8 d1 f8 ff ff       	callq  ffffffff80001b30 <inb>
ffffffff8000225f:	83 e0 20             	and    $0x20,%eax
}
ffffffff80002262:	48 83 c4 08          	add    $0x8,%rsp
    return inb(port + 5) & 0x20;
ffffffff80002266:	0f b6 c0             	movzbl %al,%eax
}
ffffffff80002269:	c3                   	retq   
ffffffff8000226a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80002270 <serial_write>:

void serial_write(uint16_t port, uint8_t data)
{
ffffffff80002270:	41 54                	push   %r12
ffffffff80002272:	44 0f b7 e7          	movzwl %di,%r12d
ffffffff80002276:	83 c7 05             	add    $0x5,%edi
ffffffff80002279:	55                   	push   %rbp
ffffffff8000227a:	89 f5                	mov    %esi,%ebp
ffffffff8000227c:	53                   	push   %rbx
ffffffff8000227d:	0f b7 df             	movzwl %di,%ebx
    return inb(port + 5) & 0x20;
ffffffff80002280:	89 df                	mov    %ebx,%edi
ffffffff80002282:	e8 a9 f8 ff ff       	callq  ffffffff80001b30 <inb>
    while(serial_is_tx_empty(port) == 0);
ffffffff80002287:	a8 20                	test   $0x20,%al
ffffffff80002289:	74 f5                	je     ffffffff80002280 <serial_write+0x10>
    outb(port, data);
}
ffffffff8000228b:	5b                   	pop    %rbx
    outb(port, data);
ffffffff8000228c:	40 0f b6 f5          	movzbl %bpl,%esi
ffffffff80002290:	44 89 e7             	mov    %r12d,%edi
}
ffffffff80002293:	5d                   	pop    %rbp
ffffffff80002294:	41 5c                	pop    %r12
    outb(port, data);
ffffffff80002296:	e9 85 f8 ff ff       	jmpq   ffffffff80001b20 <outb>
ffffffff8000229b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff800022a0 <serial_write_str>:

void serial_write_str(uint16_t port, char* data)
{
    uint8_t i = 0;
    while(data[i] != 0)
ffffffff800022a0:	0f b6 06             	movzbl (%rsi),%eax
ffffffff800022a3:	84 c0                	test   %al,%al
ffffffff800022a5:	74 39                	je     ffffffff800022e0 <serial_write_str+0x40>
{
ffffffff800022a7:	41 54                	push   %r12
ffffffff800022a9:	49 89 f4             	mov    %rsi,%r12
ffffffff800022ac:	55                   	push   %rbp
ffffffff800022ad:	0f b7 ef             	movzwl %di,%ebp
ffffffff800022b0:	53                   	push   %rbx
    uint8_t i = 0;
ffffffff800022b1:	31 db                	xor    %ebx,%ebx
ffffffff800022b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    {
        serial_write(port, data[i]);
ffffffff800022b8:	0f b6 f0             	movzbl %al,%esi
        //if(data[i] == '\n') serial_write(port, '\r');
        i++;
ffffffff800022bb:	83 c3 01             	add    $0x1,%ebx
        serial_write(port, data[i]);
ffffffff800022be:	89 ef                	mov    %ebp,%edi
ffffffff800022c0:	e8 ab ff ff ff       	callq  ffffffff80002270 <serial_write>
    while(data[i] != 0)
ffffffff800022c5:	0f b6 c3             	movzbl %bl,%eax
ffffffff800022c8:	41 0f b6 04 04       	movzbl (%r12,%rax,1),%eax
ffffffff800022cd:	84 c0                	test   %al,%al
ffffffff800022cf:	75 e7                	jne    ffffffff800022b8 <serial_write_str+0x18>
    }
ffffffff800022d1:	5b                   	pop    %rbx
ffffffff800022d2:	5d                   	pop    %rbp
ffffffff800022d3:	41 5c                	pop    %r12
ffffffff800022d5:	c3                   	retq   
ffffffff800022d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800022dd:	00 00 00 
ffffffff800022e0:	f3 c3                	repz retq 
ffffffff800022e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800022e9:	00 00 00 
ffffffff800022ec:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff800022f0 <kbd_init>:


void kbd_init()
{

}
ffffffff800022f0:	f3 c3                	repz retq 
ffffffff800022f2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800022f9:	00 00 00 00 
ffffffff800022fd:	0f 1f 00             	nopl   (%rax)

ffffffff80002300 <kbd_set_target>:

void kbd_set_target(void* handler)
{
    kbd_handler = handler;
ffffffff80002300:	48 89 3d c1 e7 00 00 	mov    %rdi,0xe7c1(%rip)        # ffffffff80010ac8 <kbd_handler>
    kbd_active = 1;
ffffffff80002307:	c6 05 c2 e7 00 00 01 	movb   $0x1,0xe7c2(%rip)        # ffffffff80010ad0 <kbd_active>
}
ffffffff8000230e:	c3                   	retq   
ffffffff8000230f:	90                   	nop

ffffffff80002310 <kbd_translate>:

uint8_t kbd_translate(uint8_t scancode, uint8_t uppercase)
{
    if(scancode > 58) return 0;
ffffffff80002310:	31 c0                	xor    %eax,%eax
ffffffff80002312:	40 80 ff 3a          	cmp    $0x3a,%dil
ffffffff80002316:	77 14                	ja     ffffffff8000232c <kbd_translate+0x1c>
ffffffff80002318:	40 0f b6 ff          	movzbl %dil,%edi

    if(uppercase) return kbd_table[scancode] - 32;
ffffffff8000231c:	40 84 f6             	test   %sil,%sil
ffffffff8000231f:	0f b6 87 00 53 00 80 	movzbl -0x7fffad00(%rdi),%eax
ffffffff80002326:	8d 50 e0             	lea    -0x20(%rax),%edx
ffffffff80002329:	0f 45 c2             	cmovne %edx,%eax

    return kbd_table[scancode];
}
ffffffff8000232c:	f3 c3                	repz retq 
ffffffff8000232e:	66 90                	xchg   %ax,%ax

ffffffff80002330 <kbd_handle>:
void kbd_handle()
{
    uint8_t data;
    KEY_INFO_t key_info;

    if(!kbd_active) return;
ffffffff80002330:	80 3d 99 e7 00 00 00 	cmpb   $0x0,0xe799(%rip)        # ffffffff80010ad0 <kbd_active>
ffffffff80002337:	75 07                	jne    ffffffff80002340 <kbd_handle+0x10>
ffffffff80002339:	f3 c3                	repz retq 
ffffffff8000233b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{
ffffffff80002340:	48 83 ec 08          	sub    $0x8,%rsp

    data = inb(0x60);
ffffffff80002344:	bf 60 00 00 00       	mov    $0x60,%edi
ffffffff80002349:	e8 e2 f7 ff ff       	callq  ffffffff80001b30 <inb>

    uint8_t buffer[20];

    switch(data)
ffffffff8000234e:	3c 36                	cmp    $0x36,%al
ffffffff80002350:	74 36                	je     ffffffff80002388 <kbd_handle+0x58>
ffffffff80002352:	77 1c                	ja     ffffffff80002370 <kbd_handle+0x40>
ffffffff80002354:	3c 01                	cmp    $0x1,%al
ffffffff80002356:	0f 84 84 00 00 00    	je     ffffffff800023e0 <kbd_handle+0xb0>
ffffffff8000235c:	3c 2a                	cmp    $0x2a,%al
ffffffff8000235e:	75 48                	jne    ffffffff800023a8 <kbd_handle+0x78>
    {
        case KBD_LEFT_SHIFT:
            lshift_status = 1;
ffffffff80002360:	c6 05 f9 9e 00 00 01 	movb   $0x1,0x9ef9(%rip)        # ffffffff8000c260 <lshift_status>
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
    key_info.scancode = data;

    kbd_handler(key_info);

ffffffff80002367:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8000236b:	c3                   	retq   
ffffffff8000236c:	0f 1f 40 00          	nopl   0x0(%rax)
    switch(data)
ffffffff80002370:	3c aa                	cmp    $0xaa,%al
ffffffff80002372:	74 24                	je     ffffffff80002398 <kbd_handle+0x68>
ffffffff80002374:	3c b6                	cmp    $0xb6,%al
ffffffff80002376:	75 30                	jne    ffffffff800023a8 <kbd_handle+0x78>
            rshift_status = 0;
ffffffff80002378:	c6 05 c9 9d 00 00 00 	movb   $0x0,0x9dc9(%rip)        # ffffffff8000c148 <rshift_status>
            return;
ffffffff8000237f:	eb e6                	jmp    ffffffff80002367 <kbd_handle+0x37>
ffffffff80002381:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            rshift_status = 1;
ffffffff80002388:	c6 05 b9 9d 00 00 01 	movb   $0x1,0x9db9(%rip)        # ffffffff8000c148 <rshift_status>
            return;
ffffffff8000238f:	eb d6                	jmp    ffffffff80002367 <kbd_handle+0x37>
ffffffff80002391:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            lshift_status = 0;
ffffffff80002398:	c6 05 c1 9e 00 00 00 	movb   $0x0,0x9ec1(%rip)        # ffffffff8000c260 <lshift_status>
            return;
ffffffff8000239f:	eb c6                	jmp    ffffffff80002367 <kbd_handle+0x37>
ffffffff800023a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if(scancode > 58) return 0;
ffffffff800023a8:	31 d2                	xor    %edx,%edx
ffffffff800023aa:	3c 3a                	cmp    $0x3a,%al
ffffffff800023ac:	77 1e                	ja     ffffffff800023cc <kbd_handle+0x9c>
ffffffff800023ae:	0f b6 d0             	movzbl %al,%edx
    if(uppercase) return kbd_table[scancode] - 32;
ffffffff800023b1:	0f b6 35 a8 9e 00 00 	movzbl 0x9ea8(%rip),%esi        # ffffffff8000c260 <lshift_status>
ffffffff800023b8:	0f b6 92 00 53 00 80 	movzbl -0x7fffad00(%rdx),%edx
ffffffff800023bf:	40 0a 35 82 9d 00 00 	or     0x9d82(%rip),%sil        # ffffffff8000c148 <rshift_status>
ffffffff800023c6:	8d 4a e0             	lea    -0x20(%rdx),%ecx
ffffffff800023c9:	0f 45 d1             	cmovne %ecx,%edx
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
ffffffff800023cc:	31 c9                	xor    %ecx,%ecx
ffffffff800023ce:	48 83 c4 08          	add    $0x8,%rsp
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
ffffffff800023d2:	88 d5                	mov    %dl,%ch
    key_info.scancode = data;
ffffffff800023d4:	88 c1                	mov    %al,%cl
    kbd_handler(key_info);
ffffffff800023d6:	89 cf                	mov    %ecx,%edi
ffffffff800023d8:	ff 25 ea e6 00 00    	jmpq   *0xe6ea(%rip)        # ffffffff80010ac8 <kbd_handler>
ffffffff800023de:	66 90                	xchg   %ax,%ax
            printf("%d\n", pit_ticks);
ffffffff800023e0:	48 8b 35 f9 e7 00 00 	mov    0xe7f9(%rip),%rsi        # ffffffff80010be0 <pit_ticks>
ffffffff800023e7:	48 c7 c7 90 57 00 80 	mov    $0xffffffff80005790,%rdi
ffffffff800023ee:	31 c0                	xor    %eax,%eax
ffffffff800023f0:	48 83 c4 08          	add    $0x8,%rsp
            printf("%d\n", pit_ticks);
ffffffff800023f4:	e9 b7 13 00 00       	jmpq   ffffffff800037b0 <printf_>
ffffffff800023f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80002400 <cpu_init>:

void cpu_init()
{
    uint64_t a,b,c,d;
    __cpuid(0,a,b,c,d);
ffffffff80002400:	f3 c3                	repz retq 
ffffffff80002402:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80002409:	00 00 00 
ffffffff8000240c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80002410 <acpi_init>:
    struct RSDP20Descriptor* rsdp;

}ACPI_Info;

void acpi_init()
{
ffffffff80002410:	48 83 ec 18          	sub    $0x18,%rsp
    ACPI_Info.rsdp = (struct RSDP20Descriptor*)boot_info.tag_rsdp->rsdp;
ffffffff80002414:	48 8b 05 ed 89 00 00 	mov    0x89ed(%rip),%rax        # ffffffff8000ae08 <boot_info+0x28>
    
    uint8_t test[8] = {'R', 'S', 'P', ' ', 'P', 'T', 'R', ' '};
ffffffff8000241b:	48 bf 52 53 50 20 50 	movabs $0x2052545020505352,%rdi
ffffffff80002422:	54 52 20 
ffffffff80002425:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
ffffffff8000242a:	31 d2                	xor    %edx,%edx
ffffffff8000242c:	b9 52 00 00 00       	mov    $0x52,%ecx
    ACPI_Info.rsdp = (struct RSDP20Descriptor*)boot_info.tag_rsdp->rsdp;
ffffffff80002431:	48 8b 40 10          	mov    0x10(%rax),%rax
ffffffff80002435:	48 89 05 2c 9e 00 00 	mov    %rax,0x9e2c(%rip)        # ffffffff8000c268 <ACPI_Info>
    for(uint32_t i = 0; i < 8; i++)
    {
        if(test[i] == ACPI_Info.rsdp->header.signature[i]) 
ffffffff8000243c:	38 0c 10             	cmp    %cl,(%rax,%rdx,1)
ffffffff8000243f:	74 0f                	je     ffffffff80002450 <acpi_init+0x40>
            return;
    }

    printf("Valid RSDP Header. Revision %d\n", ACPI_Info.rsdp->header.revision);
    
ffffffff80002441:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80002445:	c3                   	retq   
ffffffff80002446:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000244d:	00 00 00 
ffffffff80002450:	48 83 c2 01          	add    $0x1,%rdx
    for(uint32_t i = 0; i < 8; i++)
ffffffff80002454:	48 83 fa 08          	cmp    $0x8,%rdx
ffffffff80002458:	75 16                	jne    ffffffff80002470 <acpi_init+0x60>
    printf("Valid RSDP Header. Revision %d\n", ACPI_Info.rsdp->header.revision);
ffffffff8000245a:	0f b6 70 0f          	movzbl 0xf(%rax),%esi
ffffffff8000245e:	48 c7 c7 40 53 00 80 	mov    $0xffffffff80005340,%rdi
ffffffff80002465:	31 c0                	xor    %eax,%eax
ffffffff80002467:	48 83 c4 18          	add    $0x18,%rsp
    printf("Valid RSDP Header. Revision %d\n", ACPI_Info.rsdp->header.revision);
ffffffff8000246b:	e9 40 13 00 00       	jmpq   ffffffff800037b0 <printf_>
ffffffff80002470:	0f b6 4c 14 08       	movzbl 0x8(%rsp,%rdx,1),%ecx
ffffffff80002475:	eb c5                	jmp    ffffffff8000243c <acpi_init+0x2c>
ffffffff80002477:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000247e:	00 00 

ffffffff80002480 <pic_EOI>:

uint64_t ticks;

void pic_EOI(uint8_t IRQ)
{
    if(IRQ >= 8)
ffffffff80002480:	40 80 ff 07          	cmp    $0x7,%dil
ffffffff80002484:	77 12                	ja     ffffffff80002498 <pic_EOI+0x18>
    {
        outb(PIC2_CMD, PIC_EOI);
    }
    
    outb(PIC1_CMD, PIC_EOI);
ffffffff80002486:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff8000248b:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80002490:	e9 8b f6 ff ff       	jmpq   ffffffff80001b20 <outb>
ffffffff80002495:	0f 1f 00             	nopl   (%rax)
{
ffffffff80002498:	48 83 ec 08          	sub    $0x8,%rsp
        outb(PIC2_CMD, PIC_EOI);
ffffffff8000249c:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff800024a1:	bf a0 00 00 00       	mov    $0xa0,%edi
ffffffff800024a6:	e8 75 f6 ff ff       	callq  ffffffff80001b20 <outb>
    outb(PIC1_CMD, PIC_EOI);
ffffffff800024ab:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff800024b0:	bf 20 00 00 00       	mov    $0x20,%edi
}
ffffffff800024b5:	48 83 c4 08          	add    $0x8,%rsp
    outb(PIC1_CMD, PIC_EOI);
ffffffff800024b9:	e9 62 f6 ff ff       	jmpq   ffffffff80001b20 <outb>
ffffffff800024be:	66 90                	xchg   %ax,%ax

ffffffff800024c0 <pic_set_mask>:

void pic_set_mask(uint8_t IRQ)
{
ffffffff800024c0:	55                   	push   %rbp
ffffffff800024c1:	53                   	push   %rbx
ffffffff800024c2:	48 83 ec 08          	sub    $0x8,%rsp
    uint16_t port;
    uint8_t value;

    if(IRQ < 8)
ffffffff800024c6:	40 80 ff 07          	cmp    $0x7,%dil
ffffffff800024ca:	76 34                	jbe    ffffffff80002500 <pic_set_mask+0x40>
        port = PIC1_DATA;
    }
    else
    {
        port = PIC2_DATA;
        IRQ -= 8;
ffffffff800024cc:	8d 6f f8             	lea    -0x8(%rdi),%ebp
ffffffff800024cf:	bb a1 00 00 00       	mov    $0xa1,%ebx
    }
    value = inb(port) | (1 << IRQ);
ffffffff800024d4:	89 df                	mov    %ebx,%edi
ffffffff800024d6:	e8 55 f6 ff ff       	callq  ffffffff80001b30 <inb>
    outb(port, value);
}
ffffffff800024db:	48 83 c4 08          	add    $0x8,%rsp
    value = inb(port) | (1 << IRQ);
ffffffff800024df:	89 e9                	mov    %ebp,%ecx
ffffffff800024e1:	be 01 00 00 00       	mov    $0x1,%esi
    outb(port, value);
ffffffff800024e6:	89 df                	mov    %ebx,%edi
    value = inb(port) | (1 << IRQ);
ffffffff800024e8:	d3 e6                	shl    %cl,%esi
}
ffffffff800024ea:	5b                   	pop    %rbx
ffffffff800024eb:	5d                   	pop    %rbp
    value = inb(port) | (1 << IRQ);
ffffffff800024ec:	09 f0                	or     %esi,%eax
    outb(port, value);
ffffffff800024ee:	0f b6 f0             	movzbl %al,%esi
ffffffff800024f1:	e9 2a f6 ff ff       	jmpq   ffffffff80001b20 <outb>
ffffffff800024f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800024fd:	00 00 00 
ffffffff80002500:	89 fd                	mov    %edi,%ebp
ffffffff80002502:	bb 21 00 00 00       	mov    $0x21,%ebx
ffffffff80002507:	eb cb                	jmp    ffffffff800024d4 <pic_set_mask+0x14>
ffffffff80002509:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80002510 <pic_clear_mask>:

void pic_clear_mask(uint8_t IRQ)
{
ffffffff80002510:	55                   	push   %rbp
ffffffff80002511:	53                   	push   %rbx
ffffffff80002512:	48 83 ec 08          	sub    $0x8,%rsp
    uint16_t port;
    uint8_t value;

    if(IRQ < 8)
ffffffff80002516:	40 80 ff 07          	cmp    $0x7,%dil
ffffffff8000251a:	76 34                	jbe    ffffffff80002550 <pic_clear_mask+0x40>
        port = PIC1_DATA;
    }
    else
    {
        port = PIC2_DATA;
        IRQ -= 8;
ffffffff8000251c:	8d 6f f8             	lea    -0x8(%rdi),%ebp
ffffffff8000251f:	bb a1 00 00 00       	mov    $0xa1,%ebx
    }
    value = inb(port) & ~(1 << IRQ);
ffffffff80002524:	89 df                	mov    %ebx,%edi
ffffffff80002526:	e8 05 f6 ff ff       	callq  ffffffff80001b30 <inb>
    outb(port, value);
}
ffffffff8000252b:	48 83 c4 08          	add    $0x8,%rsp
    value = inb(port) & ~(1 << IRQ);
ffffffff8000252f:	89 e9                	mov    %ebp,%ecx
ffffffff80002531:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
    outb(port, value);
ffffffff80002536:	89 df                	mov    %ebx,%edi
    value = inb(port) & ~(1 << IRQ);
ffffffff80002538:	d3 c2                	rol    %cl,%edx
}
ffffffff8000253a:	5b                   	pop    %rbx
ffffffff8000253b:	5d                   	pop    %rbp
    value = inb(port) & ~(1 << IRQ);
ffffffff8000253c:	21 d0                	and    %edx,%eax
    outb(port, value);
ffffffff8000253e:	0f b6 f0             	movzbl %al,%esi
ffffffff80002541:	e9 da f5 ff ff       	jmpq   ffffffff80001b20 <outb>
ffffffff80002546:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000254d:	00 00 00 
ffffffff80002550:	89 fd                	mov    %edi,%ebp
ffffffff80002552:	bb 21 00 00 00       	mov    $0x21,%ebx
ffffffff80002557:	eb cb                	jmp    ffffffff80002524 <pic_clear_mask+0x14>
ffffffff80002559:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80002560 <pic_disable>:

void pic_disable()
{
ffffffff80002560:	48 83 ec 08          	sub    $0x8,%rsp
    outb(PIC2_DATA, 0xff);
ffffffff80002564:	be ff 00 00 00       	mov    $0xff,%esi
ffffffff80002569:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff8000256e:	e8 ad f5 ff ff       	callq  ffffffff80001b20 <outb>
    outb(PIC1_DATA, 0xff);
ffffffff80002573:	be ff 00 00 00       	mov    $0xff,%esi
ffffffff80002578:	bf 21 00 00 00       	mov    $0x21,%edi
}
ffffffff8000257d:	48 83 c4 08          	add    $0x8,%rsp
    outb(PIC1_DATA, 0xff);
ffffffff80002581:	e9 9a f5 ff ff       	jmpq   ffffffff80001b20 <outb>
ffffffff80002586:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000258d:	00 00 00 

ffffffff80002590 <pic_remap>:

void pic_remap()
{
ffffffff80002590:	55                   	push   %rbp
ffffffff80002591:	53                   	push   %rbx
    uint8_t mask1 = inb(PIC1_DATA);
ffffffff80002592:	bf 21 00 00 00       	mov    $0x21,%edi
{
ffffffff80002597:	48 83 ec 08          	sub    $0x8,%rsp
    uint8_t mask1 = inb(PIC1_DATA);
ffffffff8000259b:	e8 90 f5 ff ff       	callq  ffffffff80001b30 <inb>
    uint8_t mask2 = inb(PIC2_DATA);
ffffffff800025a0:	bf a1 00 00 00       	mov    $0xa1,%edi
    uint8_t mask1 = inb(PIC1_DATA);
ffffffff800025a5:	89 c5                	mov    %eax,%ebp
    uint8_t mask2 = inb(PIC2_DATA);
ffffffff800025a7:	e8 84 f5 ff ff       	callq  ffffffff80001b30 <inb>

    outb(PIC1_CMD, 0x11);
ffffffff800025ac:	be 11 00 00 00       	mov    $0x11,%esi
ffffffff800025b1:	bf 20 00 00 00       	mov    $0x20,%edi
    uint8_t mask2 = inb(PIC2_DATA);
ffffffff800025b6:	89 c3                	mov    %eax,%ebx
    outb(PIC1_CMD, 0x11);
ffffffff800025b8:	e8 63 f5 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff800025bd:	31 c0                	xor    %eax,%eax
ffffffff800025bf:	e8 7c f5 ff ff       	callq  ffffffff80001b40 <io_wait>
    outb(PIC2_CMD, 0x11);
ffffffff800025c4:	be 11 00 00 00       	mov    $0x11,%esi
ffffffff800025c9:	bf a0 00 00 00       	mov    $0xa0,%edi
ffffffff800025ce:	e8 4d f5 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff800025d3:	31 c0                	xor    %eax,%eax
ffffffff800025d5:	e8 66 f5 ff ff       	callq  ffffffff80001b40 <io_wait>

    outb(PIC1_DATA, 0x20);
ffffffff800025da:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff800025df:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff800025e4:	e8 37 f5 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff800025e9:	31 c0                	xor    %eax,%eax
ffffffff800025eb:	e8 50 f5 ff ff       	callq  ffffffff80001b40 <io_wait>
    outb(PIC2_DATA, 0x20);
ffffffff800025f0:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff800025f5:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff800025fa:	e8 21 f5 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff800025ff:	31 c0                	xor    %eax,%eax
ffffffff80002601:	e8 3a f5 ff ff       	callq  ffffffff80001b40 <io_wait>

    outb(PIC1_DATA, 0x04);
ffffffff80002606:	be 04 00 00 00       	mov    $0x4,%esi
ffffffff8000260b:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff80002610:	e8 0b f5 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff80002615:	31 c0                	xor    %eax,%eax
ffffffff80002617:	e8 24 f5 ff ff       	callq  ffffffff80001b40 <io_wait>
    outb(PIC2_DATA, 0x02);
ffffffff8000261c:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff80002621:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff80002626:	e8 f5 f4 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff8000262b:	31 c0                	xor    %eax,%eax
ffffffff8000262d:	e8 0e f5 ff ff       	callq  ffffffff80001b40 <io_wait>

    outb(PIC1_DATA, 0x01);
ffffffff80002632:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff80002637:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff8000263c:	e8 df f4 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff80002641:	31 c0                	xor    %eax,%eax
ffffffff80002643:	e8 f8 f4 ff ff       	callq  ffffffff80001b40 <io_wait>
    outb(PIC2_DATA, 0x01);
ffffffff80002648:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8000264d:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff80002652:	e8 c9 f4 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff80002657:	31 c0                	xor    %eax,%eax
ffffffff80002659:	e8 e2 f4 ff ff       	callq  ffffffff80001b40 <io_wait>

    outb(PIC1_DATA, mask1);
ffffffff8000265e:	40 0f b6 f5          	movzbl %bpl,%esi
ffffffff80002662:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff80002667:	e8 b4 f4 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff8000266c:	31 c0                	xor    %eax,%eax
ffffffff8000266e:	e8 cd f4 ff ff       	callq  ffffffff80001b40 <io_wait>
    outb(PIC2_DATA, mask2);
ffffffff80002673:	0f b6 f3             	movzbl %bl,%esi
ffffffff80002676:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff8000267b:	e8 a0 f4 ff ff       	callq  ffffffff80001b20 <outb>
    io_wait();
ffffffff80002680:	31 c0                	xor    %eax,%eax
}
ffffffff80002682:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80002686:	5b                   	pop    %rbx
ffffffff80002687:	5d                   	pop    %rbp
    io_wait();
ffffffff80002688:	e9 b3 f4 ff ff       	jmpq   ffffffff80001b40 <io_wait>
ffffffff8000268d:	0f 1f 00             	nopl   (%rax)

ffffffff80002690 <pit_init>:



void pit_init(uint64_t freq)
{
ffffffff80002690:	53                   	push   %rbx
    if(freq > 1193181)
        working_freq = 1193181;

    uint32_t divisor = 1193180 / working_freq;

    outb(0x43, 0x36);
ffffffff80002691:	be 36 00 00 00       	mov    $0x36,%esi
{
ffffffff80002696:	48 89 fb             	mov    %rdi,%rbx
    outb(0x43, 0x36);
ffffffff80002699:	bf 43 00 00 00       	mov    $0x43,%edi
ffffffff8000269e:	e8 7d f4 ff ff       	callq  ffffffff80001b20 <outb>
    uint32_t divisor = 1193180 / working_freq;
ffffffff800026a3:	48 81 fb dd 34 12 00 	cmp    $0x1234dd,%rbx
ffffffff800026aa:	bf dd 34 12 00       	mov    $0x1234dd,%edi
ffffffff800026af:	b8 10 27 00 00       	mov    $0x2710,%eax
ffffffff800026b4:	48 0f 46 fb          	cmovbe %rbx,%rdi
ffffffff800026b8:	48 81 ff 10 27 00 00 	cmp    $0x2710,%rdi
ffffffff800026bf:	48 0f 42 f8          	cmovb  %rax,%rdi
ffffffff800026c3:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
ffffffff800026c8:	31 d2                	xor    %edx,%edx
ffffffff800026ca:	48 f7 f7             	div    %rdi
    outb(0x40, divisor & 0xff);
ffffffff800026cd:	bf 40 00 00 00       	mov    $0x40,%edi
ffffffff800026d2:	89 c6                	mov    %eax,%esi
ffffffff800026d4:	e8 47 f4 ff ff       	callq  ffffffff80001b20 <outb>
    outb(0x40, divisor >> 8);
ffffffff800026d9:	5b                   	pop    %rbx
    outb(0x40, divisor >> 8);
ffffffff800026da:	31 f6                	xor    %esi,%esi
ffffffff800026dc:	bf 40 00 00 00       	mov    $0x40,%edi
ffffffff800026e1:	e9 3a f4 ff ff       	jmpq   ffffffff80001b20 <outb>
ffffffff800026e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800026ed:	00 00 00 

ffffffff800026f0 <vfs_init>:
void vfs_init()
{
    //create file descriptors for STDIN, STDOUT, and STDERR
    

};
ffffffff800026f0:	f3 c3                	repz retq 
ffffffff800026f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800026f9:	00 00 00 
ffffffff800026fc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80002700 <_out_buffer>:


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  if (idx < maxlen) {
ffffffff80002700:	48 39 ca             	cmp    %rcx,%rdx
ffffffff80002703:	73 04                	jae    ffffffff80002709 <_out_buffer+0x9>
    ((char*)buffer)[idx] = character;
ffffffff80002705:	40 88 3c 16          	mov    %dil,(%rsi,%rdx,1)
  }
}
ffffffff80002709:	f3 c3                	repz retq 
ffffffff8000270b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80002710 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
ffffffff80002710:	f3 c3                	repz retq 
ffffffff80002712:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80002719:	00 00 00 00 
ffffffff8000271d:	0f 1f 00             	nopl   (%rax)

ffffffff80002720 <_out_fct>:

// internal output function wrapper
static inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)idx; (void)maxlen;
  if (character) {
ffffffff80002720:	40 84 ff             	test   %dil,%dil
{
ffffffff80002723:	48 89 f0             	mov    %rsi,%rax
  if (character) {
ffffffff80002726:	74 10                	je     ffffffff80002738 <_out_fct+0x18>
    // buffer is the output fct pointer
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
ffffffff80002728:	48 8b 76 08          	mov    0x8(%rsi),%rsi
ffffffff8000272c:	40 0f be ff          	movsbl %dil,%edi
ffffffff80002730:	ff 20                	jmpq   *(%rax)
ffffffff80002732:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  }
}
ffffffff80002738:	f3 c3                	repz retq 
ffffffff8000273a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80002740 <_ntoa_format>:
}


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
ffffffff80002740:	41 57                	push   %r15
ffffffff80002742:	41 56                	push   %r14
ffffffff80002744:	41 55                	push   %r13
ffffffff80002746:	41 54                	push   %r12
ffffffff80002748:	49 89 cd             	mov    %rcx,%r13
ffffffff8000274b:	55                   	push   %rbp
ffffffff8000274c:	53                   	push   %rbx
ffffffff8000274d:	48 89 fd             	mov    %rdi,%rbp
ffffffff80002750:	4c 89 c3             	mov    %r8,%rbx
ffffffff80002753:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff80002757:	8b 84 24 80 00 00 00 	mov    0x80(%rsp),%eax
ffffffff8000275e:	48 89 34 24          	mov    %rsi,(%rsp)
ffffffff80002762:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
ffffffff80002767:	8b 7c 24 60          	mov    0x60(%rsp),%edi
ffffffff8000276b:	89 c6                	mov    %eax,%esi
ffffffff8000276d:	89 c1                	mov    %eax,%ecx
  // pad leading zeros
  if (!(flags & FLAGS_LEFT)) {
ffffffff8000276f:	89 c2                	mov    %eax,%edx
ffffffff80002771:	83 e6 10             	and    $0x10,%esi
ffffffff80002774:	83 e1 03             	and    $0x3,%ecx
ffffffff80002777:	83 e2 02             	and    $0x2,%edx
ffffffff8000277a:	89 54 24 1c          	mov    %edx,0x1c(%rsp)
ffffffff8000277e:	75 79                	jne    ffffffff800027f9 <_ntoa_format+0xb9>
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
ffffffff80002780:	44 8b 54 24 78       	mov    0x78(%rsp),%r10d
ffffffff80002785:	41 89 c0             	mov    %eax,%r8d
ffffffff80002788:	8b 54 24 70          	mov    0x70(%rsp),%edx
ffffffff8000278c:	41 83 e0 01          	and    $0x1,%r8d
ffffffff80002790:	45 85 d2             	test   %r10d,%r10d
ffffffff80002793:	0f 85 d7 00 00 00    	jne    ffffffff80002870 <_ntoa_format+0x130>
      width--;
    }
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002799:	49 39 d1             	cmp    %rdx,%r9
ffffffff8000279c:	73 27                	jae    ffffffff800027c5 <_ntoa_format+0x85>
ffffffff8000279e:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff800027a2:	75 12                	jne    ffffffff800027b6 <_ntoa_format+0x76>
ffffffff800027a4:	e9 b7 02 00 00       	jmpq   ffffffff80002a60 <_ntoa_format+0x320>
ffffffff800027a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff800027b0:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff800027b4:	74 0f                	je     ffffffff800027c5 <_ntoa_format+0x85>
      buf[len++] = '0';
ffffffff800027b6:	49 83 c1 01          	add    $0x1,%r9
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800027ba:	49 39 d1             	cmp    %rdx,%r9
      buf[len++] = '0';
ffffffff800027bd:	42 c6 44 0b ff 30    	movb   $0x30,-0x1(%rbx,%r9,1)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800027c3:	72 eb                	jb     ffffffff800027b0 <_ntoa_format+0x70>
    }
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800027c5:	45 85 c0             	test   %r8d,%r8d
ffffffff800027c8:	74 2f                	je     ffffffff800027f9 <_ntoa_format+0xb9>
ffffffff800027ca:	44 8b 74 24 78       	mov    0x78(%rsp),%r14d
ffffffff800027cf:	4d 39 ce             	cmp    %r9,%r14
ffffffff800027d2:	76 25                	jbe    ffffffff800027f9 <_ntoa_format+0xb9>
ffffffff800027d4:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff800027d8:	75 10                	jne    ffffffff800027ea <_ntoa_format+0xaa>
ffffffff800027da:	e9 8b 03 00 00       	jmpq   ffffffff80002b6a <_ntoa_format+0x42a>
ffffffff800027df:	90                   	nop
ffffffff800027e0:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff800027e4:	0f 84 76 02 00 00    	je     ffffffff80002a60 <_ntoa_format+0x320>
      buf[len++] = '0';
ffffffff800027ea:	49 83 c1 01          	add    $0x1,%r9
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800027ee:	4d 39 f1             	cmp    %r14,%r9
      buf[len++] = '0';
ffffffff800027f1:	42 c6 44 0b ff 30    	movb   $0x30,-0x1(%rbx,%r9,1)
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800027f7:	75 e7                	jne    ffffffff800027e0 <_ntoa_format+0xa0>
    }
  }

  // handle hash
  if (flags & FLAGS_HASH) {
ffffffff800027f9:	85 f6                	test   %esi,%esi
ffffffff800027fb:	74 41                	je     ffffffff8000283e <_ntoa_format+0xfe>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff800027fd:	f6 c4 04             	test   $0x4,%ah
ffffffff80002800:	0f 85 5a 01 00 00    	jne    ffffffff80002960 <_ntoa_format+0x220>
ffffffff80002806:	4d 85 c9             	test   %r9,%r9
ffffffff80002809:	0f 85 31 01 00 00    	jne    ffffffff80002940 <_ntoa_format+0x200>
      len--;
      if (len && (base == 16U)) {
        len--;
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff8000280f:	83 7c 24 68 10       	cmpl   $0x10,0x68(%rsp)
ffffffff80002814:	0f 84 2f 03 00 00    	je     ffffffff80002b49 <_ntoa_format+0x409>
      buf[len++] = 'x';
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'X';
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff8000281a:	83 7c 24 68 02       	cmpl   $0x2,0x68(%rsp)
ffffffff8000281f:	0f 85 37 03 00 00    	jne    ffffffff80002b5c <_ntoa_format+0x41c>
      buf[len++] = 'b';
ffffffff80002825:	c6 03 62             	movb   $0x62,(%rbx)
ffffffff80002828:	48 c7 44 24 10 01 00 	movq   $0x1,0x10(%rsp)
ffffffff8000282f:	00 00 
ffffffff80002831:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
ffffffff80002836:	4c 8d 4e 01          	lea    0x1(%rsi),%r9
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
      buf[len++] = '0';
ffffffff8000283a:	c6 04 33 30          	movb   $0x30,(%rbx,%rsi,1)
    }
  }

  if (len < PRINTF_NTOA_BUFFER_SIZE) {
ffffffff8000283e:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff80002842:	0f 84 38 02 00 00    	je     ffffffff80002a80 <_ntoa_format+0x340>
    if (negative) {
ffffffff80002848:	40 84 ff             	test   %dil,%dil
ffffffff8000284b:	75 4b                	jne    ffffffff80002898 <_ntoa_format+0x158>
      buf[len++] = '-';
    }
    else if (flags & FLAGS_PLUS) {
ffffffff8000284d:	a8 04                	test   $0x4,%al
ffffffff8000284f:	0f 85 a3 01 00 00    	jne    ffffffff800029f8 <_ntoa_format+0x2b8>
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
ffffffff80002855:	a8 08                	test   $0x8,%al
ffffffff80002857:	0f 84 9b 02 00 00    	je     ffffffff80002af8 <_ntoa_format+0x3b8>
      buf[len++] = ' ';
ffffffff8000285d:	49 8d 41 01          	lea    0x1(%r9),%rax
ffffffff80002861:	42 c6 04 0b 20       	movb   $0x20,(%rbx,%r9,1)
ffffffff80002866:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff8000286b:	eb 39                	jmp    ffffffff800028a6 <_ntoa_format+0x166>
ffffffff8000286d:	0f 1f 00             	nopl   (%rax)
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
ffffffff80002870:	45 85 c0             	test   %r8d,%r8d
ffffffff80002873:	0f 84 97 01 00 00    	je     ffffffff80002a10 <_ntoa_format+0x2d0>
ffffffff80002879:	40 84 ff             	test   %dil,%dil
ffffffff8000287c:	75 04                	jne    ffffffff80002882 <_ntoa_format+0x142>
ffffffff8000287e:	a8 0c                	test   $0xc,%al
ffffffff80002880:	74 05                	je     ffffffff80002887 <_ntoa_format+0x147>
      width--;
ffffffff80002882:	83 6c 24 78 01       	subl   $0x1,0x78(%rsp)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002887:	49 39 d1             	cmp    %rdx,%r9
ffffffff8000288a:	0f 82 0e ff ff ff    	jb     ffffffff8000279e <_ntoa_format+0x5e>
ffffffff80002890:	e9 35 ff ff ff       	jmpq   ffffffff800027ca <_ntoa_format+0x8a>
ffffffff80002895:	0f 1f 00             	nopl   (%rax)
      buf[len++] = '-';
ffffffff80002898:	49 8d 41 01          	lea    0x1(%r9),%rax
ffffffff8000289c:	42 c6 04 0b 2d       	movb   $0x2d,(%rbx,%r9,1)
ffffffff800028a1:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800028a6:	85 c9                	test   %ecx,%ecx
ffffffff800028a8:	0f 84 fa 00 00 00    	je     ffffffff800029a8 <_ntoa_format+0x268>
ffffffff800028ae:	4c 8b 7c 24 08       	mov    0x8(%rsp),%r15
    for (size_t i = len; i < width; i++) {
ffffffff800028b3:	4c 8b 64 24 10       	mov    0x10(%rsp),%r12
ffffffff800028b8:	4c 89 fa             	mov    %r15,%rdx
ffffffff800028bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    out(buf[--len], buffer, idx++, maxlen);
ffffffff800028c0:	49 83 ec 01          	sub    $0x1,%r12
ffffffff800028c4:	4c 8d 72 01          	lea    0x1(%rdx),%r14
ffffffff800028c8:	4c 89 e9             	mov    %r13,%rcx
ffffffff800028cb:	42 0f be 3c 23       	movsbl (%rbx,%r12,1),%edi
ffffffff800028d0:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800028d4:	ff d5                	callq  *%rbp
  while (len) {
ffffffff800028d6:	4d 85 e4             	test   %r12,%r12
    out(buf[--len], buffer, idx++, maxlen);
ffffffff800028d9:	4c 89 f2             	mov    %r14,%rdx
  while (len) {
ffffffff800028dc:	75 e2                	jne    ffffffff800028c0 <_ntoa_format+0x180>
ffffffff800028de:	4c 03 7c 24 10       	add    0x10(%rsp),%r15
  if (flags & FLAGS_LEFT) {
ffffffff800028e3:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
ffffffff800028e7:	85 c0                	test   %eax,%eax
ffffffff800028e9:	74 3a                	je     ffffffff80002925 <_ntoa_format+0x1e5>
    while (idx - start_idx < width) {
ffffffff800028eb:	44 8b 74 24 78       	mov    0x78(%rsp),%r14d
ffffffff800028f0:	4c 89 fa             	mov    %r15,%rdx
ffffffff800028f3:	48 2b 54 24 08       	sub    0x8(%rsp),%rdx
ffffffff800028f8:	49 39 d6             	cmp    %rdx,%r14
ffffffff800028fb:	76 28                	jbe    ffffffff80002925 <_ntoa_format+0x1e5>
ffffffff800028fd:	0f 1f 00             	nopl   (%rax)
      out(' ', buffer, idx++, maxlen);
ffffffff80002900:	49 8d 5f 01          	lea    0x1(%r15),%rbx
ffffffff80002904:	4c 89 fa             	mov    %r15,%rdx
ffffffff80002907:	4c 89 e9             	mov    %r13,%rcx
ffffffff8000290a:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000290e:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80002913:	ff d5                	callq  *%rbp
    while (idx - start_idx < width) {
ffffffff80002915:	48 89 da             	mov    %rbx,%rdx
ffffffff80002918:	48 2b 54 24 08       	sub    0x8(%rsp),%rdx
      out(' ', buffer, idx++, maxlen);
ffffffff8000291d:	49 89 df             	mov    %rbx,%r15
    while (idx - start_idx < width) {
ffffffff80002920:	4c 39 f2             	cmp    %r14,%rdx
ffffffff80002923:	72 db                	jb     ffffffff80002900 <_ntoa_format+0x1c0>
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}
ffffffff80002925:	48 83 c4 28          	add    $0x28,%rsp
ffffffff80002929:	4c 89 f8             	mov    %r15,%rax
ffffffff8000292c:	5b                   	pop    %rbx
ffffffff8000292d:	5d                   	pop    %rbp
ffffffff8000292e:	41 5c                	pop    %r12
ffffffff80002930:	41 5d                	pop    %r13
ffffffff80002932:	41 5e                	pop    %r14
ffffffff80002934:	41 5f                	pop    %r15
ffffffff80002936:	c3                   	retq   
ffffffff80002937:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000293e:	00 00 
ffffffff80002940:	8b 54 24 70          	mov    0x70(%rsp),%edx
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff80002944:	4c 39 ca             	cmp    %r9,%rdx
ffffffff80002947:	0f 84 e3 00 00 00    	je     ffffffff80002a30 <_ntoa_format+0x2f0>
ffffffff8000294d:	8b 54 24 78          	mov    0x78(%rsp),%edx
ffffffff80002951:	4c 39 ca             	cmp    %r9,%rdx
ffffffff80002954:	0f 84 d6 00 00 00    	je     ffffffff80002a30 <_ntoa_format+0x2f0>
ffffffff8000295a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff80002960:	49 83 f9 1f          	cmp    $0x1f,%r9
ffffffff80002964:	0f 96 c2             	setbe  %dl
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002967:	83 7c 24 68 10       	cmpl   $0x10,0x68(%rsp)
ffffffff8000296c:	0f 84 1e 01 00 00    	je     ffffffff80002a90 <_ntoa_format+0x350>
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002972:	83 7c 24 68 02       	cmpl   $0x2,0x68(%rsp)
ffffffff80002977:	0f 85 a3 00 00 00    	jne    ffffffff80002a20 <_ntoa_format+0x2e0>
ffffffff8000297d:	84 d2                	test   %dl,%dl
ffffffff8000297f:	0f 84 9b 00 00 00    	je     ffffffff80002a20 <_ntoa_format+0x2e0>
ffffffff80002985:	49 8d 71 01          	lea    0x1(%r9),%rsi
      buf[len++] = 'b';
ffffffff80002989:	42 c6 04 0b 62       	movb   $0x62,(%rbx,%r9,1)
ffffffff8000298e:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
ffffffff80002993:	48 83 7c 24 10 1f    	cmpq   $0x1f,0x10(%rsp)
ffffffff80002999:	0f 86 92 fe ff ff    	jbe    ffffffff80002831 <_ntoa_format+0xf1>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff8000299f:	85 c9                	test   %ecx,%ecx
ffffffff800029a1:	4c 8b 7c 24 08       	mov    0x8(%rsp),%r15
ffffffff800029a6:	75 3a                	jne    ffffffff800029e2 <_ntoa_format+0x2a2>
ffffffff800029a8:	44 8b 74 24 78       	mov    0x78(%rsp),%r14d
    for (size_t i = len; i < width; i++) {
ffffffff800029ad:	4c 3b 74 24 10       	cmp    0x10(%rsp),%r14
ffffffff800029b2:	0f 86 50 01 00 00    	jbe    ffffffff80002b08 <_ntoa_format+0x3c8>
ffffffff800029b8:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff800029bd:	49 01 d6             	add    %rdx,%r14
ffffffff800029c0:	4c 2b 74 24 10       	sub    0x10(%rsp),%r14
ffffffff800029c5:	0f 1f 00             	nopl   (%rax)
      out(' ', buffer, idx++, maxlen);
ffffffff800029c8:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
ffffffff800029cc:	4c 89 e9             	mov    %r13,%rcx
ffffffff800029cf:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800029d3:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff800029d8:	ff d5                	callq  *%rbp
    for (size_t i = len; i < width; i++) {
ffffffff800029da:	4d 39 f7             	cmp    %r14,%r15
ffffffff800029dd:	4c 89 fa             	mov    %r15,%rdx
ffffffff800029e0:	75 e6                	jne    ffffffff800029c8 <_ntoa_format+0x288>
  while (len) {
ffffffff800029e2:	48 83 7c 24 10 00    	cmpq   $0x0,0x10(%rsp)
ffffffff800029e8:	0f 85 c5 fe ff ff    	jne    ffffffff800028b3 <_ntoa_format+0x173>
ffffffff800029ee:	e9 f0 fe ff ff       	jmpq   ffffffff800028e3 <_ntoa_format+0x1a3>
ffffffff800029f3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      buf[len++] = '+';  // ignore the space if the '+' exists
ffffffff800029f8:	49 8d 41 01          	lea    0x1(%r9),%rax
ffffffff800029fc:	42 c6 04 0b 2b       	movb   $0x2b,(%rbx,%r9,1)
ffffffff80002a01:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff80002a06:	e9 9b fe ff ff       	jmpq   ffffffff800028a6 <_ntoa_format+0x166>
ffffffff80002a0b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002a10:	49 39 d1             	cmp    %rdx,%r9
ffffffff80002a13:	0f 82 85 fd ff ff    	jb     ffffffff8000279e <_ntoa_format+0x5e>
ffffffff80002a19:	e9 db fd ff ff       	jmpq   ffffffff800027f9 <_ntoa_format+0xb9>
ffffffff80002a1e:	66 90                	xchg   %ax,%ax
ffffffff80002a20:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
ffffffff80002a25:	e9 69 ff ff ff       	jmpq   ffffffff80002993 <_ntoa_format+0x253>
ffffffff80002a2a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      if (len && (base == 16U)) {
ffffffff80002a30:	4d 89 c8             	mov    %r9,%r8
ffffffff80002a33:	49 83 e8 01          	sub    $0x1,%r8
ffffffff80002a37:	0f 95 c2             	setne  %dl
ffffffff80002a3a:	83 7c 24 68 10       	cmpl   $0x10,0x68(%rsp)
ffffffff80002a3f:	40 0f 94 c6          	sete   %sil
ffffffff80002a43:	40 20 f2             	and    %sil,%dl
ffffffff80002a46:	0f 84 d9 00 00 00    	je     ffffffff80002b25 <_ntoa_format+0x3e5>
        len--;
ffffffff80002a4c:	49 8d 71 fe          	lea    -0x2(%r9),%rsi
ffffffff80002a50:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
ffffffff80002a55:	eb 3e                	jmp    ffffffff80002a95 <_ntoa_format+0x355>
ffffffff80002a57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80002a5e:	00 00 
  if (flags & FLAGS_HASH) {
ffffffff80002a60:	85 f6                	test   %esi,%esi
ffffffff80002a62:	74 6c                	je     ffffffff80002ad0 <_ntoa_format+0x390>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff80002a64:	f6 c4 04             	test   $0x4,%ah
ffffffff80002a67:	41 b9 20 00 00 00    	mov    $0x20,%r9d
ffffffff80002a6d:	0f 84 d1 fe ff ff    	je     ffffffff80002944 <_ntoa_format+0x204>
ffffffff80002a73:	e9 e8 fe ff ff       	jmpq   ffffffff80002960 <_ntoa_format+0x220>
ffffffff80002a78:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80002a7f:	00 
ffffffff80002a80:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff80002a87:	00 00 
ffffffff80002a89:	e9 18 fe ff ff       	jmpq   ffffffff800028a6 <_ntoa_format+0x166>
ffffffff80002a8e:	66 90                	xchg   %ax,%ax
ffffffff80002a90:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002a95:	89 c6                	mov    %eax,%esi
ffffffff80002a97:	83 e6 20             	and    $0x20,%esi
ffffffff80002a9a:	75 08                	jne    ffffffff80002aa4 <_ntoa_format+0x364>
ffffffff80002a9c:	84 d2                	test   %dl,%dl
ffffffff80002a9e:	0f 85 8e 00 00 00    	jne    ffffffff80002b32 <_ntoa_format+0x3f2>
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002aa4:	85 f6                	test   %esi,%esi
ffffffff80002aa6:	0f 84 e7 fe ff ff    	je     ffffffff80002993 <_ntoa_format+0x253>
ffffffff80002aac:	84 d2                	test   %dl,%dl
ffffffff80002aae:	0f 84 df fe ff ff    	je     ffffffff80002993 <_ntoa_format+0x253>
      buf[len++] = 'X';
ffffffff80002ab4:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
ffffffff80002ab9:	c6 04 33 58          	movb   $0x58,(%rbx,%rsi,1)
ffffffff80002abd:	48 83 c6 01          	add    $0x1,%rsi
ffffffff80002ac1:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
ffffffff80002ac6:	e9 c8 fe ff ff       	jmpq   ffffffff80002993 <_ntoa_format+0x253>
ffffffff80002acb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff80002ad0:	85 c9                	test   %ecx,%ecx
ffffffff80002ad2:	75 3e                	jne    ffffffff80002b12 <_ntoa_format+0x3d2>
ffffffff80002ad4:	44 8b 74 24 78       	mov    0x78(%rsp),%r14d
    for (size_t i = len; i < width; i++) {
ffffffff80002ad9:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff80002ae0:	00 00 
ffffffff80002ae2:	49 83 fe 20          	cmp    $0x20,%r14
ffffffff80002ae6:	0f 87 cc fe ff ff    	ja     ffffffff800029b8 <_ntoa_format+0x278>
ffffffff80002aec:	e9 bd fd ff ff       	jmpq   ffffffff800028ae <_ntoa_format+0x16e>
ffffffff80002af1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff80002af8:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
ffffffff80002afd:	e9 9d fe ff ff       	jmpq   ffffffff8000299f <_ntoa_format+0x25f>
ffffffff80002b02:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff80002b08:	4c 8b 7c 24 08       	mov    0x8(%rsp),%r15
ffffffff80002b0d:	e9 d0 fe ff ff       	jmpq   ffffffff800029e2 <_ntoa_format+0x2a2>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff80002b12:	4c 8b 7c 24 08       	mov    0x8(%rsp),%r15
ffffffff80002b17:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff80002b1e:	00 00 
ffffffff80002b20:	e9 8e fd ff ff       	jmpq   ffffffff800028b3 <_ntoa_format+0x173>
      len--;
ffffffff80002b25:	4d 89 c1             	mov    %r8,%r9
ffffffff80002b28:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80002b2d:	e9 35 fe ff ff       	jmpq   ffffffff80002967 <_ntoa_format+0x227>
      buf[len++] = 'x';
ffffffff80002b32:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
ffffffff80002b37:	c6 04 33 78          	movb   $0x78,(%rbx,%rsi,1)
ffffffff80002b3b:	48 83 c6 01          	add    $0x1,%rsi
ffffffff80002b3f:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
ffffffff80002b44:	e9 4a fe ff ff       	jmpq   ffffffff80002993 <_ntoa_format+0x253>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002b49:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
ffffffff80002b50:	00 00 
ffffffff80002b52:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80002b57:	e9 39 ff ff ff       	jmpq   ffffffff80002a95 <_ntoa_format+0x355>
      buf[len++] = '0';
ffffffff80002b5c:	c6 03 30             	movb   $0x30,(%rbx)
ffffffff80002b5f:	41 b9 01 00 00 00    	mov    $0x1,%r9d
ffffffff80002b65:	e9 de fc ff ff       	jmpq   ffffffff80002848 <_ntoa_format+0x108>
  if (flags & FLAGS_HASH) {
ffffffff80002b6a:	85 f6                	test   %esi,%esi
ffffffff80002b6c:	74 17                	je     ffffffff80002b85 <_ntoa_format+0x445>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff80002b6e:	f6 c4 04             	test   $0x4,%ah
ffffffff80002b71:	0f 84 cd fd ff ff    	je     ffffffff80002944 <_ntoa_format+0x204>
ffffffff80002b77:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff80002b7e:	00 00 
ffffffff80002b80:	e9 1a fe ff ff       	jmpq   ffffffff8000299f <_ntoa_format+0x25f>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff80002b85:	85 c9                	test   %ecx,%ecx
    for (size_t i = len; i < width; i++) {
ffffffff80002b87:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff80002b8e:	00 00 
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff80002b90:	0f 85 18 fd ff ff    	jne    ffffffff800028ae <_ntoa_format+0x16e>
    for (size_t i = len; i < width; i++) {
ffffffff80002b96:	49 83 fe 20          	cmp    $0x20,%r14
ffffffff80002b9a:	0f 87 18 fe ff ff    	ja     ffffffff800029b8 <_ntoa_format+0x278>
ffffffff80002ba0:	e9 09 fd ff ff       	jmpq   ffffffff800028ae <_ntoa_format+0x16e>
ffffffff80002ba5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80002bac:	00 00 00 00 

ffffffff80002bb0 <_ntoa_long>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
ffffffff80002bb0:	41 55                	push   %r13
ffffffff80002bb2:	41 54                	push   %r12
ffffffff80002bb4:	4c 89 c0             	mov    %r8,%rax
ffffffff80002bb7:	55                   	push   %rbp
ffffffff80002bb8:	53                   	push   %rbx
ffffffff80002bb9:	48 89 d3             	mov    %rdx,%rbx
ffffffff80002bbc:	48 83 ec 28          	sub    $0x28,%rsp
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
ffffffff80002bc0:	4d 85 c0             	test   %r8,%r8
{
ffffffff80002bc3:	4c 8b 54 24 50       	mov    0x50(%rsp),%r10
ffffffff80002bc8:	8b 6c 24 68          	mov    0x68(%rsp),%ebp
  if (!value) {
ffffffff80002bcc:	75 13                	jne    ffffffff80002be1 <_ntoa_long+0x31>
    flags &= ~FLAGS_HASH;
ffffffff80002bce:	89 ea                	mov    %ebp,%edx
ffffffff80002bd0:	83 e2 ef             	and    $0xffffffef,%edx
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff80002bd3:	81 e5 00 04 00 00    	and    $0x400,%ebp
    flags &= ~FLAGS_HASH;
ffffffff80002bd9:	89 d5                	mov    %edx,%ebp
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff80002bdb:	0f 85 7f 00 00 00    	jne    ffffffff80002c60 <_ntoa_long+0xb0>
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80002be1:	89 ea                	mov    %ebp,%edx
ffffffff80002be3:	83 e2 20             	and    $0x20,%edx
ffffffff80002be6:	83 fa 01             	cmp    $0x1,%edx
ffffffff80002be9:	45 19 db             	sbb    %r11d,%r11d
ffffffff80002bec:	45 31 c0             	xor    %r8d,%r8d
ffffffff80002bef:	41 83 e3 20          	and    $0x20,%r11d
ffffffff80002bf3:	41 83 c3 37          	add    $0x37,%r11d
ffffffff80002bf7:	eb 0d                	jmp    ffffffff80002c06 <_ntoa_long+0x56>
ffffffff80002bf9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002c00:	49 83 f8 1f          	cmp    $0x1f,%r8
ffffffff80002c04:	77 26                	ja     ffffffff80002c2c <_ntoa_long+0x7c>
ffffffff80002c06:	31 d2                	xor    %edx,%edx
ffffffff80002c08:	49 f7 f2             	div    %r10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80002c0b:	44 8d 6a 30          	lea    0x30(%rdx),%r13d
ffffffff80002c0f:	45 8d 24 13          	lea    (%r11,%rdx,1),%r12d
ffffffff80002c13:	48 83 fa 09          	cmp    $0x9,%rdx
ffffffff80002c17:	44 89 ea             	mov    %r13d,%edx
ffffffff80002c1a:	41 0f 47 d4          	cmova  %r12d,%edx
ffffffff80002c1e:	49 83 c0 01          	add    $0x1,%r8
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002c22:	48 85 c0             	test   %rax,%rax
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80002c25:	42 88 54 04 ff       	mov    %dl,-0x1(%rsp,%r8,1)
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002c2a:	75 d4                	jne    ffffffff80002c00 <_ntoa_long+0x50>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
ffffffff80002c2c:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80002c30:	45 0f b6 c9          	movzbl %r9b,%r9d
ffffffff80002c34:	48 89 da             	mov    %rbx,%rdx
ffffffff80002c37:	55                   	push   %rbp
ffffffff80002c38:	8b 44 24 70          	mov    0x70(%rsp),%eax
ffffffff80002c3c:	50                   	push   %rax
ffffffff80002c3d:	8b 44 24 70          	mov    0x70(%rsp),%eax
ffffffff80002c41:	50                   	push   %rax
ffffffff80002c42:	41 52                	push   %r10
ffffffff80002c44:	41 51                	push   %r9
ffffffff80002c46:	4d 89 c1             	mov    %r8,%r9
ffffffff80002c49:	4c 8d 44 24 30       	lea    0x30(%rsp),%r8
ffffffff80002c4e:	e8 ed fa ff ff       	callq  ffffffff80002740 <_ntoa_format>
}
ffffffff80002c53:	48 83 c4 58          	add    $0x58,%rsp
ffffffff80002c57:	5b                   	pop    %rbx
ffffffff80002c58:	5d                   	pop    %rbp
ffffffff80002c59:	41 5c                	pop    %r12
ffffffff80002c5b:	41 5d                	pop    %r13
ffffffff80002c5d:	c3                   	retq   
ffffffff80002c5e:	66 90                	xchg   %ax,%ax
  size_t len = 0U;
ffffffff80002c60:	45 31 c0             	xor    %r8d,%r8d
ffffffff80002c63:	eb c7                	jmp    ffffffff80002c2c <_ntoa_long+0x7c>
ffffffff80002c65:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80002c6c:	00 00 00 00 

ffffffff80002c70 <_ntoa_long_long>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
ffffffff80002c70:	41 55                	push   %r13
ffffffff80002c72:	41 54                	push   %r12
ffffffff80002c74:	4c 89 c0             	mov    %r8,%rax
ffffffff80002c77:	55                   	push   %rbp
ffffffff80002c78:	53                   	push   %rbx
ffffffff80002c79:	48 89 d3             	mov    %rdx,%rbx
ffffffff80002c7c:	48 83 ec 28          	sub    $0x28,%rsp
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
ffffffff80002c80:	4d 85 c0             	test   %r8,%r8
{
ffffffff80002c83:	4c 8b 54 24 50       	mov    0x50(%rsp),%r10
ffffffff80002c88:	8b 6c 24 68          	mov    0x68(%rsp),%ebp
  if (!value) {
ffffffff80002c8c:	75 13                	jne    ffffffff80002ca1 <_ntoa_long_long+0x31>
    flags &= ~FLAGS_HASH;
ffffffff80002c8e:	89 ea                	mov    %ebp,%edx
ffffffff80002c90:	83 e2 ef             	and    $0xffffffef,%edx
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff80002c93:	81 e5 00 04 00 00    	and    $0x400,%ebp
    flags &= ~FLAGS_HASH;
ffffffff80002c99:	89 d5                	mov    %edx,%ebp
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff80002c9b:	0f 85 7f 00 00 00    	jne    ffffffff80002d20 <_ntoa_long_long+0xb0>
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80002ca1:	89 ea                	mov    %ebp,%edx
ffffffff80002ca3:	83 e2 20             	and    $0x20,%edx
ffffffff80002ca6:	83 fa 01             	cmp    $0x1,%edx
ffffffff80002ca9:	45 19 db             	sbb    %r11d,%r11d
ffffffff80002cac:	45 31 c0             	xor    %r8d,%r8d
ffffffff80002caf:	41 83 e3 20          	and    $0x20,%r11d
ffffffff80002cb3:	41 83 c3 37          	add    $0x37,%r11d
ffffffff80002cb7:	eb 0d                	jmp    ffffffff80002cc6 <_ntoa_long_long+0x56>
ffffffff80002cb9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002cc0:	49 83 f8 1f          	cmp    $0x1f,%r8
ffffffff80002cc4:	77 26                	ja     ffffffff80002cec <_ntoa_long_long+0x7c>
ffffffff80002cc6:	31 d2                	xor    %edx,%edx
ffffffff80002cc8:	49 f7 f2             	div    %r10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80002ccb:	44 8d 6a 30          	lea    0x30(%rdx),%r13d
ffffffff80002ccf:	45 8d 24 13          	lea    (%r11,%rdx,1),%r12d
ffffffff80002cd3:	48 83 fa 09          	cmp    $0x9,%rdx
ffffffff80002cd7:	44 89 ea             	mov    %r13d,%edx
ffffffff80002cda:	41 0f 47 d4          	cmova  %r12d,%edx
ffffffff80002cde:	49 83 c0 01          	add    $0x1,%r8
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002ce2:	48 85 c0             	test   %rax,%rax
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80002ce5:	42 88 54 04 ff       	mov    %dl,-0x1(%rsp,%r8,1)
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002cea:	75 d4                	jne    ffffffff80002cc0 <_ntoa_long_long+0x50>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
ffffffff80002cec:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80002cf0:	45 0f b6 c9          	movzbl %r9b,%r9d
ffffffff80002cf4:	48 89 da             	mov    %rbx,%rdx
ffffffff80002cf7:	55                   	push   %rbp
ffffffff80002cf8:	8b 44 24 70          	mov    0x70(%rsp),%eax
ffffffff80002cfc:	50                   	push   %rax
ffffffff80002cfd:	8b 44 24 70          	mov    0x70(%rsp),%eax
ffffffff80002d01:	50                   	push   %rax
ffffffff80002d02:	41 52                	push   %r10
ffffffff80002d04:	41 51                	push   %r9
ffffffff80002d06:	4d 89 c1             	mov    %r8,%r9
ffffffff80002d09:	4c 8d 44 24 30       	lea    0x30(%rsp),%r8
ffffffff80002d0e:	e8 2d fa ff ff       	callq  ffffffff80002740 <_ntoa_format>
}
ffffffff80002d13:	48 83 c4 58          	add    $0x58,%rsp
ffffffff80002d17:	5b                   	pop    %rbx
ffffffff80002d18:	5d                   	pop    %rbp
ffffffff80002d19:	41 5c                	pop    %r12
ffffffff80002d1b:	41 5d                	pop    %r13
ffffffff80002d1d:	c3                   	retq   
ffffffff80002d1e:	66 90                	xchg   %ax,%ax
  size_t len = 0U;
ffffffff80002d20:	45 31 c0             	xor    %r8d,%r8d
ffffffff80002d23:	eb c7                	jmp    ffffffff80002cec <_ntoa_long_long+0x7c>
ffffffff80002d25:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80002d2c:	00 00 00 00 

ffffffff80002d30 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
ffffffff80002d30:	41 57                	push   %r15
ffffffff80002d32:	41 56                	push   %r14
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
ffffffff80002d34:	48 c7 c0 10 27 00 80 	mov    $0xffffffff80002710,%rax
{
ffffffff80002d3b:	41 55                	push   %r13
ffffffff80002d3d:	41 54                	push   %r12
ffffffff80002d3f:	49 89 f7             	mov    %rsi,%r15
ffffffff80002d42:	55                   	push   %rbp
ffffffff80002d43:	53                   	push   %rbx
ffffffff80002d44:	48 89 fd             	mov    %rdi,%rbp
ffffffff80002d47:	49 89 d6             	mov    %rdx,%r14
ffffffff80002d4a:	49 89 cd             	mov    %rcx,%r13
ffffffff80002d4d:	48 83 ec 38          	sub    $0x38,%rsp
    out = _out_null;
ffffffff80002d51:	48 85 f6             	test   %rsi,%rsi
ffffffff80002d54:	48 0f 44 e8          	cmove  %rax,%rbp
{
ffffffff80002d58:	4c 89 04 24          	mov    %r8,(%rsp)
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
ffffffff80002d5c:	31 db                	xor    %ebx,%ebx
  while (*format)
ffffffff80002d5e:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
ffffffff80002d63:	40 84 ff             	test   %dil,%dil
ffffffff80002d66:	74 26                	je     ffffffff80002d8e <_vsnprintf+0x5e>
ffffffff80002d68:	49 83 c5 01          	add    $0x1,%r13
    if (*format != '%') {
ffffffff80002d6c:	40 80 ff 25          	cmp    $0x25,%dil
ffffffff80002d70:	74 46                	je     ffffffff80002db8 <_vsnprintf+0x88>
      out(*format, buffer, idx++, maxlen);
ffffffff80002d72:	4c 8d 63 01          	lea    0x1(%rbx),%r12
        out(*format, buffer, idx++, maxlen);
ffffffff80002d76:	48 89 da             	mov    %rbx,%rdx
ffffffff80002d79:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002d7c:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002d7f:	ff d5                	callq  *%rbp
  while (*format)
ffffffff80002d81:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
        out(*format, buffer, idx++, maxlen);
ffffffff80002d86:	4c 89 e3             	mov    %r12,%rbx
  while (*format)
ffffffff80002d89:	40 84 ff             	test   %dil,%dil
ffffffff80002d8c:	75 da                	jne    ffffffff80002d68 <_vsnprintf+0x38>
        break;
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
ffffffff80002d8e:	49 8d 56 ff          	lea    -0x1(%r14),%rdx
ffffffff80002d92:	4c 39 f3             	cmp    %r14,%rbx
ffffffff80002d95:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002d98:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002d9b:	48 0f 42 d3          	cmovb  %rbx,%rdx
ffffffff80002d9f:	31 ff                	xor    %edi,%edi
ffffffff80002da1:	ff d5                	callq  *%rbp

  // return written chars without terminating \0
  return (int)idx;
}
ffffffff80002da3:	48 83 c4 38          	add    $0x38,%rsp
ffffffff80002da7:	89 d8                	mov    %ebx,%eax
ffffffff80002da9:	5b                   	pop    %rbx
ffffffff80002daa:	5d                   	pop    %rbp
ffffffff80002dab:	41 5c                	pop    %r12
ffffffff80002dad:	41 5d                	pop    %r13
ffffffff80002daf:	41 5e                	pop    %r14
ffffffff80002db1:	41 5f                	pop    %r15
ffffffff80002db3:	c3                   	retq   
ffffffff80002db4:	0f 1f 40 00          	nopl   0x0(%rax)
    flags = 0U;
ffffffff80002db8:	31 c9                	xor    %ecx,%ecx
ffffffff80002dba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      switch (*format) {
ffffffff80002dc0:	41 0f be 45 00       	movsbl 0x0(%r13),%eax
ffffffff80002dc5:	49 8d 75 01          	lea    0x1(%r13),%rsi
ffffffff80002dc9:	48 89 f7             	mov    %rsi,%rdi
ffffffff80002dcc:	8d 50 e0             	lea    -0x20(%rax),%edx
ffffffff80002dcf:	80 fa 10             	cmp    $0x10,%dl
ffffffff80002dd2:	77 3c                	ja     ffffffff80002e10 <_vsnprintf+0xe0>
ffffffff80002dd4:	0f b6 d2             	movzbl %dl,%edx
ffffffff80002dd7:	ff 24 d5 e0 53 00 80 	jmpq   *-0x7fffac20(,%rdx,8)
ffffffff80002dde:	66 90                	xchg   %ax,%ax
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
ffffffff80002de0:	83 c9 01             	or     $0x1,%ecx
ffffffff80002de3:	49 89 f5             	mov    %rsi,%r13
ffffffff80002de6:	eb d8                	jmp    ffffffff80002dc0 <_vsnprintf+0x90>
ffffffff80002de8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80002def:	00 
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
ffffffff80002df0:	83 c9 04             	or     $0x4,%ecx
ffffffff80002df3:	eb ee                	jmp    ffffffff80002de3 <_vsnprintf+0xb3>
ffffffff80002df5:	0f 1f 00             	nopl   (%rax)
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
ffffffff80002df8:	83 c9 02             	or     $0x2,%ecx
ffffffff80002dfb:	eb e6                	jmp    ffffffff80002de3 <_vsnprintf+0xb3>
ffffffff80002dfd:	0f 1f 00             	nopl   (%rax)
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
ffffffff80002e00:	83 c9 10             	or     $0x10,%ecx
ffffffff80002e03:	eb de                	jmp    ffffffff80002de3 <_vsnprintf+0xb3>
ffffffff80002e05:	0f 1f 00             	nopl   (%rax)
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
ffffffff80002e08:	83 c9 08             	or     $0x8,%ecx
ffffffff80002e0b:	eb d6                	jmp    ffffffff80002de3 <_vsnprintf+0xb3>
ffffffff80002e0d:	0f 1f 00             	nopl   (%rax)
  return (ch >= '0') && (ch <= '9');
ffffffff80002e10:	8d 50 d0             	lea    -0x30(%rax),%edx
    if (_is_digit(*format)) {
ffffffff80002e13:	80 fa 09             	cmp    $0x9,%dl
ffffffff80002e16:	0f 86 54 02 00 00    	jbe    ffffffff80003070 <_vsnprintf+0x340>
    width = 0U;
ffffffff80002e1c:	45 31 e4             	xor    %r12d,%r12d
    else if (*format == '*') {
ffffffff80002e1f:	3c 2a                	cmp    $0x2a,%al
ffffffff80002e21:	0f 84 75 07 00 00    	je     ffffffff8000359c <_vsnprintf+0x86c>
    precision = 0U;
ffffffff80002e27:	45 31 d2             	xor    %r10d,%r10d
    if (*format == '.') {
ffffffff80002e2a:	3c 2e                	cmp    $0x2e,%al
ffffffff80002e2c:	0f 84 73 02 00 00    	je     ffffffff800030a5 <_vsnprintf+0x375>
    switch (*format) {
ffffffff80002e32:	3c 6a                	cmp    $0x6a,%al
ffffffff80002e34:	74 12                	je     ffffffff80002e48 <_vsnprintf+0x118>
ffffffff80002e36:	0f 8e bc 02 00 00    	jle    ffffffff800030f8 <_vsnprintf+0x3c8>
ffffffff80002e3c:	3c 6c                	cmp    $0x6c,%al
ffffffff80002e3e:	74 30                	je     ffffffff80002e70 <_vsnprintf+0x140>
ffffffff80002e40:	3c 7a                	cmp    $0x7a,%al
ffffffff80002e42:	0f 85 d0 02 00 00    	jne    ffffffff80003118 <_vsnprintf+0x3e8>
ffffffff80002e48:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
ffffffff80002e4d:	4c 8d 6f 01          	lea    0x1(%rdi),%r13
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
ffffffff80002e51:	80 cd 01             	or     $0x1,%ch
    switch (*format) {
ffffffff80002e54:	8d 50 db             	lea    -0x25(%rax),%edx
ffffffff80002e57:	80 fa 53             	cmp    $0x53,%dl
ffffffff80002e5a:	0f 87 00 02 00 00    	ja     ffffffff80003060 <_vsnprintf+0x330>
ffffffff80002e60:	0f b6 d2             	movzbl %dl,%edx
ffffffff80002e63:	ff 24 d5 68 54 00 80 	jmpq   *-0x7fffab98(,%rdx,8)
ffffffff80002e6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        if (*format == 'l') {
ffffffff80002e70:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
ffffffff80002e75:	3c 6c                	cmp    $0x6c,%al
ffffffff80002e77:	0f 84 98 04 00 00    	je     ffffffff80003315 <_vsnprintf+0x5e5>
        flags |= FLAGS_LONG;
ffffffff80002e7d:	80 cd 01             	or     $0x1,%ch
ffffffff80002e80:	4c 8d 6f 01          	lea    0x1(%rdi),%r13
ffffffff80002e84:	eb ce                	jmp    ffffffff80002e54 <_vsnprintf+0x124>
ffffffff80002e86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80002e8d:	00 00 00 
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
ffffffff80002e90:	48 8b 34 24          	mov    (%rsp),%rsi
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
ffffffff80002e94:	83 c9 21             	or     $0x21,%ecx
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
ffffffff80002e97:	8b 06                	mov    (%rsi),%eax
ffffffff80002e99:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff80002e9c:	0f 87 45 08 00 00    	ja     ffffffff800036e7 <_vsnprintf+0x9b7>
ffffffff80002ea2:	89 c2                	mov    %eax,%edx
ffffffff80002ea4:	48 03 56 10          	add    0x10(%rsi),%rdx
ffffffff80002ea8:	83 c0 08             	add    $0x8,%eax
ffffffff80002eab:	89 06                	mov    %eax,(%rsi)
ffffffff80002ead:	51                   	push   %rcx
ffffffff80002eae:	6a 10                	pushq  $0x10
ffffffff80002eb0:	45 31 c9             	xor    %r9d,%r9d
ffffffff80002eb3:	41 52                	push   %r10
ffffffff80002eb5:	6a 10                	pushq  $0x10
ffffffff80002eb7:	4c 8b 02             	mov    (%rdx),%r8
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
ffffffff80002eba:	48 89 da             	mov    %rbx,%rdx
ffffffff80002ebd:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002ec0:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002ec3:	48 89 ef             	mov    %rbp,%rdi
ffffffff80002ec6:	e8 a5 fd ff ff       	callq  ffffffff80002c70 <_ntoa_long_long>
ffffffff80002ecb:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80002ecf:	48 89 c3             	mov    %rax,%rbx
ffffffff80002ed2:	e9 87 fe ff ff       	jmpq   ffffffff80002d5e <_vsnprintf+0x2e>
ffffffff80002ed7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80002ede:	00 00 
ffffffff80002ee0:	4c 8d 43 01          	lea    0x1(%rbx),%r8
        if (!(flags & FLAGS_LEFT)) {
ffffffff80002ee4:	83 e1 02             	and    $0x2,%ecx
ffffffff80002ee7:	4c 89 c0             	mov    %r8,%rax
ffffffff80002eea:	0f 84 47 04 00 00    	je     ffffffff80003337 <_vsnprintf+0x607>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff80002ef0:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002ef4:	8b 16                	mov    (%rsi),%edx
ffffffff80002ef6:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002ef9:	0f 87 34 06 00 00    	ja     ffffffff80003533 <_vsnprintf+0x803>
ffffffff80002eff:	89 d1                	mov    %edx,%ecx
ffffffff80002f01:	48 03 4e 10          	add    0x10(%rsi),%rcx
ffffffff80002f05:	83 c2 08             	add    $0x8,%edx
ffffffff80002f08:	89 16                	mov    %edx,(%rsi)
ffffffff80002f0a:	0f be 39             	movsbl (%rcx),%edi
ffffffff80002f0d:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
ffffffff80002f12:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002f15:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff80002f1a:	48 89 da             	mov    %rbx,%rdx
ffffffff80002f1d:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002f20:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff80002f22:	41 83 fc 01          	cmp    $0x1,%r12d
ffffffff80002f26:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff80002f2b:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
ffffffff80002f30:	0f 86 e8 02 00 00    	jbe    ffffffff8000321e <_vsnprintf+0x4ee>
ffffffff80002f36:	41 8d 4c 24 fe       	lea    -0x2(%r12),%ecx
ffffffff80002f3b:	48 83 c3 02          	add    $0x2,%rbx
ffffffff80002f3f:	48 89 c2             	mov    %rax,%rdx
ffffffff80002f42:	48 89 5c 24 10       	mov    %rbx,0x10(%rsp)
ffffffff80002f47:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
ffffffff80002f4c:	48 01 cb             	add    %rcx,%rbx
            out(' ', buffer, idx++, maxlen);
ffffffff80002f4f:	4c 8d 62 01          	lea    0x1(%rdx),%r12
ffffffff80002f53:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002f56:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002f59:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80002f5e:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff80002f60:	49 39 dc             	cmp    %rbx,%r12
ffffffff80002f63:	4c 89 e2             	mov    %r12,%rdx
ffffffff80002f66:	75 e7                	jne    ffffffff80002f4f <_vsnprintf+0x21f>
ffffffff80002f68:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
ffffffff80002f6d:	48 03 5c 24 08       	add    0x8(%rsp),%rbx
        break;
ffffffff80002f72:	e9 e7 fd ff ff       	jmpq   ffffffff80002d5e <_vsnprintf+0x2e>
ffffffff80002f77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80002f7e:	00 00 
        out('%', buffer, idx++, maxlen);
ffffffff80002f80:	4c 8d 63 01          	lea    0x1(%rbx),%r12
ffffffff80002f84:	48 89 da             	mov    %rbx,%rdx
ffffffff80002f87:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002f8a:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002f8d:	bf 25 00 00 00       	mov    $0x25,%edi
ffffffff80002f92:	4c 89 e3             	mov    %r12,%rbx
ffffffff80002f95:	ff d5                	callq  *%rbp
        break;
ffffffff80002f97:	e9 c2 fd ff ff       	jmpq   ffffffff80002d5e <_vsnprintf+0x2e>
ffffffff80002f9c:	0f 1f 40 00          	nopl   0x0(%rax)
        if (*format == 'x' || *format == 'X') {
ffffffff80002fa0:	89 c2                	mov    %eax,%edx
ffffffff80002fa2:	83 e2 df             	and    $0xffffffdf,%edx
ffffffff80002fa5:	80 fa 58             	cmp    $0x58,%dl
ffffffff80002fa8:	0f 84 66 02 00 00    	je     ffffffff80003214 <_vsnprintf+0x4e4>
        else if (*format == 'o') {
ffffffff80002fae:	3c 6f                	cmp    $0x6f,%al
ffffffff80002fb0:	0f 84 b6 04 00 00    	je     ffffffff8000346c <_vsnprintf+0x73c>
        else if (*format == 'b') {
ffffffff80002fb6:	3c 62                	cmp    $0x62,%al
ffffffff80002fb8:	0f 84 20 05 00 00    	je     ffffffff800034de <_vsnprintf+0x7ae>
          flags &= ~FLAGS_HASH;   // no hash for dec format
ffffffff80002fbe:	83 e1 ef             	and    $0xffffffef,%ecx
ffffffff80002fc1:	bf 0a 00 00 00       	mov    $0xa,%edi
        if (*format == 'X') {
ffffffff80002fc6:	3c 58                	cmp    $0x58,%al
ffffffff80002fc8:	0f 84 3c 03 00 00    	je     ffffffff8000330a <_vsnprintf+0x5da>
        if ((*format != 'i') && (*format != 'd')) {
ffffffff80002fce:	3c 69                	cmp    $0x69,%al
ffffffff80002fd0:	74 08                	je     ffffffff80002fda <_vsnprintf+0x2aa>
ffffffff80002fd2:	3c 64                	cmp    $0x64,%al
ffffffff80002fd4:	0f 85 33 03 00 00    	jne    ffffffff8000330d <_vsnprintf+0x5dd>
          flags &= ~FLAGS_ZEROPAD;
ffffffff80002fda:	89 ca                	mov    %ecx,%edx
ffffffff80002fdc:	83 e2 fe             	and    $0xfffffffe,%edx
ffffffff80002fdf:	f6 c5 04             	test   $0x4,%ch
ffffffff80002fe2:	0f 45 ca             	cmovne %edx,%ecx
ffffffff80002fe5:	48 8b 14 24          	mov    (%rsp),%rdx
ffffffff80002fe9:	89 ce                	mov    %ecx,%esi
ffffffff80002feb:	81 e6 00 02 00 00    	and    $0x200,%esi
        if ((*format == 'i') || (*format == 'd')) {
ffffffff80002ff1:	3c 69                	cmp    $0x69,%al
ffffffff80002ff3:	8b 12                	mov    (%rdx),%edx
ffffffff80002ff5:	0f 84 b8 02 00 00    	je     ffffffff800032b3 <_vsnprintf+0x583>
ffffffff80002ffb:	3c 64                	cmp    $0x64,%al
ffffffff80002ffd:	0f 84 b0 02 00 00    	je     ffffffff800032b3 <_vsnprintf+0x583>
          if (flags & FLAGS_LONG_LONG) {
ffffffff80003003:	85 f6                	test   %esi,%esi
ffffffff80003005:	0f 85 38 04 00 00    	jne    ffffffff80003443 <_vsnprintf+0x713>
          else if (flags & FLAGS_LONG) {
ffffffff8000300b:	f6 c5 01             	test   $0x1,%ch
ffffffff8000300e:	0f 85 a1 04 00 00    	jne    ffffffff800034b5 <_vsnprintf+0x785>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff80003014:	f6 c1 40             	test   $0x40,%cl
ffffffff80003017:	0f 84 6e 04 00 00    	je     ffffffff8000348b <_vsnprintf+0x75b>
ffffffff8000301d:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003020:	0f 87 d2 05 00 00    	ja     ffffffff800035f8 <_vsnprintf+0x8c8>
ffffffff80003026:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000302a:	89 d0                	mov    %edx,%eax
ffffffff8000302c:	83 c2 08             	add    $0x8,%edx
ffffffff8000302f:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003033:	89 16                	mov    %edx,(%rsi)
ffffffff80003035:	44 0f b6 00          	movzbl (%rax),%r8d
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
ffffffff80003039:	51                   	push   %rcx
ffffffff8000303a:	41 54                	push   %r12
ffffffff8000303c:	45 31 c9             	xor    %r9d,%r9d
ffffffff8000303f:	41 52                	push   %r10
ffffffff80003041:	57                   	push   %rdi
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff80003042:	48 89 da             	mov    %rbx,%rdx
ffffffff80003045:	4c 89 f1             	mov    %r14,%rcx
ffffffff80003048:	4c 89 fe             	mov    %r15,%rsi
ffffffff8000304b:	48 89 ef             	mov    %rbp,%rdi
ffffffff8000304e:	e8 5d fb ff ff       	callq  ffffffff80002bb0 <_ntoa_long>
ffffffff80003053:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80003057:	48 89 c3             	mov    %rax,%rbx
ffffffff8000305a:	e9 ff fc ff ff       	jmpq   ffffffff80002d5e <_vsnprintf+0x2e>
ffffffff8000305f:	90                   	nop
        out(*format, buffer, idx++, maxlen);
ffffffff80003060:	4c 8d 63 01          	lea    0x1(%rbx),%r12
    switch (*format) {
ffffffff80003064:	0f be f8             	movsbl %al,%edi
ffffffff80003067:	e9 0a fd ff ff       	jmpq   ffffffff80002d76 <_vsnprintf+0x46>
ffffffff8000306c:	0f 1f 40 00          	nopl   0x0(%rax)
  unsigned int i = 0U;
ffffffff80003070:	45 31 e4             	xor    %r12d,%r12d
ffffffff80003073:	eb 0a                	jmp    ffffffff8000307f <_vsnprintf+0x34f>
ffffffff80003075:	0f 1f 00             	nopl   (%rax)
  while (_is_digit(**str)) {
ffffffff80003078:	49 89 f5             	mov    %rsi,%r13
ffffffff8000307b:	48 83 c6 01          	add    $0x1,%rsi
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
ffffffff8000307f:	43 8d 14 a4          	lea    (%r12,%r12,4),%edx
ffffffff80003083:	44 8d 64 50 d0       	lea    -0x30(%rax,%rdx,2),%r12d
  while (_is_digit(**str)) {
ffffffff80003088:	0f be 06             	movsbl (%rsi),%eax
  return (ch >= '0') && (ch <= '9');
ffffffff8000308b:	8d 50 d0             	lea    -0x30(%rax),%edx
  while (_is_digit(**str)) {
ffffffff8000308e:	80 fa 09             	cmp    $0x9,%dl
ffffffff80003091:	76 e5                	jbe    ffffffff80003078 <_vsnprintf+0x348>
ffffffff80003093:	49 8d 7d 02          	lea    0x2(%r13),%rdi
    width = 0U;
ffffffff80003097:	49 89 f5             	mov    %rsi,%r13
    precision = 0U;
ffffffff8000309a:	45 31 d2             	xor    %r10d,%r10d
    if (*format == '.') {
ffffffff8000309d:	3c 2e                	cmp    $0x2e,%al
ffffffff8000309f:	0f 85 8d fd ff ff    	jne    ffffffff80002e32 <_vsnprintf+0x102>
      if (_is_digit(*format)) {
ffffffff800030a5:	41 0f be 45 01       	movsbl 0x1(%r13),%eax
      flags |= FLAGS_PRECISION;
ffffffff800030aa:	80 cd 04             	or     $0x4,%ch
  return (ch >= '0') && (ch <= '9');
ffffffff800030ad:	8d 50 d0             	lea    -0x30(%rax),%edx
      if (_is_digit(*format)) {
ffffffff800030b0:	80 fa 09             	cmp    $0x9,%dl
ffffffff800030b3:	76 1e                	jbe    ffffffff800030d3 <_vsnprintf+0x3a3>
      else if (*format == '*') {
ffffffff800030b5:	3c 2a                	cmp    $0x2a,%al
ffffffff800030b7:	0f 84 3f 06 00 00    	je     ffffffff800036fc <_vsnprintf+0x9cc>
      format++;
ffffffff800030bd:	49 89 fd             	mov    %rdi,%r13
      else if (*format == '*') {
ffffffff800030c0:	48 83 c7 01          	add    $0x1,%rdi
ffffffff800030c4:	e9 69 fd ff ff       	jmpq   ffffffff80002e32 <_vsnprintf+0x102>
ffffffff800030c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  while (_is_digit(**str)) {
ffffffff800030d0:	4c 89 ef             	mov    %r13,%rdi
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
ffffffff800030d3:	43 8d 14 92          	lea    (%r10,%r10,4),%edx
ffffffff800030d7:	4c 8d 6f 01          	lea    0x1(%rdi),%r13
ffffffff800030db:	44 8d 54 50 d0       	lea    -0x30(%rax,%rdx,2),%r10d
  while (_is_digit(**str)) {
ffffffff800030e0:	0f be 47 01          	movsbl 0x1(%rdi),%eax
  return (ch >= '0') && (ch <= '9');
ffffffff800030e4:	8d 50 d0             	lea    -0x30(%rax),%edx
  while (_is_digit(**str)) {
ffffffff800030e7:	80 fa 09             	cmp    $0x9,%dl
ffffffff800030ea:	76 e4                	jbe    ffffffff800030d0 <_vsnprintf+0x3a0>
ffffffff800030ec:	48 83 c7 02          	add    $0x2,%rdi
ffffffff800030f0:	e9 3d fd ff ff       	jmpq   ffffffff80002e32 <_vsnprintf+0x102>
ffffffff800030f5:	0f 1f 00             	nopl   (%rax)
    switch (*format) {
ffffffff800030f8:	3c 68                	cmp    $0x68,%al
ffffffff800030fa:	75 1c                	jne    ffffffff80003118 <_vsnprintf+0x3e8>
        if (*format == 'h') {
ffffffff800030fc:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
ffffffff80003101:	3c 68                	cmp    $0x68,%al
ffffffff80003103:	0f 84 1d 02 00 00    	je     ffffffff80003326 <_vsnprintf+0x5f6>
        flags |= FLAGS_SHORT;
ffffffff80003109:	80 c9 80             	or     $0x80,%cl
ffffffff8000310c:	4c 8d 6f 01          	lea    0x1(%rdi),%r13
ffffffff80003110:	e9 3f fd ff ff       	jmpq   ffffffff80002e54 <_vsnprintf+0x124>
ffffffff80003115:	0f 1f 00             	nopl   (%rax)
    switch (*format) {
ffffffff80003118:	49 89 fd             	mov    %rdi,%r13
ffffffff8000311b:	e9 34 fd ff ff       	jmpq   ffffffff80002e54 <_vsnprintf+0x124>
        const char* p = va_arg(va, char*);
ffffffff80003120:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003124:	8b 16                	mov    (%rsi),%edx
ffffffff80003126:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003129:	0f 87 2e 04 00 00    	ja     ffffffff8000355d <_vsnprintf+0x82d>
ffffffff8000312f:	89 d0                	mov    %edx,%eax
ffffffff80003131:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003135:	83 c2 08             	add    $0x8,%edx
ffffffff80003138:	89 16                	mov    %edx,(%rsi)
ffffffff8000313a:	4c 8b 08             	mov    (%rax),%r9
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
ffffffff8000313d:	45 85 d2             	test   %r10d,%r10d
ffffffff80003140:	41 0f be 39          	movsbl (%r9),%edi
ffffffff80003144:	0f 85 54 01 00 00    	jne    ffffffff8000329e <_vsnprintf+0x56e>
  for (s = str; *s && maxsize--; ++s);
ffffffff8000314a:	40 84 ff             	test   %dil,%dil
ffffffff8000314d:	48 c7 c6 fe ff ff ff 	mov    $0xfffffffffffffffe,%rsi
ffffffff80003154:	0f 84 b8 03 00 00    	je     ffffffff80003512 <_vsnprintf+0x7e2>
ffffffff8000315a:	4c 89 c8             	mov    %r9,%rax
ffffffff8000315d:	eb 11                	jmp    ffffffff80003170 <_vsnprintf+0x440>
ffffffff8000315f:	90                   	nop
ffffffff80003160:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80003165:	48 29 c2             	sub    %rax,%rdx
ffffffff80003168:	4c 01 ca             	add    %r9,%rdx
ffffffff8000316b:	48 01 f2             	add    %rsi,%rdx
ffffffff8000316e:	74 09                	je     ffffffff80003179 <_vsnprintf+0x449>
ffffffff80003170:	48 83 c0 01          	add    $0x1,%rax
ffffffff80003174:	80 38 00             	cmpb   $0x0,(%rax)
ffffffff80003177:	75 e7                	jne    ffffffff80003160 <_vsnprintf+0x430>
ffffffff80003179:	44 29 c8             	sub    %r9d,%eax
ffffffff8000317c:	89 44 24 20          	mov    %eax,0x20(%rsp)
        if (flags & FLAGS_PRECISION) {
ffffffff80003180:	89 c8                	mov    %ecx,%eax
ffffffff80003182:	25 00 04 00 00       	and    $0x400,%eax
ffffffff80003187:	89 44 24 18          	mov    %eax,0x18(%rsp)
ffffffff8000318b:	74 0f                	je     ffffffff8000319c <_vsnprintf+0x46c>
          l = (l < precision ? l : precision);
ffffffff8000318d:	8b 44 24 20          	mov    0x20(%rsp),%eax
ffffffff80003191:	44 39 d0             	cmp    %r10d,%eax
ffffffff80003194:	41 0f 47 c2          	cmova  %r10d,%eax
ffffffff80003198:	89 44 24 20          	mov    %eax,0x20(%rsp)
        if (!(flags & FLAGS_LEFT)) {
ffffffff8000319c:	83 e1 02             	and    $0x2,%ecx
ffffffff8000319f:	89 4c 24 24          	mov    %ecx,0x24(%rsp)
ffffffff800031a3:	0f 84 0e 02 00 00    	je     ffffffff800033b7 <_vsnprintf+0x687>
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff800031a9:	40 84 ff             	test   %dil,%dil
ffffffff800031ac:	0f 84 94 00 00 00    	je     ffffffff80003246 <_vsnprintf+0x516>
ffffffff800031b2:	49 29 d9             	sub    %rbx,%r9
ffffffff800031b5:	44 89 64 24 28       	mov    %r12d,0x28(%rsp)
ffffffff800031ba:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
ffffffff800031bf:	44 8b 64 24 18       	mov    0x18(%rsp),%r12d
ffffffff800031c4:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
ffffffff800031c9:	4c 89 6c 24 18       	mov    %r13,0x18(%rsp)
ffffffff800031ce:	49 89 dd             	mov    %rbx,%r13
ffffffff800031d1:	eb 27                	jmp    ffffffff800031fa <_vsnprintf+0x4ca>
ffffffff800031d3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
          out(*(p++), buffer, idx++, maxlen);
ffffffff800031d8:	4c 89 f1             	mov    %r14,%rcx
ffffffff800031db:	4c 89 ea             	mov    %r13,%rdx
ffffffff800031de:	4c 89 fe             	mov    %r15,%rsi
ffffffff800031e1:	ff d5                	callq  *%rbp
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff800031e3:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
          out(*(p++), buffer, idx++, maxlen);
ffffffff800031e8:	49 8d 5d 01          	lea    0x1(%r13),%rbx
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff800031ec:	41 0f be 7c 05 01    	movsbl 0x1(%r13,%rax,1),%edi
ffffffff800031f2:	40 84 ff             	test   %dil,%dil
ffffffff800031f5:	74 39                	je     ffffffff80003230 <_vsnprintf+0x500>
          out(*(p++), buffer, idx++, maxlen);
ffffffff800031f7:	49 89 dd             	mov    %rbx,%r13
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff800031fa:	45 85 e4             	test   %r12d,%r12d
ffffffff800031fd:	74 d9                	je     ffffffff800031d8 <_vsnprintf+0x4a8>
ffffffff800031ff:	8b 44 24 10          	mov    0x10(%rsp),%eax
ffffffff80003203:	85 c0                	test   %eax,%eax
ffffffff80003205:	8d 50 ff             	lea    -0x1(%rax),%edx
ffffffff80003208:	0f 84 68 02 00 00    	je     ffffffff80003476 <_vsnprintf+0x746>
ffffffff8000320e:	89 54 24 10          	mov    %edx,0x10(%rsp)
ffffffff80003212:	eb c4                	jmp    ffffffff800031d8 <_vsnprintf+0x4a8>
ffffffff80003214:	bf 10 00 00 00       	mov    $0x10,%edi
ffffffff80003219:	e9 a8 fd ff ff       	jmpq   ffffffff80002fc6 <_vsnprintf+0x296>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff8000321e:	4c 89 c3             	mov    %r8,%rbx
ffffffff80003221:	e9 38 fb ff ff       	jmpq   ffffffff80002d5e <_vsnprintf+0x2e>
ffffffff80003226:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000322d:	00 00 00 
ffffffff80003230:	44 8b 64 24 28       	mov    0x28(%rsp),%r12d
ffffffff80003235:	4c 8b 6c 24 18       	mov    0x18(%rsp),%r13
        if (flags & FLAGS_LEFT) {
ffffffff8000323a:	8b 44 24 24          	mov    0x24(%rsp),%eax
ffffffff8000323e:	85 c0                	test   %eax,%eax
ffffffff80003240:	0f 84 18 fb ff ff    	je     ffffffff80002d5e <_vsnprintf+0x2e>
          while (l++ < width) {
ffffffff80003246:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
ffffffff8000324a:	41 39 cc             	cmp    %ecx,%r12d
ffffffff8000324d:	0f 86 0b fb ff ff    	jbe    ffffffff80002d5e <_vsnprintf+0x2e>
ffffffff80003253:	41 83 ec 01          	sub    $0x1,%r12d
ffffffff80003257:	48 89 da             	mov    %rbx,%rdx
ffffffff8000325a:	4c 89 6c 24 08       	mov    %r13,0x8(%rsp)
ffffffff8000325f:	44 89 e0             	mov    %r12d,%eax
ffffffff80003262:	4c 8d 63 01          	lea    0x1(%rbx),%r12
ffffffff80003266:	29 c8                	sub    %ecx,%eax
ffffffff80003268:	4c 01 e0             	add    %r12,%rax
ffffffff8000326b:	4d 89 e5             	mov    %r12,%r13
ffffffff8000326e:	48 89 c3             	mov    %rax,%rbx
ffffffff80003271:	eb 09                	jmp    ffffffff8000327c <_vsnprintf+0x54c>
ffffffff80003273:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
ffffffff80003278:	49 83 c5 01          	add    $0x1,%r13
            out(' ', buffer, idx++, maxlen);
ffffffff8000327c:	4c 89 f1             	mov    %r14,%rcx
ffffffff8000327f:	4c 89 fe             	mov    %r15,%rsi
ffffffff80003282:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80003287:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff80003289:	49 39 dd             	cmp    %rbx,%r13
ffffffff8000328c:	4c 89 ea             	mov    %r13,%rdx
ffffffff8000328f:	75 e7                	jne    ffffffff80003278 <_vsnprintf+0x548>
ffffffff80003291:	4c 89 eb             	mov    %r13,%rbx
ffffffff80003294:	4c 8b 6c 24 08       	mov    0x8(%rsp),%r13
        break;
ffffffff80003299:	e9 c0 fa ff ff       	jmpq   ffffffff80002d5e <_vsnprintf+0x2e>
  for (s = str; *s && maxsize--; ++s);
ffffffff8000329e:	40 84 ff             	test   %dil,%dil
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
ffffffff800032a1:	44 89 d6             	mov    %r10d,%esi
  for (s = str; *s && maxsize--; ++s);
ffffffff800032a4:	0f 84 68 02 00 00    	je     ffffffff80003512 <_vsnprintf+0x7e2>
ffffffff800032aa:	48 83 ee 01          	sub    $0x1,%rsi
ffffffff800032ae:	e9 a7 fe ff ff       	jmpq   ffffffff8000315a <_vsnprintf+0x42a>
          if (flags & FLAGS_LONG_LONG) {
ffffffff800032b3:	85 f6                	test   %esi,%esi
ffffffff800032b5:	0f 85 bd 03 00 00    	jne    ffffffff80003678 <_vsnprintf+0x948>
          else if (flags & FLAGS_LONG) {
ffffffff800032bb:	f6 c5 01             	test   $0x1,%ch
ffffffff800032be:	0f 85 7e 03 00 00    	jne    ffffffff80003642 <_vsnprintf+0x912>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff800032c4:	f6 c1 40             	test   $0x40,%cl
ffffffff800032c7:	0f 84 1b 02 00 00    	je     ffffffff800034e8 <_vsnprintf+0x7b8>
ffffffff800032cd:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff800032d0:	0f 87 b1 02 00 00    	ja     ffffffff80003587 <_vsnprintf+0x857>
ffffffff800032d6:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800032da:	89 d0                	mov    %edx,%eax
ffffffff800032dc:	83 c2 08             	add    $0x8,%edx
ffffffff800032df:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff800032e3:	89 16                	mov    %edx,(%rsi)
ffffffff800032e5:	44 0f be 08          	movsbl (%rax),%r9d
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff800032e9:	44 89 c8             	mov    %r9d,%eax
ffffffff800032ec:	51                   	push   %rcx
ffffffff800032ed:	41 54                	push   %r12
ffffffff800032ef:	c1 f8 1f             	sar    $0x1f,%eax
ffffffff800032f2:	41 52                	push   %r10
ffffffff800032f4:	57                   	push   %rdi
ffffffff800032f5:	41 89 c0             	mov    %eax,%r8d
ffffffff800032f8:	45 31 c8             	xor    %r9d,%r8d
ffffffff800032fb:	41 c1 e9 1f          	shr    $0x1f,%r9d
ffffffff800032ff:	41 29 c0             	sub    %eax,%r8d
ffffffff80003302:	4d 63 c0             	movslq %r8d,%r8
ffffffff80003305:	e9 38 fd ff ff       	jmpq   ffffffff80003042 <_vsnprintf+0x312>
          flags |= FLAGS_UPPERCASE;
ffffffff8000330a:	83 c9 20             	or     $0x20,%ecx
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
ffffffff8000330d:	83 e1 f3             	and    $0xfffffff3,%ecx
ffffffff80003310:	e9 c5 fc ff ff       	jmpq   ffffffff80002fda <_vsnprintf+0x2aa>
ffffffff80003315:	41 0f b6 45 02       	movzbl 0x2(%r13),%eax
          flags |= FLAGS_LONG_LONG;
ffffffff8000331a:	80 cd 03             	or     $0x3,%ch
ffffffff8000331d:	49 83 c5 03          	add    $0x3,%r13
ffffffff80003321:	e9 2e fb ff ff       	jmpq   ffffffff80002e54 <_vsnprintf+0x124>
ffffffff80003326:	41 0f b6 45 02       	movzbl 0x2(%r13),%eax
          flags |= FLAGS_CHAR;
ffffffff8000332b:	80 c9 c0             	or     $0xc0,%cl
ffffffff8000332e:	49 83 c5 03          	add    $0x3,%r13
ffffffff80003332:	e9 1d fb ff ff       	jmpq   ffffffff80002e54 <_vsnprintf+0x124>
          while (l++ < width) {
ffffffff80003337:	41 83 fc 01          	cmp    $0x1,%r12d
ffffffff8000333b:	0f 86 de 01 00 00    	jbe    ffffffff8000351f <_vsnprintf+0x7ef>
ffffffff80003341:	41 8d 44 24 fe       	lea    -0x2(%r12),%eax
ffffffff80003346:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
ffffffff8000334b:	4d 89 c5             	mov    %r8,%r13
ffffffff8000334e:	4c 01 c0             	add    %r8,%rax
ffffffff80003351:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff80003356:	eb 0f                	jmp    ffffffff80003367 <_vsnprintf+0x637>
ffffffff80003358:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000335f:	00 
ffffffff80003360:	4c 89 eb             	mov    %r13,%rbx
ffffffff80003363:	49 83 c5 01          	add    $0x1,%r13
            out(' ', buffer, idx++, maxlen);
ffffffff80003367:	4c 89 f1             	mov    %r14,%rcx
ffffffff8000336a:	48 89 da             	mov    %rbx,%rdx
ffffffff8000336d:	4c 89 fe             	mov    %r15,%rsi
ffffffff80003370:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80003375:	4d 89 ec             	mov    %r13,%r12
ffffffff80003378:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff8000337a:	4c 3b 6c 24 08       	cmp    0x8(%rsp),%r13
ffffffff8000337f:	75 df                	jne    ffffffff80003360 <_vsnprintf+0x630>
ffffffff80003381:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
ffffffff80003386:	48 83 c3 02          	add    $0x2,%rbx
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff8000338a:	48 8b 0c 24          	mov    (%rsp),%rcx
ffffffff8000338e:	8b 01                	mov    (%rcx),%eax
ffffffff80003390:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff80003393:	0f 87 d9 01 00 00    	ja     ffffffff80003572 <_vsnprintf+0x842>
ffffffff80003399:	89 c2                	mov    %eax,%edx
ffffffff8000339b:	48 03 51 10          	add    0x10(%rcx),%rdx
ffffffff8000339f:	83 c0 08             	add    $0x8,%eax
ffffffff800033a2:	89 01                	mov    %eax,(%rcx)
ffffffff800033a4:	0f be 3a             	movsbl (%rdx),%edi
ffffffff800033a7:	4c 89 f1             	mov    %r14,%rcx
ffffffff800033aa:	4c 89 e2             	mov    %r12,%rdx
ffffffff800033ad:	4c 89 fe             	mov    %r15,%rsi
ffffffff800033b0:	ff d5                	callq  *%rbp
ffffffff800033b2:	e9 a7 f9 ff ff       	jmpq   ffffffff80002d5e <_vsnprintf+0x2e>
          while (l++ < width) {
ffffffff800033b7:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
ffffffff800033bb:	41 39 cc             	cmp    %ecx,%r12d
ffffffff800033be:	8d 41 01             	lea    0x1(%rcx),%eax
ffffffff800033c1:	0f 86 63 01 00 00    	jbe    ffffffff8000352a <_vsnprintf+0x7fa>
ffffffff800033c7:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
ffffffff800033cc:	4c 8d 43 01          	lea    0x1(%rbx),%r8
ffffffff800033d0:	44 89 64 24 20       	mov    %r12d,0x20(%rsp)
ffffffff800033d5:	4c 89 6c 24 28       	mov    %r13,0x28(%rsp)
ffffffff800033da:	48 89 da             	mov    %rbx,%rdx
ffffffff800033dd:	44 89 54 24 08       	mov    %r10d,0x8(%rsp)
ffffffff800033e2:	29 c8                	sub    %ecx,%eax
ffffffff800033e4:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
ffffffff800033e9:	4d 89 c5             	mov    %r8,%r13
ffffffff800033ec:	4c 01 c0             	add    %r8,%rax
ffffffff800033ef:	49 89 c4             	mov    %rax,%r12
ffffffff800033f2:	eb 08                	jmp    ffffffff800033fc <_vsnprintf+0x6cc>
ffffffff800033f4:	0f 1f 40 00          	nopl   0x0(%rax)
ffffffff800033f8:	49 83 c5 01          	add    $0x1,%r13
            out(' ', buffer, idx++, maxlen);
ffffffff800033fc:	4c 89 f1             	mov    %r14,%rcx
ffffffff800033ff:	4c 89 fe             	mov    %r15,%rsi
ffffffff80003402:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80003407:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff80003409:	4d 39 e5             	cmp    %r12,%r13
            out(' ', buffer, idx++, maxlen);
ffffffff8000340c:	4c 89 eb             	mov    %r13,%rbx
ffffffff8000340f:	4c 89 ea             	mov    %r13,%rdx
          while (l++ < width) {
ffffffff80003412:	75 e4                	jne    ffffffff800033f8 <_vsnprintf+0x6c8>
ffffffff80003414:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
ffffffff80003419:	44 8b 64 24 20       	mov    0x20(%rsp),%r12d
ffffffff8000341e:	44 8b 54 24 08       	mov    0x8(%rsp),%r10d
ffffffff80003423:	4c 8b 6c 24 28       	mov    0x28(%rsp),%r13
ffffffff80003428:	41 0f be 39          	movsbl (%r9),%edi
ffffffff8000342c:	41 8d 44 24 01       	lea    0x1(%r12),%eax
ffffffff80003431:	89 44 24 20          	mov    %eax,0x20(%rsp)
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80003435:	40 84 ff             	test   %dil,%dil
ffffffff80003438:	0f 85 74 fd ff ff    	jne    ffffffff800031b2 <_vsnprintf+0x482>
ffffffff8000343e:	e9 1b f9 ff ff       	jmpq   ffffffff80002d5e <_vsnprintf+0x2e>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
ffffffff80003443:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003446:	0f 87 97 01 00 00    	ja     ffffffff800035e3 <_vsnprintf+0x8b3>
ffffffff8000344c:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003450:	89 d0                	mov    %edx,%eax
ffffffff80003452:	83 c2 08             	add    $0x8,%edx
ffffffff80003455:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003459:	89 16                	mov    %edx,(%rsi)
ffffffff8000345b:	51                   	push   %rcx
ffffffff8000345c:	45 31 c9             	xor    %r9d,%r9d
ffffffff8000345f:	41 54                	push   %r12
ffffffff80003461:	41 52                	push   %r10
ffffffff80003463:	57                   	push   %rdi
ffffffff80003464:	4c 8b 00             	mov    (%rax),%r8
ffffffff80003467:	e9 4e fa ff ff       	jmpq   ffffffff80002eba <_vsnprintf+0x18a>
ffffffff8000346c:	bf 08 00 00 00       	mov    $0x8,%edi
ffffffff80003471:	e9 97 fe ff ff       	jmpq   ffffffff8000330d <_vsnprintf+0x5dd>
ffffffff80003476:	4c 89 e8             	mov    %r13,%rax
ffffffff80003479:	44 8b 64 24 28       	mov    0x28(%rsp),%r12d
ffffffff8000347e:	4c 8b 6c 24 18       	mov    0x18(%rsp),%r13
ffffffff80003483:	48 89 c3             	mov    %rax,%rbx
ffffffff80003486:	e9 af fd ff ff       	jmpq   ffffffff8000323a <_vsnprintf+0x50a>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff8000348b:	f6 c1 80             	test   $0x80,%cl
ffffffff8000348e:	0f 84 8e 01 00 00    	je     ffffffff80003622 <_vsnprintf+0x8f2>
ffffffff80003494:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003497:	0f 87 70 01 00 00    	ja     ffffffff8000360d <_vsnprintf+0x8dd>
ffffffff8000349d:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800034a1:	89 d0                	mov    %edx,%eax
ffffffff800034a3:	83 c2 08             	add    $0x8,%edx
ffffffff800034a6:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff800034aa:	89 16                	mov    %edx,(%rsi)
ffffffff800034ac:	44 0f b7 00          	movzwl (%rax),%r8d
ffffffff800034b0:	e9 84 fb ff ff       	jmpq   ffffffff80003039 <_vsnprintf+0x309>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
ffffffff800034b5:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff800034b8:	0f 87 8a 00 00 00    	ja     ffffffff80003548 <_vsnprintf+0x818>
ffffffff800034be:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800034c2:	89 d0                	mov    %edx,%eax
ffffffff800034c4:	83 c2 08             	add    $0x8,%edx
ffffffff800034c7:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff800034cb:	89 16                	mov    %edx,(%rsi)
ffffffff800034cd:	51                   	push   %rcx
ffffffff800034ce:	45 31 c9             	xor    %r9d,%r9d
ffffffff800034d1:	41 54                	push   %r12
ffffffff800034d3:	41 52                	push   %r10
ffffffff800034d5:	57                   	push   %rdi
ffffffff800034d6:	4c 8b 00             	mov    (%rax),%r8
ffffffff800034d9:	e9 64 fb ff ff       	jmpq   ffffffff80003042 <_vsnprintf+0x312>
ffffffff800034de:	bf 02 00 00 00       	mov    $0x2,%edi
ffffffff800034e3:	e9 25 fe ff ff       	jmpq   ffffffff8000330d <_vsnprintf+0x5dd>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff800034e8:	f6 c1 80             	test   $0x80,%cl
ffffffff800034eb:	0f 84 56 02 00 00    	je     ffffffff80003747 <_vsnprintf+0xa17>
ffffffff800034f1:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff800034f4:	0f 87 38 02 00 00    	ja     ffffffff80003732 <_vsnprintf+0xa02>
ffffffff800034fa:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800034fe:	89 d0                	mov    %edx,%eax
ffffffff80003500:	83 c2 08             	add    $0x8,%edx
ffffffff80003503:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003507:	89 16                	mov    %edx,(%rsi)
ffffffff80003509:	44 0f bf 08          	movswl (%rax),%r9d
ffffffff8000350d:	e9 d7 fd ff ff       	jmpq   ffffffff800032e9 <_vsnprintf+0x5b9>
  for (s = str; *s && maxsize--; ++s);
ffffffff80003512:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%rsp)
ffffffff80003519:	00 
ffffffff8000351a:	e9 61 fc ff ff       	jmpq   ffffffff80003180 <_vsnprintf+0x450>
          while (l++ < width) {
ffffffff8000351f:	49 89 dc             	mov    %rbx,%r12
ffffffff80003522:	4c 89 c3             	mov    %r8,%rbx
ffffffff80003525:	e9 60 fe ff ff       	jmpq   ffffffff8000338a <_vsnprintf+0x65a>
          while (l++ < width) {
ffffffff8000352a:	89 44 24 20          	mov    %eax,0x20(%rsp)
ffffffff8000352e:	e9 02 ff ff ff       	jmpq   ffffffff80003435 <_vsnprintf+0x705>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff80003533:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003537:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
ffffffff8000353b:	48 8d 51 08          	lea    0x8(%rcx),%rdx
ffffffff8000353f:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003543:	e9 c2 f9 ff ff       	jmpq   ffffffff80002f0a <_vsnprintf+0x1da>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
ffffffff80003548:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000354c:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff80003550:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80003554:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003558:	e9 70 ff ff ff       	jmpq   ffffffff800034cd <_vsnprintf+0x79d>
        const char* p = va_arg(va, char*);
ffffffff8000355d:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003561:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff80003565:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80003569:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff8000356d:	e9 c8 fb ff ff       	jmpq   ffffffff8000313a <_vsnprintf+0x40a>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff80003572:	48 8b 0c 24          	mov    (%rsp),%rcx
ffffffff80003576:	48 8b 51 08          	mov    0x8(%rcx),%rdx
ffffffff8000357a:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff8000357e:	48 89 41 08          	mov    %rax,0x8(%rcx)
ffffffff80003582:	e9 1d fe ff ff       	jmpq   ffffffff800033a4 <_vsnprintf+0x674>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff80003587:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000358b:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff8000358f:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80003593:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003597:	e9 49 fd ff ff       	jmpq   ffffffff800032e5 <_vsnprintf+0x5b5>
      const int w = va_arg(va, int);
ffffffff8000359c:	48 8b 3c 24          	mov    (%rsp),%rdi
ffffffff800035a0:	8b 17                	mov    (%rdi),%edx
ffffffff800035a2:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff800035a5:	77 2a                	ja     ffffffff800035d1 <_vsnprintf+0x8a1>
ffffffff800035a7:	89 d0                	mov    %edx,%eax
ffffffff800035a9:	48 03 47 10          	add    0x10(%rdi),%rax
ffffffff800035ad:	83 c2 08             	add    $0x8,%edx
ffffffff800035b0:	89 17                	mov    %edx,(%rdi)
ffffffff800035b2:	44 8b 20             	mov    (%rax),%r12d
      if (w < 0) {
ffffffff800035b5:	45 85 e4             	test   %r12d,%r12d
ffffffff800035b8:	79 06                	jns    ffffffff800035c0 <_vsnprintf+0x890>
        flags |= FLAGS_LEFT;    // reverse padding
ffffffff800035ba:	83 c9 02             	or     $0x2,%ecx
        width = (unsigned int)-w;
ffffffff800035bd:	41 f7 dc             	neg    %r12d
ffffffff800035c0:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
ffffffff800035c5:	49 8d 7d 02          	lea    0x2(%r13),%rdi
    width = 0U;
ffffffff800035c9:	49 89 f5             	mov    %rsi,%r13
ffffffff800035cc:	e9 c9 fa ff ff       	jmpq   ffffffff8000309a <_vsnprintf+0x36a>
      const int w = va_arg(va, int);
ffffffff800035d1:	48 8b 3c 24          	mov    (%rsp),%rdi
ffffffff800035d5:	48 8b 47 08          	mov    0x8(%rdi),%rax
ffffffff800035d9:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff800035dd:	48 89 57 08          	mov    %rdx,0x8(%rdi)
ffffffff800035e1:	eb cf                	jmp    ffffffff800035b2 <_vsnprintf+0x882>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
ffffffff800035e3:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800035e7:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff800035eb:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff800035ef:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff800035f3:	e9 63 fe ff ff       	jmpq   ffffffff8000345b <_vsnprintf+0x72b>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff800035f8:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800035fc:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff80003600:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80003604:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003608:	e9 28 fa ff ff       	jmpq   ffffffff80003035 <_vsnprintf+0x305>
ffffffff8000360d:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003611:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff80003615:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80003619:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff8000361d:	e9 8a fe ff ff       	jmpq   ffffffff800034ac <_vsnprintf+0x77c>
ffffffff80003622:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003625:	0f 87 83 00 00 00    	ja     ffffffff800036ae <_vsnprintf+0x97e>
ffffffff8000362b:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000362f:	89 d0                	mov    %edx,%eax
ffffffff80003631:	83 c2 08             	add    $0x8,%edx
ffffffff80003634:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003638:	89 16                	mov    %edx,(%rsi)
ffffffff8000363a:	44 8b 00             	mov    (%rax),%r8d
ffffffff8000363d:	e9 f7 f9 ff ff       	jmpq   ffffffff80003039 <_vsnprintf+0x309>
            const long value = va_arg(va, long);
ffffffff80003642:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003645:	77 7c                	ja     ffffffff800036c3 <_vsnprintf+0x993>
ffffffff80003647:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000364b:	89 d0                	mov    %edx,%eax
ffffffff8000364d:	83 c2 08             	add    $0x8,%edx
ffffffff80003650:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003654:	89 16                	mov    %edx,(%rsi)
ffffffff80003656:	4c 8b 08             	mov    (%rax),%r9
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff80003659:	51                   	push   %rcx
ffffffff8000365a:	41 54                	push   %r12
ffffffff8000365c:	41 52                	push   %r10
ffffffff8000365e:	57                   	push   %rdi
ffffffff8000365f:	4c 89 c8             	mov    %r9,%rax
ffffffff80003662:	48 c1 f8 3f          	sar    $0x3f,%rax
ffffffff80003666:	49 89 c0             	mov    %rax,%r8
ffffffff80003669:	4d 31 c8             	xor    %r9,%r8
ffffffff8000366c:	49 c1 e9 3f          	shr    $0x3f,%r9
ffffffff80003670:	49 29 c0             	sub    %rax,%r8
ffffffff80003673:	e9 ca f9 ff ff       	jmpq   ffffffff80003042 <_vsnprintf+0x312>
            const long long value = va_arg(va, long long);
ffffffff80003678:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff8000367b:	77 58                	ja     ffffffff800036d5 <_vsnprintf+0x9a5>
ffffffff8000367d:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003681:	89 d0                	mov    %edx,%eax
ffffffff80003683:	83 c2 08             	add    $0x8,%edx
ffffffff80003686:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff8000368a:	89 16                	mov    %edx,(%rsi)
ffffffff8000368c:	4c 8b 08             	mov    (%rax),%r9
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff8000368f:	51                   	push   %rcx
ffffffff80003690:	41 54                	push   %r12
ffffffff80003692:	41 52                	push   %r10
ffffffff80003694:	57                   	push   %rdi
ffffffff80003695:	4c 89 c8             	mov    %r9,%rax
ffffffff80003698:	48 c1 f8 3f          	sar    $0x3f,%rax
ffffffff8000369c:	49 89 c0             	mov    %rax,%r8
ffffffff8000369f:	4d 31 c8             	xor    %r9,%r8
ffffffff800036a2:	49 c1 e9 3f          	shr    $0x3f,%r9
ffffffff800036a6:	49 29 c0             	sub    %rax,%r8
ffffffff800036a9:	e9 0c f8 ff ff       	jmpq   ffffffff80002eba <_vsnprintf+0x18a>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff800036ae:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800036b2:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff800036b6:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff800036ba:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff800036be:	e9 77 ff ff ff       	jmpq   ffffffff8000363a <_vsnprintf+0x90a>
            const long value = va_arg(va, long);
ffffffff800036c3:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800036c7:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff800036cb:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff800036cf:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff800036d3:	eb 81                	jmp    ffffffff80003656 <_vsnprintf+0x926>
            const long long value = va_arg(va, long long);
ffffffff800036d5:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800036d9:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff800036dd:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff800036e1:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff800036e5:	eb a5                	jmp    ffffffff8000368c <_vsnprintf+0x95c>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
ffffffff800036e7:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800036eb:	48 8b 56 08          	mov    0x8(%rsi),%rdx
ffffffff800036ef:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff800036f3:	48 89 46 08          	mov    %rax,0x8(%rsi)
ffffffff800036f7:	e9 b1 f7 ff ff       	jmpq   ffffffff80002ead <_vsnprintf+0x17d>
        const int prec = (int)va_arg(va, int);
ffffffff800036fc:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003700:	8b 16                	mov    (%rsi),%edx
ffffffff80003702:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003705:	77 5c                	ja     ffffffff80003763 <_vsnprintf+0xa33>
ffffffff80003707:	89 d0                	mov    %edx,%eax
ffffffff80003709:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff8000370d:	83 c2 08             	add    $0x8,%edx
ffffffff80003710:	89 16                	mov    %edx,(%rsi)
        precision = prec > 0 ? (unsigned int)prec : 0U;
ffffffff80003712:	8b 10                	mov    (%rax),%edx
ffffffff80003714:	41 ba 00 00 00 00    	mov    $0x0,%r10d
ffffffff8000371a:	49 8d 7d 03          	lea    0x3(%r13),%rdi
ffffffff8000371e:	85 d2                	test   %edx,%edx
ffffffff80003720:	44 0f 49 10          	cmovns (%rax),%r10d
ffffffff80003724:	41 0f b6 45 02       	movzbl 0x2(%r13),%eax
        format++;
ffffffff80003729:	49 83 c5 02          	add    $0x2,%r13
ffffffff8000372d:	e9 00 f7 ff ff       	jmpq   ffffffff80002e32 <_vsnprintf+0x102>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff80003732:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003736:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff8000373a:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff8000373e:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003742:	e9 c2 fd ff ff       	jmpq   ffffffff80003509 <_vsnprintf+0x7d9>
ffffffff80003747:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff8000374a:	77 29                	ja     ffffffff80003775 <_vsnprintf+0xa45>
ffffffff8000374c:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003750:	89 d0                	mov    %edx,%eax
ffffffff80003752:	83 c2 08             	add    $0x8,%edx
ffffffff80003755:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003759:	89 16                	mov    %edx,(%rsi)
ffffffff8000375b:	44 8b 08             	mov    (%rax),%r9d
ffffffff8000375e:	e9 86 fb ff ff       	jmpq   ffffffff800032e9 <_vsnprintf+0x5b9>
        const int prec = (int)va_arg(va, int);
ffffffff80003763:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003767:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff8000376b:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff8000376f:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003773:	eb 9d                	jmp    ffffffff80003712 <_vsnprintf+0x9e2>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff80003775:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003779:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff8000377d:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80003781:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003785:	eb d4                	jmp    ffffffff8000375b <_vsnprintf+0xa2b>
ffffffff80003787:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000378e:	00 00 

ffffffff80003790 <_out_char>:
  if (character) {
ffffffff80003790:	40 84 ff             	test   %dil,%dil
ffffffff80003793:	75 0b                	jne    ffffffff800037a0 <_out_char+0x10>
}
ffffffff80003795:	f3 c3                	repz retq 
ffffffff80003797:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000379e:	00 00 
    _putchar(character);
ffffffff800037a0:	40 0f be ff          	movsbl %dil,%edi
ffffffff800037a4:	e9 c7 01 00 00       	jmpq   ffffffff80003970 <_putchar>
ffffffff800037a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff800037b0 <printf_>:


///////////////////////////////////////////////////////////////////////////////

int printf_(const char* format, ...)
{
ffffffff800037b0:	48 83 ec 58          	sub    $0x58,%rsp
  va_list va;
  va_start(va, format);
ffffffff800037b4:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
{
ffffffff800037b9:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
ffffffff800037be:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff800037c3:	48 8d 74 24 07       	lea    0x7(%rsp),%rsi
ffffffff800037c8:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
{
ffffffff800037cd:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
  va_start(va, format);
ffffffff800037d2:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff800037d7:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
{
ffffffff800037dc:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff800037e1:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
ffffffff800037e8:	48 89 f9             	mov    %rdi,%rcx
ffffffff800037eb:	48 c7 c7 90 37 00 80 	mov    $0xffffffff80003790,%rdi
{
ffffffff800037f2:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  va_start(va, format);
ffffffff800037f7:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
ffffffff800037fe:	00 
ffffffff800037ff:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff80003804:	e8 27 f5 ff ff       	callq  ffffffff80002d30 <_vsnprintf>
  va_end(va);
  return ret;
}
ffffffff80003809:	48 83 c4 58          	add    $0x58,%rsp
ffffffff8000380d:	c3                   	retq   
ffffffff8000380e:	66 90                	xchg   %ax,%ax

ffffffff80003810 <sprintf_>:


int sprintf_(char* buffer, const char* format, ...)
{
ffffffff80003810:	48 83 ec 58          	sub    $0x58,%rsp
  va_list va;
  va_start(va, format);
ffffffff80003814:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
{
ffffffff80003819:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff8000381e:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
{
ffffffff80003823:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
ffffffff80003828:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff8000382d:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  va_start(va, format);
ffffffff80003834:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff80003839:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff8000383e:	48 89 f1             	mov    %rsi,%rcx
ffffffff80003841:	48 89 fe             	mov    %rdi,%rsi
ffffffff80003844:	48 c7 c7 00 27 00 80 	mov    $0xffffffff80002700,%rdi
{
ffffffff8000384b:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  va_start(va, format);
ffffffff80003850:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%rsp)
ffffffff80003857:	00 
ffffffff80003858:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff8000385d:	e8 ce f4 ff ff       	callq  ffffffff80002d30 <_vsnprintf>
  va_end(va);
  return ret;
}
ffffffff80003862:	48 83 c4 58          	add    $0x58,%rsp
ffffffff80003866:	c3                   	retq   
ffffffff80003867:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000386e:	00 00 

ffffffff80003870 <snprintf_>:


int snprintf_(char* buffer, size_t count, const char* format, ...)
{
ffffffff80003870:	48 83 ec 58          	sub    $0x58,%rsp
  va_list va;
  va_start(va, format);
ffffffff80003874:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
{
ffffffff80003879:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff8000387e:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
{
ffffffff80003883:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff80003888:	48 89 d1             	mov    %rdx,%rcx
ffffffff8000388b:	48 89 f2             	mov    %rsi,%rdx
  va_start(va, format);
ffffffff8000388e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff80003893:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff80003898:	48 89 fe             	mov    %rdi,%rsi
ffffffff8000389b:	48 c7 c7 00 27 00 80 	mov    $0xffffffff80002700,%rdi
{
ffffffff800038a2:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  va_start(va, format);
ffffffff800038a7:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%rsp)
ffffffff800038ae:	00 
ffffffff800038af:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff800038b4:	e8 77 f4 ff ff       	callq  ffffffff80002d30 <_vsnprintf>
  va_end(va);
  return ret;
}
ffffffff800038b9:	48 83 c4 58          	add    $0x58,%rsp
ffffffff800038bd:	c3                   	retq   
ffffffff800038be:	66 90                	xchg   %ax,%ax

ffffffff800038c0 <vprintf_>:


int vprintf_(const char* format, va_list va)
{
ffffffff800038c0:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff800038c4:	49 89 f0             	mov    %rsi,%r8
ffffffff800038c7:	48 89 f9             	mov    %rdi,%rcx
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff800038ca:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
ffffffff800038cf:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
ffffffff800038d6:	48 c7 c7 90 37 00 80 	mov    $0xffffffff80003790,%rdi
ffffffff800038dd:	e8 4e f4 ff ff       	callq  ffffffff80002d30 <_vsnprintf>
}
ffffffff800038e2:	48 83 c4 18          	add    $0x18,%rsp
ffffffff800038e6:	c3                   	retq   
ffffffff800038e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800038ee:	00 00 

ffffffff800038f0 <vsnprintf_>:


int vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
ffffffff800038f0:	49 89 c8             	mov    %rcx,%r8
  return _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff800038f3:	48 89 d1             	mov    %rdx,%rcx
ffffffff800038f6:	48 89 f2             	mov    %rsi,%rdx
ffffffff800038f9:	48 89 fe             	mov    %rdi,%rsi
ffffffff800038fc:	48 c7 c7 00 27 00 80 	mov    $0xffffffff80002700,%rdi
ffffffff80003903:	e9 28 f4 ff ff       	jmpq   ffffffff80002d30 <_vsnprintf>
ffffffff80003908:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000390f:	00 

ffffffff80003910 <fctprintf>:
}


int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
ffffffff80003910:	48 83 ec 68          	sub    $0x68,%rsp
  va_list va;
  va_start(va, format);
ffffffff80003914:	48 8d 44 24 70       	lea    0x70(%rsp),%rax
{
ffffffff80003919:	4c 89 44 24 50       	mov    %r8,0x50(%rsp)
  const out_fct_wrap_type out_fct_wrap = { out, arg };
ffffffff8000391e:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff80003923:	4c 8d 44 24 18       	lea    0x18(%rsp),%r8
ffffffff80003928:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
{
ffffffff8000392d:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
  va_start(va, format);
ffffffff80003932:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
ffffffff80003937:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
  const out_fct_wrap_type out_fct_wrap = { out, arg };
ffffffff8000393c:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff80003941:	48 89 d1             	mov    %rdx,%rcx
ffffffff80003944:	48 c7 c7 20 27 00 80 	mov    $0xffffffff80002720,%rdi
ffffffff8000394b:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
{
ffffffff80003952:	4c 89 4c 24 58       	mov    %r9,0x58(%rsp)
  va_start(va, format);
ffffffff80003957:	c7 44 24 18 18 00 00 	movl   $0x18,0x18(%rsp)
ffffffff8000395e:	00 
ffffffff8000395f:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff80003964:	e8 c7 f3 ff ff       	callq  ffffffff80002d30 <_vsnprintf>
  va_end(va);
  return ret;
ffffffff80003969:	48 83 c4 68          	add    $0x68,%rsp
ffffffff8000396d:	c3                   	retq   
ffffffff8000396e:	66 90                	xchg   %ax,%ax

ffffffff80003970 <_putchar>:
#include "../device/console/console.h"

void _putchar(char character)
{
    
    putchar(character);
ffffffff80003970:	40 0f b6 ff          	movzbl %dil,%edi
ffffffff80003974:	e9 07 e3 ff ff       	jmpq   ffffffff80001c80 <putchar>
ffffffff80003979:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80003980 <serial_printf>:
    
    //serial_write(0x3F8, character);
}

void serial_printf(uint16_t port, const char* format, ...)
{
ffffffff80003980:	53                   	push   %rbx
ffffffff80003981:	89 fb                	mov    %edi,%ebx
ffffffff80003983:	48 81 ec 50 01 00 00 	sub    $0x150,%rsp
    char buffer[256];

    va_list argptr;
    va_start(argptr, format);
ffffffff8000398a:	48 8d 84 24 60 01 00 	lea    0x160(%rsp),%rax
ffffffff80003991:	00 
{
ffffffff80003992:	48 89 8c 24 38 01 00 	mov    %rcx,0x138(%rsp)
ffffffff80003999:	00 
    vsnprintf(buffer, 256, format, argptr);
ffffffff8000399a:	48 8d 7c 24 20       	lea    0x20(%rsp),%rdi
ffffffff8000399f:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
{
ffffffff800039a4:	48 89 94 24 30 01 00 	mov    %rdx,0x130(%rsp)
ffffffff800039ab:	00 
    vsnprintf(buffer, 256, format, argptr);
ffffffff800039ac:	48 89 f2             	mov    %rsi,%rdx
    va_start(argptr, format);
ffffffff800039af:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff800039b4:	48 8d 84 24 20 01 00 	lea    0x120(%rsp),%rax
ffffffff800039bb:	00 
    vsnprintf(buffer, 256, format, argptr);
ffffffff800039bc:	be 00 01 00 00       	mov    $0x100,%esi
{
ffffffff800039c1:	4c 89 84 24 40 01 00 	mov    %r8,0x140(%rsp)
ffffffff800039c8:	00 
ffffffff800039c9:	4c 89 8c 24 48 01 00 	mov    %r9,0x148(%rsp)
ffffffff800039d0:	00 
    va_start(argptr, format);
ffffffff800039d1:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%rsp)
ffffffff800039d8:	00 
ffffffff800039d9:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    vsnprintf(buffer, 256, format, argptr);
ffffffff800039de:	e8 0d ff ff ff       	callq  ffffffff800038f0 <vsnprintf_>
    va_end(argptr);

    serial_write_str(port, buffer);
ffffffff800039e3:	48 8d 74 24 20       	lea    0x20(%rsp),%rsi
ffffffff800039e8:	0f b7 fb             	movzwl %bx,%edi
ffffffff800039eb:	e8 b0 e8 ff ff       	callq  ffffffff800022a0 <serial_write_str>
ffffffff800039f0:	48 81 c4 50 01 00 00 	add    $0x150,%rsp
ffffffff800039f7:	5b                   	pop    %rbx
ffffffff800039f8:	c3                   	retq   
ffffffff800039f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80003a00 <gdt_init>:
uint8_t ist2[4096];

void gdt_init()
{
    gdt.null0.raw = 0x00;
    gdt.kcode.raw = 0x00AF9A000000FFFF;
ffffffff80003a00:	48 b8 ff ff 00 00 00 	movabs $0xaf9a000000ffff,%rax
ffffffff80003a07:	9a af 00 
    tss.ist1 = (uint64_t)ist1 + sizeof(ist1);

    gdtr.base = (uint64_t)&gdt;
    gdtr.limit = sizeof(gdt);

    gdt_load((uint64_t*)&gdtr, 0x50);
ffffffff80003a0a:	be 50 00 00 00       	mov    $0x50,%esi
ffffffff80003a0f:	48 c7 c7 e0 0a 01 80 	mov    $0xffffffff80010ae0,%rdi
    gdt.kcode.raw = 0x00AF9A000000FFFF;
ffffffff80003a16:	48 89 05 6b d1 00 00 	mov    %rax,0xd16b(%rip)        # ffffffff80010b88 <gdt+0x8>
    gdt.kdata.raw = 0x00AF92000000FFFF;
ffffffff80003a1d:	48 b8 ff ff 00 00 00 	movabs $0xaf92000000ffff,%rax
ffffffff80003a24:	92 af 00 
    gdt.null0.raw = 0x00;
ffffffff80003a27:	48 c7 05 4e d1 00 00 	movq   $0x0,0xd14e(%rip)        # ffffffff80010b80 <gdt>
ffffffff80003a2e:	00 00 00 00 
    gdt.kdata.raw = 0x00AF92000000FFFF;
ffffffff80003a32:	48 89 05 57 d1 00 00 	mov    %rax,0xd157(%rip)        # ffffffff80010b90 <gdt+0x10>
    gdt.ucode.raw = 0x00AFFA000000FFFF;
ffffffff80003a39:	48 b8 ff ff 00 00 00 	movabs $0xaffa000000ffff,%rax
ffffffff80003a40:	fa af 00 
    gdt.null1.raw = 0x00;
ffffffff80003a43:	48 c7 05 4a d1 00 00 	movq   $0x0,0xd14a(%rip)        # ffffffff80010b98 <gdt+0x18>
ffffffff80003a4a:	00 00 00 00 
    gdt.ucode.raw = 0x00AFFA000000FFFF;
ffffffff80003a4e:	48 89 05 53 d1 00 00 	mov    %rax,0xd153(%rip)        # ffffffff80010ba8 <gdt+0x28>
    gdt.udata.raw = 0x00AFF2000000FFFF;
ffffffff80003a55:	48 b8 ff ff 00 00 00 	movabs $0xaff2000000ffff,%rax
ffffffff80003a5c:	f2 af 00 
    gdt.null2.raw = 0x00;
ffffffff80003a5f:	48 c7 05 46 d1 00 00 	movq   $0x0,0xd146(%rip)        # ffffffff80010bb0 <gdt+0x30>
ffffffff80003a66:	00 00 00 00 
    gdt.udata.raw = 0x00AFF2000000FFFF;
ffffffff80003a6a:	48 89 05 2f d1 00 00 	mov    %rax,0xd12f(%rip)        # ffffffff80010ba0 <gdt+0x20>
    gdt.tss_entry.base0 = (uint64_t)&tss & 0xFFFF;
ffffffff80003a71:	48 c7 c0 00 0b 01 80 	mov    $0xffffffff80010b00,%rax
    gdt.null3.raw = 0x00;
ffffffff80003a78:	48 c7 05 35 d1 00 00 	movq   $0x0,0xd135(%rip)        # ffffffff80010bb8 <gdt+0x38>
ffffffff80003a7f:	00 00 00 00 
    gdt.tss_entry.base16 = ((uint64_t)&tss >> 16) & 0xFF;
ffffffff80003a83:	48 89 c2             	mov    %rax,%rdx
    gdt.tss_entry.base0 = (uint64_t)&tss & 0xFFFF;
ffffffff80003a86:	66 89 05 45 d1 00 00 	mov    %ax,0xd145(%rip)        # ffffffff80010bd2 <gdt+0x52>
    gdt.null4.raw = 0x00;
ffffffff80003a8d:	48 c7 05 28 d1 00 00 	movq   $0x0,0xd128(%rip)        # ffffffff80010bc0 <gdt+0x40>
ffffffff80003a94:	00 00 00 00 
    gdt.tss_entry.base16 = ((uint64_t)&tss >> 16) & 0xFF;
ffffffff80003a98:	48 c1 ea 10          	shr    $0x10,%rdx
    gdt.null5.raw = 0x00;
ffffffff80003a9c:	48 c7 05 21 d1 00 00 	movq   $0x0,0xd121(%rip)        # ffffffff80010bc8 <gdt+0x48>
ffffffff80003aa3:	00 00 00 00 
    gdt.tss_entry.segment_type = 0x09;      //64 bit TSS
ffffffff80003aa7:	c6 05 27 d1 00 00 89 	movb   $0x89,0xd127(%rip)        # ffffffff80010bd5 <gdt+0x55>
    gdt.tss_entry.base16 = ((uint64_t)&tss >> 16) & 0xFF;
ffffffff80003aae:	88 15 20 d1 00 00    	mov    %dl,0xd120(%rip)        # ffffffff80010bd4 <gdt+0x54>
    gdt.tss_entry.base24 = ((uint64_t)&tss >> 24) & 0xFF;
ffffffff80003ab4:	48 89 c2             	mov    %rax,%rdx
    gdt.tss_entry.base32 = ((uint64_t)&tss >> 32) & 0xFFFFFFFF;
ffffffff80003ab7:	48 c1 e8 20          	shr    $0x20,%rax
ffffffff80003abb:	89 05 17 d1 00 00    	mov    %eax,0xd117(%rip)        # ffffffff80010bd8 <gdt+0x58>
    gdt.tss_entry.limit0 = sizeof(tss);
ffffffff80003ac1:	b8 68 00 00 00       	mov    $0x68,%eax
    gdt.tss_entry.base24 = ((uint64_t)&tss >> 24) & 0xFF;
ffffffff80003ac6:	48 c1 ea 18          	shr    $0x18,%rdx
    gdt.tss_entry.limit0 = sizeof(tss);
ffffffff80003aca:	66 89 05 ff d0 00 00 	mov    %ax,0xd0ff(%rip)        # ffffffff80010bd0 <gdt+0x50>
    gdt.tss_entry.reserved0 = 0;
ffffffff80003ad1:	0f b6 05 fe d0 00 00 	movzbl 0xd0fe(%rip),%eax        # ffffffff80010bd6 <gdt+0x56>
    gdt.tss_entry.base24 = ((uint64_t)&tss >> 24) & 0xFF;
ffffffff80003ad8:	88 15 f9 d0 00 00    	mov    %dl,0xd0f9(%rip)        # ffffffff80010bd7 <gdt+0x57>
    gdtr.limit = sizeof(gdt);
ffffffff80003ade:	ba 60 00 00 00       	mov    $0x60,%edx
    gdt.tss_entry.reserved1 = 0;
ffffffff80003ae3:	c7 05 ef d0 00 00 00 	movl   $0x0,0xd0ef(%rip)        # ffffffff80010bdc <gdt+0x5c>
ffffffff80003aea:	00 00 00 
    tss.reserved0 = 0x00;
ffffffff80003aed:	c7 05 09 d0 00 00 00 	movl   $0x0,0xd009(%rip)        # ffffffff80010b00 <tss>
ffffffff80003af4:	00 00 00 
    tss.RSP0 = (uint64_t)stack + sizeof(stack);
ffffffff80003af7:	48 c7 05 02 d0 00 00 	movq   $0xffffffff8000ade0,0xd002(%rip)        # ffffffff80010b04 <tss+0x4>
ffffffff80003afe:	e0 ad 00 80 
    tss.RSP2 = (uint64_t)rsp2stack + sizeof(rsp2stack);
ffffffff80003b02:	48 c7 05 07 d0 00 00 	movq   $0xffffffff8000ea80,0xd007(%rip)        # ffffffff80010b14 <tss+0x14>
ffffffff80003b09:	80 ea 00 80 
    tss.ist1 = (uint64_t)ist1 + sizeof(ist1);
ffffffff80003b0d:	48 c7 05 0c d0 00 00 	movq   $0xffffffff80010a80,0xd00c(%rip)        # ffffffff80010b24 <tss+0x24>
ffffffff80003b14:	80 0a 01 80 
    gdt.tss_entry.reserved0 = 0;
ffffffff80003b18:	83 e0 40             	and    $0x40,%eax
    gdtr.base = (uint64_t)&gdt;
ffffffff80003b1b:	48 c7 05 bc cf 00 00 	movq   $0xffffffff80010b80,0xcfbc(%rip)        # ffffffff80010ae2 <gdtr+0x2>
ffffffff80003b22:	80 0b 01 80 
    gdtr.limit = sizeof(gdt);
ffffffff80003b26:	66 89 15 b3 cf 00 00 	mov    %dx,0xcfb3(%rip)        # ffffffff80010ae0 <gdtr>
    gdt.tss_entry.reserved0 = 0;
ffffffff80003b2d:	88 05 a3 d0 00 00    	mov    %al,0xd0a3(%rip)        # ffffffff80010bd6 <gdt+0x56>
    gdt_load((uint64_t*)&gdtr, 0x50);
ffffffff80003b33:	e9 98 c5 ff ff       	jmpq   ffffffff800000d0 <gdt_load>
ffffffff80003b38:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80003b3f:	00 

ffffffff80003b40 <load_elf>:
//#include <memory.h>

uint64_t load_elf(void* ptr)
{

ffffffff80003b40:	f3 c3                	repz retq 
ffffffff80003b42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80003b49:	00 00 00 
ffffffff80003b4c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80003b50 <oct2bin>:

uint64_t oct2bin(uint8_t* str, uint16_t size)
{
    uint64_t n = 0;
    uint8_t* c = str;
    while (size-- > 0)
ffffffff80003b50:	66 85 f6             	test   %si,%si
ffffffff80003b53:	8d 46 ff             	lea    -0x1(%rsi),%eax
ffffffff80003b56:	74 28                	je     ffffffff80003b80 <oct2bin+0x30>
ffffffff80003b58:	0f b7 c0             	movzwl %ax,%eax
ffffffff80003b5b:	48 8d 4c 07 01       	lea    0x1(%rdi,%rax,1),%rcx
    uint64_t n = 0;
ffffffff80003b60:	31 c0                	xor    %eax,%eax
ffffffff80003b62:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    {
        n *= 8;
        n += *c - '0';
ffffffff80003b68:	0f b6 17             	movzbl (%rdi),%edx
        c++;
ffffffff80003b6b:	48 83 c7 01          	add    $0x1,%rdi
        n += *c - '0';
ffffffff80003b6f:	83 ea 30             	sub    $0x30,%edx
    while (size-- > 0)
ffffffff80003b72:	48 39 cf             	cmp    %rcx,%rdi
        n += *c - '0';
ffffffff80003b75:	48 63 d2             	movslq %edx,%rdx
ffffffff80003b78:	48 8d 04 c2          	lea    (%rdx,%rax,8),%rax
    while (size-- > 0)
ffffffff80003b7c:	75 ea                	jne    ffffffff80003b68 <oct2bin+0x18>
ffffffff80003b7e:	f3 c3                	repz retq 
    uint64_t n = 0;
ffffffff80003b80:	31 c0                	xor    %eax,%eax
    }
    return n;
}
ffffffff80003b82:	c3                   	retq   
ffffffff80003b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80003b8a:	00 00 00 
ffffffff80003b8d:	0f 1f 00             	nopl   (%rax)

ffffffff80003b90 <kernel>:
#include <libk/liballoc.h>
#include "./device/serial/stty.h"
#include "./usermode/usermode.h"

void kernel()
{
ffffffff80003b90:	55                   	push   %rbp
ffffffff80003b91:	53                   	push   %rbx
    //printf("Kernel Now\n");
    serial_init(0x3F8);     //COM1
ffffffff80003b92:	bf f8 03 00 00       	mov    $0x3f8,%edi
{
ffffffff80003b97:	48 83 ec 08          	sub    $0x8,%rsp
    serial_init(0x3F8);     //COM1
ffffffff80003b9b:	e8 a0 e5 ff ff       	callq  ffffffff80002140 <serial_init>
    gdt_init();
ffffffff80003ba0:	31 c0                	xor    %eax,%eax
ffffffff80003ba2:	e8 59 fe ff ff       	callq  ffffffff80003a00 <gdt_init>
    idt_init();
ffffffff80003ba7:	31 c0                	xor    %eax,%eax
ffffffff80003ba9:	e8 32 01 00 00       	callq  ffffffff80003ce0 <idt_init>
    fb_init();
ffffffff80003bae:	31 c0                	xor    %eax,%eax
ffffffff80003bb0:	e8 9b df ff ff       	callq  ffffffff80001b50 <fb_init>
    console_init();
ffffffff80003bb5:	31 c0                	xor    %eax,%eax
ffffffff80003bb7:	e8 d4 e3 ff ff       	callq  ffffffff80001f90 <console_init>

    pmm_init();
ffffffff80003bbc:	31 c0                	xor    %eax,%eax
ffffffff80003bbe:	e8 cd da ff ff       	callq  ffffffff80001690 <pmm_init>
    vmm_init();
ffffffff80003bc3:	31 c0                	xor    %eax,%eax
ffffffff80003bc5:	e8 c6 d0 ff ff       	callq  ffffffff80000c90 <vmm_init>

    user_init();
ffffffff80003bca:	31 c0                	xor    %eax,%eax
ffffffff80003bcc:	e8 9f c8 ff ff       	callq  ffffffff80000470 <user_init>
    
    serial_printf(SERIAL_PORT1, "Kernel Physical Base Address %x\n", boot_info.tag_kernel_base_address->physical_base_address);
ffffffff80003bd1:	48 8b 05 08 72 00 00 	mov    0x7208(%rip),%rax        # ffffffff8000ade0 <boot_info>
ffffffff80003bd8:	48 c7 c6 08 57 00 80 	mov    $0xffffffff80005708,%rsi
ffffffff80003bdf:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003be4:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff80003be8:	31 c0                	xor    %eax,%eax
ffffffff80003bea:	e8 91 fd ff ff       	callq  ffffffff80003980 <serial_printf>
    serial_printf(SERIAL_PORT1, "Kernel Virtual Base Address  %x\n", boot_info.tag_kernel_base_address->virtual_base_address);
ffffffff80003bef:	48 8b 05 ea 71 00 00 	mov    0x71ea(%rip),%rax        # ffffffff8000ade0 <boot_info>
ffffffff80003bf6:	48 c7 c6 30 57 00 80 	mov    $0xffffffff80005730,%rsi
ffffffff80003bfd:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003c02:	48 8b 50 18          	mov    0x18(%rax),%rdx
ffffffff80003c06:	31 c0                	xor    %eax,%eax
ffffffff80003c08:	e8 73 fd ff ff       	callq  ffffffff80003980 <serial_printf>

    serial_printf(SERIAL_PORT1, "PMRS Entries:  %d\n", boot_info.tag_pmrs->entries);
ffffffff80003c0d:	48 8b 05 0c 72 00 00 	mov    0x720c(%rip),%rax        # ffffffff8000ae20 <boot_info+0x40>
ffffffff80003c14:	48 c7 c6 81 57 00 80 	mov    $0xffffffff80005781,%rsi
ffffffff80003c1b:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003c20:	48 8b 50 10          	mov    0x10(%rax),%rdx
ffffffff80003c24:	31 c0                	xor    %eax,%eax
ffffffff80003c26:	e8 55 fd ff ff       	callq  ffffffff80003980 <serial_printf>
    for(uint64_t i = 0; i < boot_info.tag_pmrs->entries; i++)
ffffffff80003c2b:	48 8b 05 ee 71 00 00 	mov    0x71ee(%rip),%rax        # ffffffff8000ae20 <boot_info+0x40>
ffffffff80003c32:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
ffffffff80003c37:	74 43                	je     ffffffff80003c7c <kernel+0xec>
ffffffff80003c39:	31 db                	xor    %ebx,%ebx
    {
        serial_printf(SERIAL_PORT1, "Base: %p,  Length: %x,  Permissions: %d\n", boot_info.tag_pmrs->pmrs[i].base, boot_info.tag_pmrs->pmrs[i].length, boot_info.tag_pmrs->pmrs[i].permissions);
ffffffff80003c3b:	48 c7 c5 58 57 00 80 	mov    $0xffffffff80005758,%rbp
ffffffff80003c42:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff80003c48:	48 8d 14 5b          	lea    (%rbx,%rbx,2),%rdx
ffffffff80003c4c:	48 89 ee             	mov    %rbp,%rsi
ffffffff80003c4f:	bf f8 03 00 00       	mov    $0x3f8,%edi
    for(uint64_t i = 0; i < boot_info.tag_pmrs->entries; i++)
ffffffff80003c54:	48 83 c3 01          	add    $0x1,%rbx
        serial_printf(SERIAL_PORT1, "Base: %p,  Length: %x,  Permissions: %d\n", boot_info.tag_pmrs->pmrs[i].base, boot_info.tag_pmrs->pmrs[i].length, boot_info.tag_pmrs->pmrs[i].permissions);
ffffffff80003c58:	48 8d 04 d0          	lea    (%rax,%rdx,8),%rax
ffffffff80003c5c:	4c 8b 40 28          	mov    0x28(%rax),%r8
ffffffff80003c60:	48 8b 48 20          	mov    0x20(%rax),%rcx
ffffffff80003c64:	48 8b 50 18          	mov    0x18(%rax),%rdx
ffffffff80003c68:	31 c0                	xor    %eax,%eax
ffffffff80003c6a:	e8 11 fd ff ff       	callq  ffffffff80003980 <serial_printf>
    for(uint64_t i = 0; i < boot_info.tag_pmrs->entries; i++)
ffffffff80003c6f:	48 8b 05 aa 71 00 00 	mov    0x71aa(%rip),%rax        # ffffffff8000ae20 <boot_info+0x40>
ffffffff80003c76:	48 39 58 10          	cmp    %rbx,0x10(%rax)
ffffffff80003c7a:	77 cc                	ja     ffffffff80003c48 <kernel+0xb8>

    



    printf("Kernel Done!\n"); 
ffffffff80003c7c:	48 c7 c7 94 57 00 80 	mov    $0xffffffff80005794,%rdi
ffffffff80003c83:	31 c0                	xor    %eax,%eax
ffffffff80003c85:	e8 26 fb ff ff       	callq  ffffffff800037b0 <printf_>
ffffffff80003c8a:	eb fe                	jmp    ffffffff80003c8a <kernel+0xfa>
ffffffff80003c8c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80003c90 <create_descriptor>:

void create_descriptor(uint16_t index, void* isr, uint8_t ist, uint8_t cs, uint8_t attr)
{
    struct idt_entry* entry = &idt[index];

    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80003c90:	0f b7 ff             	movzwl %di,%edi
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003c93:	48 89 f0             	mov    %rsi,%rax
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
    entry->ist = ist;
    entry->kernel_cs = cs;
ffffffff80003c96:	0f b6 c9             	movzbl %cl,%ecx
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80003c99:	48 c1 e7 04          	shl    $0x4,%rdi
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003c9d:	48 c1 e8 10          	shr    $0x10,%rax
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80003ca1:	66 89 b7 00 0c 01 80 	mov    %si,-0x7ffef400(%rdi)
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003ca8:	48 c1 ee 20          	shr    $0x20,%rsi
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003cac:	66 89 87 06 0c 01 80 	mov    %ax,-0x7ffef3fa(%rdi)
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003cb3:	89 b7 08 0c 01 80    	mov    %esi,-0x7ffef3f8(%rdi)
    entry->ist = ist;
ffffffff80003cb9:	88 97 04 0c 01 80    	mov    %dl,-0x7ffef3fc(%rdi)
    entry->kernel_cs = cs;
ffffffff80003cbf:	66 89 8f 02 0c 01 80 	mov    %cx,-0x7ffef3fe(%rdi)
    entry->attributes = attr;
ffffffff80003cc6:	44 88 87 05 0c 01 80 	mov    %r8b,-0x7ffef3fb(%rdi)
    entry->reserved = 0;
ffffffff80003ccd:	c7 87 0c 0c 01 80 00 	movl   $0x0,-0x7ffef3f4(%rdi)
ffffffff80003cd4:	00 00 00 
}
ffffffff80003cd7:	c3                   	retq   
ffffffff80003cd8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80003cdf:	00 

ffffffff80003ce0 <idt_init>:

void idt_init()
{
    //uint64_t idt_ptr = hh_code_to_phys((uint64_t)&idt[0]);
    idtr.base = (uint64_t)&idt[0];
ffffffff80003ce0:	48 c7 c0 00 0c 01 80 	mov    $0xffffffff80010c00,%rax
    idtr.limit = (uint16_t)(sizeof(idt) - 1);
ffffffff80003ce7:	b9 ff 0f 00 00       	mov    $0xfff,%ecx
{
ffffffff80003cec:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80003cf0:	48 8d b8 f0 02 00 00 	lea    0x2f0(%rax),%rdi
    idtr.limit = (uint16_t)(sizeof(idt) - 1);
ffffffff80003cf7:	66 89 0d ea ce 00 00 	mov    %cx,0xceea(%rip)        # ffffffff80010be8 <idtr>
    idtr.base = (uint64_t)&idt[0];
ffffffff80003cfe:	48 89 05 e5 ce 00 00 	mov    %rax,0xcee5(%rip)        # ffffffff80010bea <idtr+0x2>
ffffffff80003d05:	48 c7 c1 d8 02 00 80 	mov    $0xffffffff800002d8,%rcx
ffffffff80003d0c:	0f 1f 40 00          	nopl   0x0(%rax)

    for(uint8_t index = 0; index < 47; index++)
    {
        create_descriptor(index, isr_stub_table[index], 0x00, 0x08, 0x8E);
ffffffff80003d10:	48 8b 11             	mov    (%rcx),%rdx
    entry->ist = ist;
ffffffff80003d13:	c6 40 04 00          	movb   $0x0,0x4(%rax)
ffffffff80003d17:	48 83 c0 10          	add    $0x10,%rax
    entry->attributes = attr;
ffffffff80003d1b:	c6 40 f5 8e          	movb   $0x8e,-0xb(%rax)
    entry->reserved = 0;
ffffffff80003d1f:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%rax)
ffffffff80003d26:	48 83 c1 08          	add    $0x8,%rcx
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80003d2a:	66 89 50 f0          	mov    %dx,-0x10(%rax)
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003d2e:	48 89 d6             	mov    %rdx,%rsi
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003d31:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff80003d35:	89 50 f8             	mov    %edx,-0x8(%rax)
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003d38:	48 c1 ee 10          	shr    $0x10,%rsi
    entry->kernel_cs = cs;
ffffffff80003d3c:	ba 08 00 00 00       	mov    $0x8,%edx
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003d41:	66 89 70 f6          	mov    %si,-0xa(%rax)
    entry->kernel_cs = cs;
ffffffff80003d45:	66 89 50 f2          	mov    %dx,-0xe(%rax)
    for(uint8_t index = 0; index < 47; index++)
ffffffff80003d49:	48 39 f8             	cmp    %rdi,%rax
ffffffff80003d4c:	75 c2                	jne    ffffffff80003d10 <idt_init+0x30>
    }

    create_descriptor(127, isr_stub_table[48], 0x00, 0x08, 0x8E);
ffffffff80003d4e:	48 8b 05 03 c7 ff ff 	mov    -0x38fd(%rip),%rax        # ffffffff80000458 <isr_stub_table+0x180>
    entry->kernel_cs = cs;
ffffffff80003d55:	c7 05 93 d6 00 00 08 	movl   $0x8e000008,0xd693(%rip)        # ffffffff800113f2 <idt+0x7f2>
ffffffff80003d5c:	00 00 8e 
    entry->reserved = 0;
ffffffff80003d5f:	c7 05 93 d6 00 00 00 	movl   $0x0,0xd693(%rip)        # ffffffff800113fc <idt+0x7fc>
ffffffff80003d66:	00 00 00 
    entry->kernel_cs = cs;
ffffffff80003d69:	c7 05 8f d6 00 00 08 	movl   $0x8e000008,0xd68f(%rip)        # ffffffff80011402 <idt+0x802>
ffffffff80003d70:	00 00 8e 
    entry->reserved = 0;
ffffffff80003d73:	c7 05 8f d6 00 00 00 	movl   $0x0,0xd68f(%rip)        # ffffffff8001140c <idt+0x80c>
ffffffff80003d7a:	00 00 00 
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80003d7d:	66 89 05 6c d6 00 00 	mov    %ax,0xd66c(%rip)        # ffffffff800113f0 <idt+0x7f0>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003d84:	48 89 c2             	mov    %rax,%rdx
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003d87:	48 c1 e8 20          	shr    $0x20,%rax
ffffffff80003d8b:	89 05 67 d6 00 00    	mov    %eax,0xd667(%rip)        # ffffffff800113f8 <idt+0x7f8>
    create_descriptor(128, isr_stub_table[49], 0x00, 0x08, 0x8E);
ffffffff80003d91:	48 8b 05 c8 c6 ff ff 	mov    -0x3938(%rip),%rax        # ffffffff80000460 <isr_stub_table+0x188>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003d98:	48 c1 ea 10          	shr    $0x10,%rdx
ffffffff80003d9c:	66 89 15 53 d6 00 00 	mov    %dx,0xd653(%rip)        # ffffffff800113f6 <idt+0x7f6>
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80003da3:	66 89 05 56 d6 00 00 	mov    %ax,0xd656(%rip)        # ffffffff80011400 <idt+0x800>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003daa:	48 89 c2             	mov    %rax,%rdx
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003dad:	48 c1 e8 20          	shr    $0x20,%rax
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003db1:	48 c1 ea 10          	shr    $0x10,%rdx
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003db5:	89 05 4d d6 00 00    	mov    %eax,0xd64d(%rip)        # ffffffff80011408 <idt+0x808>

    pic_remap();
ffffffff80003dbb:	31 c0                	xor    %eax,%eax
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003dbd:	66 89 15 42 d6 00 00 	mov    %dx,0xd642(%rip)        # ffffffff80011406 <idt+0x806>
    pic_remap();
ffffffff80003dc4:	e8 c7 e7 ff ff       	callq  ffffffff80002590 <pic_remap>
    pic_disable();
ffffffff80003dc9:	31 c0                	xor    %eax,%eax
ffffffff80003dcb:	e8 90 e7 ff ff       	callq  ffffffff80002560 <pic_disable>

    

    idt_load(&idtr);
ffffffff80003dd0:	48 c7 c7 e8 0b 01 80 	mov    $0xffffffff80010be8,%rdi
ffffffff80003dd7:	e8 8c c6 ff ff       	callq  ffffffff80000468 <idt_load>

    pit_init(10000);
ffffffff80003ddc:	bf 10 27 00 00       	mov    $0x2710,%edi
ffffffff80003de1:	e8 aa e8 ff ff       	callq  ffffffff80002690 <pit_init>

    pic_clear_mask(1);
ffffffff80003de6:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff80003deb:	e8 20 e7 ff ff       	callq  ffffffff80002510 <pic_clear_mask>
    pic_clear_mask(0);
ffffffff80003df0:	31 ff                	xor    %edi,%edi
ffffffff80003df2:	e8 19 e7 ff ff       	callq  ffffffff80002510 <pic_clear_mask>

    serial_printf(SERIAL_PORT1, "IDT: %p\n", (uint64_t)&idt);
ffffffff80003df7:	48 c7 c2 00 0c 01 80 	mov    $0xffffffff80010c00,%rdx
ffffffff80003dfe:	48 c7 c6 a2 57 00 80 	mov    $0xffffffff800057a2,%rsi
ffffffff80003e05:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003e0a:	31 c0                	xor    %eax,%eax

    //__asm__ volatile ("lidt %0" : : "m"(idtr));
    //__asm__ volatile ("sti");
}
ffffffff80003e0c:	48 83 c4 08          	add    $0x8,%rsp
    serial_printf(SERIAL_PORT1, "IDT: %p\n", (uint64_t)&idt);
ffffffff80003e10:	e9 6b fb ff ff       	jmpq   ffffffff80003980 <serial_printf>
ffffffff80003e15:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80003e1c:	00 00 00 00 

ffffffff80003e20 <interrupt_handler>:

uint64_t interrupt_handler(uint64_t rsp)
{
ffffffff80003e20:	55                   	push   %rbp
ffffffff80003e21:	53                   	push   %rbx
ffffffff80003e22:	48 89 fb             	mov    %rdi,%rbx
ffffffff80003e25:	48 83 ec 08          	sub    $0x8,%rsp
    struct interrupt_stack_frame* frame = (struct interrupt_stack_frame*)rsp;
    
    if(frame->int_no < 32)
ffffffff80003e29:	48 8b 77 78          	mov    0x78(%rdi),%rsi
ffffffff80003e2d:	48 83 fe 1f          	cmp    $0x1f,%rsi
ffffffff80003e31:	77 1d                	ja     ffffffff80003e50 <interrupt_handler+0x30>
    {
        if(frame->cs == 0x08)
ffffffff80003e33:	48 83 bf 90 00 00 00 	cmpq   $0x8,0x90(%rdi)
ffffffff80003e3a:	08 
ffffffff80003e3b:	74 63                	je     ffffffff80003ea0 <interrupt_handler+0x80>
    {
        printf("Syscall 127\n");
        return rsp;
    }
    return rsp;
ffffffff80003e3d:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80003e41:	48 89 d8             	mov    %rbx,%rax
ffffffff80003e44:	5b                   	pop    %rbx
ffffffff80003e45:	5d                   	pop    %rbp
ffffffff80003e46:	c3                   	retq   
ffffffff80003e47:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80003e4e:	00 00 
    else if (frame->int_no < 48)
ffffffff80003e50:	48 83 fe 2f          	cmp    $0x2f,%rsi
ffffffff80003e54:	77 32                	ja     ffffffff80003e88 <interrupt_handler+0x68>
        uint64_t irq = frame->int_no - 32;
ffffffff80003e56:	48 8d 6e e0          	lea    -0x20(%rsi),%rbp
        if(irq > 1)
ffffffff80003e5a:	48 83 fd 01          	cmp    $0x1,%rbp
ffffffff80003e5e:	0f 87 3c 02 00 00    	ja     ffffffff800040a0 <interrupt_handler+0x280>
        switch(irq)
ffffffff80003e64:	0f 84 26 02 00 00    	je     ffffffff80004090 <interrupt_handler+0x270>
                pit_ticks++;
ffffffff80003e6a:	48 83 05 6e cd 00 00 	addq   $0x1,0xcd6e(%rip)        # ffffffff80010be0 <pit_ticks>
ffffffff80003e71:	01 
        pic_EOI(irq);
ffffffff80003e72:	89 ef                	mov    %ebp,%edi
ffffffff80003e74:	e8 07 e6 ff ff       	callq  ffffffff80002480 <pic_EOI>
ffffffff80003e79:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80003e7d:	48 89 d8             	mov    %rbx,%rax
ffffffff80003e80:	5b                   	pop    %rbx
ffffffff80003e81:	5d                   	pop    %rbp
ffffffff80003e82:	c3                   	retq   
ffffffff80003e83:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    else if (frame->int_no == 127)
ffffffff80003e88:	48 83 fe 7f          	cmp    $0x7f,%rsi
ffffffff80003e8c:	75 af                	jne    ffffffff80003e3d <interrupt_handler+0x1d>
        printf("Syscall 127\n");
ffffffff80003e8e:	48 c7 c7 d1 57 00 80 	mov    $0xffffffff800057d1,%rdi
ffffffff80003e95:	31 c0                	xor    %eax,%eax
ffffffff80003e97:	e8 14 f9 ff ff       	callq  ffffffff800037b0 <printf_>
        return rsp;
ffffffff80003e9c:	eb 9f                	jmp    ffffffff80003e3d <interrupt_handler+0x1d>
ffffffff80003e9e:	66 90                	xchg   %ax,%ax
            uint64_t cr2 = read_cr2();
ffffffff80003ea0:	31 c0                	xor    %eax,%eax
ffffffff80003ea2:	e8 59 c2 ff ff       	callq  ffffffff80000100 <read_cr2>
            serial_printf(SERIAL_PORT1, "CPU Exception: %d  ERR %x  CR2 %p\r\n", frame->int_no, frame->err_no, cr2);
ffffffff80003ea7:	48 8b 8b 80 00 00 00 	mov    0x80(%rbx),%rcx
ffffffff80003eae:	48 8b 53 78          	mov    0x78(%rbx),%rdx
ffffffff80003eb2:	49 89 c0             	mov    %rax,%r8
ffffffff80003eb5:	48 c7 c6 50 59 00 80 	mov    $0xffffffff80005950,%rsi
ffffffff80003ebc:	bf f8 03 00 00       	mov    $0x3f8,%edi
            uint64_t cr2 = read_cr2();
ffffffff80003ec1:	48 89 c5             	mov    %rax,%rbp
            serial_printf(SERIAL_PORT1, "CPU Exception: %d  ERR %x  CR2 %p\r\n", frame->int_no, frame->err_no, cr2);
ffffffff80003ec4:	31 c0                	xor    %eax,%eax
ffffffff80003ec6:	e8 b5 fa ff ff       	callq  ffffffff80003980 <serial_printf>
            serial_printf(SERIAL_PORT1, _exception_messages[frame->int_no]);
ffffffff80003ecb:	48 8b 43 78          	mov    0x78(%rbx),%rax
ffffffff80003ecf:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003ed4:	48 8b 34 c5 60 5a 00 	mov    -0x7fffa5a0(,%rax,8),%rsi
ffffffff80003edb:	80 
ffffffff80003edc:	31 c0                	xor    %eax,%eax
ffffffff80003ede:	e8 9d fa ff ff       	callq  ffffffff80003980 <serial_printf>
            serial_printf(SERIAL_PORT1, "\n");
ffffffff80003ee3:	31 c0                	xor    %eax,%eax
ffffffff80003ee5:	48 c7 c6 c6 51 00 80 	mov    $0xffffffff800051c6,%rsi
ffffffff80003eec:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003ef1:	e8 8a fa ff ff       	callq  ffffffff80003980 <serial_printf>
            if (frame->int_no == 0xE) 
ffffffff80003ef6:	48 83 7b 78 0e       	cmpq   $0xe,0x78(%rbx)
ffffffff80003efb:	0f 84 de 01 00 00    	je     ffffffff800040df <interrupt_handler+0x2bf>
            serial_printf(SERIAL_PORT1, "SS: %x  RSP: %x  RFLAGS: %x  CS: %x  RIP: %x\n", frame->ss, frame->rsp, frame->rflags, frame->cs, frame->rip);
ffffffff80003f01:	48 8b 8b a0 00 00 00 	mov    0xa0(%rbx),%rcx
ffffffff80003f08:	48 8b 93 a8 00 00 00 	mov    0xa8(%rbx),%rdx
ffffffff80003f0f:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80003f13:	4c 8b 8b 90 00 00 00 	mov    0x90(%rbx),%r9
ffffffff80003f1a:	4c 8b 83 98 00 00 00 	mov    0x98(%rbx),%r8
ffffffff80003f21:	31 c0                	xor    %eax,%eax
ffffffff80003f23:	ff b3 88 00 00 00    	pushq  0x88(%rbx)
ffffffff80003f29:	48 c7 c6 78 59 00 80 	mov    $0xffffffff80005978,%rsi
ffffffff80003f30:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003f35:	e8 46 fa ff ff       	callq  ffffffff80003980 <serial_printf>
            serial_printf(SERIAL_PORT1, "rax: %x  rbx: %x  rcx: %x  rdx: %x  rsi: %x  rdi: %x\n", frame->rax, frame->rbx, frame->rcx, frame->rdx, frame->rsi, frame->rdi);
ffffffff80003f3a:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
ffffffff80003f3e:	48 8b 53 70          	mov    0x70(%rbx),%rdx
ffffffff80003f42:	31 c0                	xor    %eax,%eax
ffffffff80003f44:	4c 8b 4b 58          	mov    0x58(%rbx),%r9
ffffffff80003f48:	4c 8b 43 60          	mov    0x60(%rbx),%r8
ffffffff80003f4c:	48 c7 c6 a8 59 00 80 	mov    $0xffffffff800059a8,%rsi
ffffffff80003f53:	ff 73 48             	pushq  0x48(%rbx)
ffffffff80003f56:	ff 73 50             	pushq  0x50(%rbx)
ffffffff80003f59:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003f5e:	e8 1d fa ff ff       	callq  ffffffff80003980 <serial_printf>
            serial_printf(SERIAL_PORT1, "r8: %x  r9: %x  r10: %x  r11: %x  r12: %x  r13: %x\n", frame->r8, frame->r9, frame->r10, frame->r11, frame->r12, frame->r13);
ffffffff80003f63:	4c 8b 4b 20          	mov    0x20(%rbx),%r9
ffffffff80003f67:	4c 8b 43 28          	mov    0x28(%rbx),%r8
ffffffff80003f6b:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80003f6f:	48 8b 4b 30          	mov    0x30(%rbx),%rcx
ffffffff80003f73:	48 8b 53 38          	mov    0x38(%rbx),%rdx
ffffffff80003f77:	31 c0                	xor    %eax,%eax
ffffffff80003f79:	ff 73 10             	pushq  0x10(%rbx)
ffffffff80003f7c:	ff 73 18             	pushq  0x18(%rbx)
ffffffff80003f7f:	48 c7 c6 e0 59 00 80 	mov    $0xffffffff800059e0,%rsi
ffffffff80003f86:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003f8b:	e8 f0 f9 ff ff       	callq  ffffffff80003980 <serial_printf>
            serial_printf(SERIAL_PORT1, "r14: %x  r15: %x\n", frame->r14, frame->r15);
ffffffff80003f90:	48 8b 53 08          	mov    0x8(%rbx),%rdx
ffffffff80003f94:	48 8b 0b             	mov    (%rbx),%rcx
ffffffff80003f97:	31 c0                	xor    %eax,%eax
ffffffff80003f99:	48 c7 c6 ab 57 00 80 	mov    $0xffffffff800057ab,%rsi
ffffffff80003fa0:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003fa5:	e8 d6 f9 ff ff       	callq  ffffffff80003980 <serial_printf>
            printf("\nCPU Exception! INT %d   ERR %x  CR2 %p\n", frame->int_no, frame->err_no, cr2);
ffffffff80003faa:	48 8b 73 78          	mov    0x78(%rbx),%rsi
ffffffff80003fae:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
ffffffff80003fb5:	48 89 e9             	mov    %rbp,%rcx
ffffffff80003fb8:	48 c7 c7 18 5a 00 80 	mov    $0xffffffff80005a18,%rdi
ffffffff80003fbf:	31 c0                	xor    %eax,%eax
ffffffff80003fc1:	e8 ea f7 ff ff       	callq  ffffffff800037b0 <printf_>
            printf(_exception_messages[frame->int_no]);
ffffffff80003fc6:	48 8b 43 78          	mov    0x78(%rbx),%rax
ffffffff80003fca:	48 8b 3c c5 60 5a 00 	mov    -0x7fffa5a0(,%rax,8),%rdi
ffffffff80003fd1:	80 
ffffffff80003fd2:	31 c0                	xor    %eax,%eax
ffffffff80003fd4:	e8 d7 f7 ff ff       	callq  ffffffff800037b0 <printf_>
            printf("\n");
ffffffff80003fd9:	48 c7 c7 c6 51 00 80 	mov    $0xffffffff800051c6,%rdi
ffffffff80003fe0:	31 c0                	xor    %eax,%eax
ffffffff80003fe2:	e8 c9 f7 ff ff       	callq  ffffffff800037b0 <printf_>
            if (frame->int_no == 0xE) 
ffffffff80003fe7:	48 83 7b 78 0e       	cmpq   $0xe,0x78(%rbx)
ffffffff80003fec:	5e                   	pop    %rsi
ffffffff80003fed:	5f                   	pop    %rdi
ffffffff80003fee:	0f 84 c2 00 00 00    	je     ffffffff800040b6 <interrupt_handler+0x296>
            printf("SS: %x  RSP: %x  RFLAGS: %x  CS: %x  RIP: %x\n", frame->ss, frame->rsp, frame->rflags, frame->cs, frame->rip);
ffffffff80003ff4:	48 8b 8b 98 00 00 00 	mov    0x98(%rbx),%rcx
ffffffff80003ffb:	48 8b 93 a0 00 00 00 	mov    0xa0(%rbx),%rdx
ffffffff80004002:	48 c7 c7 78 59 00 80 	mov    $0xffffffff80005978,%rdi
ffffffff80004009:	48 8b b3 a8 00 00 00 	mov    0xa8(%rbx),%rsi
ffffffff80004010:	4c 8b 8b 88 00 00 00 	mov    0x88(%rbx),%r9
ffffffff80004017:	31 c0                	xor    %eax,%eax
ffffffff80004019:	4c 8b 83 90 00 00 00 	mov    0x90(%rbx),%r8
ffffffff80004020:	e8 8b f7 ff ff       	callq  ffffffff800037b0 <printf_>
            printf("rax: %x  rbx: %x  rcx: %x  rdx: %x  rsi: %x  rdi: %x\n", frame->rax, frame->rbx, frame->rcx, frame->rdx, frame->rsi, frame->rdi);
ffffffff80004025:	48 8b 4b 60          	mov    0x60(%rbx),%rcx
ffffffff80004029:	48 8b 53 68          	mov    0x68(%rbx),%rdx
ffffffff8000402d:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80004031:	48 8b 73 70          	mov    0x70(%rbx),%rsi
ffffffff80004035:	4c 8b 4b 50          	mov    0x50(%rbx),%r9
ffffffff80004039:	48 c7 c7 a8 59 00 80 	mov    $0xffffffff800059a8,%rdi
ffffffff80004040:	4c 8b 43 58          	mov    0x58(%rbx),%r8
ffffffff80004044:	ff 73 48             	pushq  0x48(%rbx)
ffffffff80004047:	31 c0                	xor    %eax,%eax
ffffffff80004049:	e8 62 f7 ff ff       	callq  ffffffff800037b0 <printf_>
            printf("r8: %x  r9: %x  r10: %x  r11: %x  r12: %x  r13: %x\n", frame->r8, frame->r9, frame->r10, frame->r11, frame->r12, frame->r13);
ffffffff8000404e:	58                   	pop    %rax
ffffffff8000404f:	48 8b 4b 28          	mov    0x28(%rbx),%rcx
ffffffff80004053:	48 8b 53 30          	mov    0x30(%rbx),%rdx
ffffffff80004057:	48 c7 c7 e0 59 00 80 	mov    $0xffffffff800059e0,%rdi
ffffffff8000405e:	48 8b 73 38          	mov    0x38(%rbx),%rsi
ffffffff80004062:	4c 8b 4b 18          	mov    0x18(%rbx),%r9
ffffffff80004066:	31 c0                	xor    %eax,%eax
ffffffff80004068:	4c 8b 43 20          	mov    0x20(%rbx),%r8
ffffffff8000406c:	ff 73 10             	pushq  0x10(%rbx)
ffffffff8000406f:	e8 3c f7 ff ff       	callq  ffffffff800037b0 <printf_>
            printf("r14: %x  r15: %x\n", frame->r14, frame->r15);
ffffffff80004074:	48 8b 73 08          	mov    0x8(%rbx),%rsi
ffffffff80004078:	48 8b 13             	mov    (%rbx),%rdx
ffffffff8000407b:	48 c7 c7 ab 57 00 80 	mov    $0xffffffff800057ab,%rdi
ffffffff80004082:	31 c0                	xor    %eax,%eax
ffffffff80004084:	e8 27 f7 ff ff       	callq  ffffffff800037b0 <printf_>
            asm("cli");
ffffffff80004089:	fa                   	cli    
            asm("hlt");
ffffffff8000408a:	f4                   	hlt    
ffffffff8000408b:	5a                   	pop    %rdx
ffffffff8000408c:	59                   	pop    %rcx
ffffffff8000408d:	eb fe                	jmp    ffffffff8000408d <interrupt_handler+0x26d>
ffffffff8000408f:	90                   	nop
                kbd_handle();
ffffffff80004090:	31 c0                	xor    %eax,%eax
ffffffff80004092:	e8 99 e2 ff ff       	callq  ffffffff80002330 <kbd_handle>
                break;
ffffffff80004097:	e9 d6 fd ff ff       	jmpq   ffffffff80003e72 <interrupt_handler+0x52>
ffffffff8000409c:	0f 1f 40 00          	nopl   0x0(%rax)
            printf("INT: %d  IRQ: %d  \n", frame->int_no, irq);
ffffffff800040a0:	48 89 ea             	mov    %rbp,%rdx
ffffffff800040a3:	48 c7 c7 bd 57 00 80 	mov    $0xffffffff800057bd,%rdi
ffffffff800040aa:	31 c0                	xor    %eax,%eax
ffffffff800040ac:	e8 ff f6 ff ff       	callq  ffffffff800037b0 <printf_>
ffffffff800040b1:	e9 bc fd ff ff       	jmpq   ffffffff80003e72 <interrupt_handler+0x52>
                printf(_page_fault_errors[frame->err_no]);
ffffffff800040b6:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
ffffffff800040bd:	48 8b 3c c5 60 5b 00 	mov    -0x7fffa4a0(,%rax,8),%rdi
ffffffff800040c4:	80 
ffffffff800040c5:	31 c0                	xor    %eax,%eax
ffffffff800040c7:	e8 e4 f6 ff ff       	callq  ffffffff800037b0 <printf_>
                printf("\n");
ffffffff800040cc:	48 c7 c7 c6 51 00 80 	mov    $0xffffffff800051c6,%rdi
ffffffff800040d3:	31 c0                	xor    %eax,%eax
ffffffff800040d5:	e8 d6 f6 ff ff       	callq  ffffffff800037b0 <printf_>
ffffffff800040da:	e9 15 ff ff ff       	jmpq   ffffffff80003ff4 <interrupt_handler+0x1d4>
                serial_printf(SERIAL_PORT1, _page_fault_errors[frame->err_no]);
ffffffff800040df:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
ffffffff800040e6:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800040eb:	48 8b 34 c5 60 5b 00 	mov    -0x7fffa4a0(,%rax,8),%rsi
ffffffff800040f2:	80 
ffffffff800040f3:	31 c0                	xor    %eax,%eax
ffffffff800040f5:	e8 86 f8 ff ff       	callq  ffffffff80003980 <serial_printf>
                serial_printf(SERIAL_PORT1, "\n");
ffffffff800040fa:	48 c7 c6 c6 51 00 80 	mov    $0xffffffff800051c6,%rsi
ffffffff80004101:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80004106:	31 c0                	xor    %eax,%eax
ffffffff80004108:	e8 73 f8 ff ff       	callq  ffffffff80003980 <serial_printf>
ffffffff8000410d:	e9 ef fd ff ff       	jmpq   ffffffff80003f01 <interrupt_handler+0xe1>
