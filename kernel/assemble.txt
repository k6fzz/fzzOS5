
./bin/kernel.elf:     file format elf64-x86-64


Disassembly of section .text:

ffffffff80000000 <to_usermode>:
ffffffff80000000:	48 89 f9             	mov    %rdi,%rcx
ffffffff80000003:	48 89 f4             	mov    %rsi,%rsp
ffffffff80000006:	41 bb 02 02 00 00    	mov    $0x202,%r11d
ffffffff8000000c:	0f 07                	sysret 

ffffffff8000000e <enable_sce>:
ffffffff8000000e:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
ffffffff80000013:	0f 32                	rdmsr  
ffffffff80000015:	83 c8 01             	or     $0x1,%eax
ffffffff80000018:	0f 30                	wrmsr  
ffffffff8000001a:	b9 81 00 00 c0       	mov    $0xc0000081,%ecx
ffffffff8000001f:	0f 32                	rdmsr  
ffffffff80000021:	ba 08 00 18 00       	mov    $0x180008,%edx
ffffffff80000026:	0f 30                	wrmsr  
ffffffff80000028:	c3                   	retq   

ffffffff80000029 <enable_sce.end>:
ffffffff80000029:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80000030 <vmm_read_cr3>:
ffffffff80000030:	0f 20 d8             	mov    %cr3,%rax
ffffffff80000033:	c3                   	retq   

ffffffff80000034 <vmm_write_cr3>:
ffffffff80000034:	0f 22 df             	mov    %rdi,%cr3
ffffffff80000037:	c3                   	retq   

ffffffff80000038 <vmm_flush_tlb>:
ffffffff80000038:	0f 01 3f             	invlpg (%rdi)
ffffffff8000003b:	c3                   	retq   

ffffffff8000003c <vmm_flush_tlb.end>:
ffffffff8000003c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000040 <gdt_load>:
ffffffff80000040:	0f 01 17             	lgdt   (%rdi)
ffffffff80000043:	55                   	push   %rbp
ffffffff80000044:	48 89 e5             	mov    %rsp,%rbp
ffffffff80000047:	6a 10                	pushq  $0x10
ffffffff80000049:	55                   	push   %rbp
ffffffff8000004a:	9c                   	pushfq 
ffffffff8000004b:	6a 08                	pushq  $0x8
ffffffff8000004d:	68 54 00 00 80       	pushq  $0xffffffff80000054
ffffffff80000052:	48 cf                	iretq  

ffffffff80000054 <gdt_load.trampoline>:
ffffffff80000054:	5d                   	pop    %rbp
ffffffff80000055:	66 b8 10 00          	mov    $0x10,%ax
ffffffff80000059:	8e d8                	mov    %eax,%ds
ffffffff8000005b:	8e c0                	mov    %eax,%es
ffffffff8000005d:	8e e0                	mov    %eax,%fs
ffffffff8000005f:	8e e8                	mov    %eax,%gs
ffffffff80000061:	8e d0                	mov    %eax,%ss
ffffffff80000063:	66 8b 06             	mov    (%rsi),%ax
ffffffff80000066:	0f 00 d8             	ltr    %ax
ffffffff80000069:	c3                   	retq   

ffffffff8000006a <gdt_load.end>:
ffffffff8000006a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80000070 <read_cr2>:
ffffffff80000070:	0f 20 d0             	mov    %cr2,%rax
ffffffff80000073:	c3                   	retq   

ffffffff80000074 <_interrupt_common>:
ffffffff80000074:	fc                   	cld    
ffffffff80000075:	50                   	push   %rax
ffffffff80000076:	53                   	push   %rbx
ffffffff80000077:	51                   	push   %rcx
ffffffff80000078:	52                   	push   %rdx
ffffffff80000079:	56                   	push   %rsi
ffffffff8000007a:	57                   	push   %rdi
ffffffff8000007b:	55                   	push   %rbp
ffffffff8000007c:	41 50                	push   %r8
ffffffff8000007e:	41 51                	push   %r9
ffffffff80000080:	41 52                	push   %r10
ffffffff80000082:	41 53                	push   %r11
ffffffff80000084:	41 54                	push   %r12
ffffffff80000086:	41 55                	push   %r13
ffffffff80000088:	41 56                	push   %r14
ffffffff8000008a:	41 57                	push   %r15
ffffffff8000008c:	48 89 e7             	mov    %rsp,%rdi
ffffffff8000008f:	e8 cc 36 00 00       	callq  ffffffff80003760 <interrupt_handler>
ffffffff80000094:	48 89 c4             	mov    %rax,%rsp
ffffffff80000097:	41 5f                	pop    %r15
ffffffff80000099:	41 5e                	pop    %r14
ffffffff8000009b:	41 5d                	pop    %r13
ffffffff8000009d:	41 5c                	pop    %r12
ffffffff8000009f:	41 5b                	pop    %r11
ffffffff800000a1:	41 5a                	pop    %r10
ffffffff800000a3:	41 59                	pop    %r9
ffffffff800000a5:	41 58                	pop    %r8
ffffffff800000a7:	5d                   	pop    %rbp
ffffffff800000a8:	5f                   	pop    %rdi
ffffffff800000a9:	5e                   	pop    %rsi
ffffffff800000aa:	5a                   	pop    %rdx
ffffffff800000ab:	59                   	pop    %rcx
ffffffff800000ac:	5b                   	pop    %rbx
ffffffff800000ad:	58                   	pop    %rax
ffffffff800000ae:	48 83 c4 10          	add    $0x10,%rsp
ffffffff800000b2:	48 cf                	iretq  

ffffffff800000b4 <_interrupt0>:
ffffffff800000b4:	6a 00                	pushq  $0x0
ffffffff800000b6:	6a 00                	pushq  $0x0
ffffffff800000b8:	eb ba                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000ba <_interrupt1>:
ffffffff800000ba:	6a 00                	pushq  $0x0
ffffffff800000bc:	6a 01                	pushq  $0x1
ffffffff800000be:	eb b4                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000c0 <_interrupt2>:
ffffffff800000c0:	6a 00                	pushq  $0x0
ffffffff800000c2:	6a 02                	pushq  $0x2
ffffffff800000c4:	eb ae                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000c6 <_interrupt3>:
ffffffff800000c6:	6a 00                	pushq  $0x0
ffffffff800000c8:	6a 03                	pushq  $0x3
ffffffff800000ca:	eb a8                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000cc <_interrupt4>:
ffffffff800000cc:	6a 00                	pushq  $0x0
ffffffff800000ce:	6a 04                	pushq  $0x4
ffffffff800000d0:	eb a2                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000d2 <_interrupt5>:
ffffffff800000d2:	6a 00                	pushq  $0x0
ffffffff800000d4:	6a 05                	pushq  $0x5
ffffffff800000d6:	eb 9c                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000d8 <_interrupt6>:
ffffffff800000d8:	6a 00                	pushq  $0x0
ffffffff800000da:	6a 06                	pushq  $0x6
ffffffff800000dc:	eb 96                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000de <_interrupt7>:
ffffffff800000de:	6a 00                	pushq  $0x0
ffffffff800000e0:	6a 07                	pushq  $0x7
ffffffff800000e2:	eb 90                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000e4 <_interrupt8>:
ffffffff800000e4:	6a 08                	pushq  $0x8
ffffffff800000e6:	eb 8c                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000e8 <_interrupt9>:
ffffffff800000e8:	6a 00                	pushq  $0x0
ffffffff800000ea:	6a 09                	pushq  $0x9
ffffffff800000ec:	eb 86                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000ee <_interrupt10>:
ffffffff800000ee:	6a 0a                	pushq  $0xa
ffffffff800000f0:	eb 82                	jmp    ffffffff80000074 <_interrupt_common>

ffffffff800000f2 <_interrupt11>:
ffffffff800000f2:	6a 0b                	pushq  $0xb
ffffffff800000f4:	e9 7b ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800000f9 <_interrupt12>:
ffffffff800000f9:	6a 0c                	pushq  $0xc
ffffffff800000fb:	e9 74 ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000100 <_interrupt13>:
ffffffff80000100:	6a 0d                	pushq  $0xd
ffffffff80000102:	e9 6d ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000107 <_interrupt14>:
ffffffff80000107:	6a 0e                	pushq  $0xe
ffffffff80000109:	e9 66 ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff8000010e <_interrupt15>:
ffffffff8000010e:	6a 00                	pushq  $0x0
ffffffff80000110:	6a 0f                	pushq  $0xf
ffffffff80000112:	e9 5d ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000117 <_interrupt16>:
ffffffff80000117:	6a 00                	pushq  $0x0
ffffffff80000119:	6a 10                	pushq  $0x10
ffffffff8000011b:	e9 54 ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000120 <_interrupt17>:
ffffffff80000120:	6a 11                	pushq  $0x11
ffffffff80000122:	e9 4d ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000127 <_interrupt18>:
ffffffff80000127:	6a 00                	pushq  $0x0
ffffffff80000129:	6a 12                	pushq  $0x12
ffffffff8000012b:	e9 44 ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000130 <_interrupt19>:
ffffffff80000130:	6a 00                	pushq  $0x0
ffffffff80000132:	6a 13                	pushq  $0x13
ffffffff80000134:	e9 3b ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000139 <_interrupt20>:
ffffffff80000139:	6a 00                	pushq  $0x0
ffffffff8000013b:	6a 14                	pushq  $0x14
ffffffff8000013d:	e9 32 ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000142 <_interrupt21>:
ffffffff80000142:	6a 00                	pushq  $0x0
ffffffff80000144:	6a 15                	pushq  $0x15
ffffffff80000146:	e9 29 ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff8000014b <_interrupt22>:
ffffffff8000014b:	6a 00                	pushq  $0x0
ffffffff8000014d:	6a 16                	pushq  $0x16
ffffffff8000014f:	e9 20 ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000154 <_interrupt23>:
ffffffff80000154:	6a 00                	pushq  $0x0
ffffffff80000156:	6a 17                	pushq  $0x17
ffffffff80000158:	e9 17 ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff8000015d <_interrupt24>:
ffffffff8000015d:	6a 00                	pushq  $0x0
ffffffff8000015f:	6a 18                	pushq  $0x18
ffffffff80000161:	e9 0e ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000166 <_interrupt25>:
ffffffff80000166:	6a 00                	pushq  $0x0
ffffffff80000168:	6a 19                	pushq  $0x19
ffffffff8000016a:	e9 05 ff ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff8000016f <_interrupt26>:
ffffffff8000016f:	6a 00                	pushq  $0x0
ffffffff80000171:	6a 1a                	pushq  $0x1a
ffffffff80000173:	e9 fc fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000178 <_interrupt27>:
ffffffff80000178:	6a 00                	pushq  $0x0
ffffffff8000017a:	6a 1b                	pushq  $0x1b
ffffffff8000017c:	e9 f3 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000181 <_interrupt28>:
ffffffff80000181:	6a 00                	pushq  $0x0
ffffffff80000183:	6a 1c                	pushq  $0x1c
ffffffff80000185:	e9 ea fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff8000018a <_interrupt29>:
ffffffff8000018a:	6a 00                	pushq  $0x0
ffffffff8000018c:	6a 1d                	pushq  $0x1d
ffffffff8000018e:	e9 e1 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000193 <_interrupt30>:
ffffffff80000193:	6a 1e                	pushq  $0x1e
ffffffff80000195:	e9 da fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff8000019a <_interrupt31>:
ffffffff8000019a:	6a 00                	pushq  $0x0
ffffffff8000019c:	6a 1f                	pushq  $0x1f
ffffffff8000019e:	e9 d1 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001a3 <_interrupt32>:
ffffffff800001a3:	6a 00                	pushq  $0x0
ffffffff800001a5:	6a 20                	pushq  $0x20
ffffffff800001a7:	e9 c8 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001ac <_interrupt33>:
ffffffff800001ac:	6a 00                	pushq  $0x0
ffffffff800001ae:	6a 21                	pushq  $0x21
ffffffff800001b0:	e9 bf fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001b5 <_interrupt34>:
ffffffff800001b5:	6a 00                	pushq  $0x0
ffffffff800001b7:	6a 22                	pushq  $0x22
ffffffff800001b9:	e9 b6 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001be <_interrupt35>:
ffffffff800001be:	6a 00                	pushq  $0x0
ffffffff800001c0:	6a 23                	pushq  $0x23
ffffffff800001c2:	e9 ad fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001c7 <_interrupt36>:
ffffffff800001c7:	6a 00                	pushq  $0x0
ffffffff800001c9:	6a 24                	pushq  $0x24
ffffffff800001cb:	e9 a4 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001d0 <_interrupt37>:
ffffffff800001d0:	6a 00                	pushq  $0x0
ffffffff800001d2:	6a 25                	pushq  $0x25
ffffffff800001d4:	e9 9b fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001d9 <_interrupt38>:
ffffffff800001d9:	6a 00                	pushq  $0x0
ffffffff800001db:	6a 26                	pushq  $0x26
ffffffff800001dd:	e9 92 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001e2 <_interrupt39>:
ffffffff800001e2:	6a 00                	pushq  $0x0
ffffffff800001e4:	6a 27                	pushq  $0x27
ffffffff800001e6:	e9 89 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001eb <_interrupt40>:
ffffffff800001eb:	6a 00                	pushq  $0x0
ffffffff800001ed:	6a 28                	pushq  $0x28
ffffffff800001ef:	e9 80 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001f4 <_interrupt41>:
ffffffff800001f4:	6a 00                	pushq  $0x0
ffffffff800001f6:	6a 29                	pushq  $0x29
ffffffff800001f8:	e9 77 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff800001fd <_interrupt42>:
ffffffff800001fd:	6a 00                	pushq  $0x0
ffffffff800001ff:	6a 2a                	pushq  $0x2a
ffffffff80000201:	e9 6e fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000206 <_interrupt43>:
ffffffff80000206:	6a 00                	pushq  $0x0
ffffffff80000208:	6a 2b                	pushq  $0x2b
ffffffff8000020a:	e9 65 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff8000020f <_interrupt44>:
ffffffff8000020f:	6a 00                	pushq  $0x0
ffffffff80000211:	6a 2c                	pushq  $0x2c
ffffffff80000213:	e9 5c fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000218 <_interrupt45>:
ffffffff80000218:	6a 00                	pushq  $0x0
ffffffff8000021a:	6a 2d                	pushq  $0x2d
ffffffff8000021c:	e9 53 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000221 <_interrupt46>:
ffffffff80000221:	6a 00                	pushq  $0x0
ffffffff80000223:	6a 2e                	pushq  $0x2e
ffffffff80000225:	e9 4a fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff8000022a <_interrupt47>:
ffffffff8000022a:	6a 00                	pushq  $0x0
ffffffff8000022c:	6a 2f                	pushq  $0x2f
ffffffff8000022e:	e9 41 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000233 <_interrupt127>:
ffffffff80000233:	6a 00                	pushq  $0x0
ffffffff80000235:	6a 7f                	pushq  $0x7f
ffffffff80000237:	e9 38 fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff8000023c <_interrupt128>:
ffffffff8000023c:	6a 00                	pushq  $0x0
ffffffff8000023e:	68 80 00 00 00       	pushq  $0x80
ffffffff80000243:	e9 2c fe ff ff       	jmpq   ffffffff80000074 <_interrupt_common>

ffffffff80000248 <isr_stub_table>:
ffffffff80000248:	b4 00 00 80 ff ff ff ff ba 00 00 80 ff ff ff ff     ................
ffffffff80000258:	c0 00 00 80 ff ff ff ff c6 00 00 80 ff ff ff ff     ................
ffffffff80000268:	cc 00 00 80 ff ff ff ff d2 00 00 80 ff ff ff ff     ................
ffffffff80000278:	d8 00 00 80 ff ff ff ff de 00 00 80 ff ff ff ff     ................
ffffffff80000288:	e4 00 00 80 ff ff ff ff e8 00 00 80 ff ff ff ff     ................
ffffffff80000298:	ee 00 00 80 ff ff ff ff f2 00 00 80 ff ff ff ff     ................
ffffffff800002a8:	f9 00 00 80 ff ff ff ff 00 01 00 80 ff ff ff ff     ................
ffffffff800002b8:	07 01 00 80 ff ff ff ff 0e 01 00 80 ff ff ff ff     ................
ffffffff800002c8:	17 01 00 80 ff ff ff ff 20 01 00 80 ff ff ff ff     ........ .......
ffffffff800002d8:	27 01 00 80 ff ff ff ff 30 01 00 80 ff ff ff ff     '.......0.......
ffffffff800002e8:	39 01 00 80 ff ff ff ff 42 01 00 80 ff ff ff ff     9.......B.......
ffffffff800002f8:	4b 01 00 80 ff ff ff ff 54 01 00 80 ff ff ff ff     K.......T.......
ffffffff80000308:	5d 01 00 80 ff ff ff ff 66 01 00 80 ff ff ff ff     ].......f.......
ffffffff80000318:	6f 01 00 80 ff ff ff ff 78 01 00 80 ff ff ff ff     o.......x.......
ffffffff80000328:	81 01 00 80 ff ff ff ff 8a 01 00 80 ff ff ff ff     ................
ffffffff80000338:	93 01 00 80 ff ff ff ff 9a 01 00 80 ff ff ff ff     ................
ffffffff80000348:	a3 01 00 80 ff ff ff ff ac 01 00 80 ff ff ff ff     ................
ffffffff80000358:	b5 01 00 80 ff ff ff ff be 01 00 80 ff ff ff ff     ................
ffffffff80000368:	c7 01 00 80 ff ff ff ff d0 01 00 80 ff ff ff ff     ................
ffffffff80000378:	d9 01 00 80 ff ff ff ff e2 01 00 80 ff ff ff ff     ................
ffffffff80000388:	eb 01 00 80 ff ff ff ff f4 01 00 80 ff ff ff ff     ................
ffffffff80000398:	fd 01 00 80 ff ff ff ff 06 02 00 80 ff ff ff ff     ................
ffffffff800003a8:	0f 02 00 80 ff ff ff ff 18 02 00 80 ff ff ff ff     ................
ffffffff800003b8:	21 02 00 80 ff ff ff ff 2a 02 00 80 ff ff ff ff     !.......*.......
ffffffff800003c8:	33 02 00 80 ff ff ff ff 3c 02 00 80 ff ff ff ff     3.......<.......

ffffffff800003d8 <idt_load>:
ffffffff800003d8:	0f 01 1f             	lidt   (%rdi)
ffffffff800003db:	fb                   	sti    
ffffffff800003dc:	c3                   	retq   

ffffffff800003dd <int_test>:
ffffffff800003dd:	cd 7f                	int    $0x7f
ffffffff800003df:	c3                   	retq   

ffffffff800003e0 <user_init>:
extern void enable_sce();

void user_init()
{

}
ffffffff800003e0:	f3 c3                	repz retq 
ffffffff800003e2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800003e9:	00 00 00 00 
ffffffff800003ed:	0f 1f 00             	nopl   (%rax)

ffffffff800003f0 <user_enter>:


void user_enter(void* func, uint8_t* stack)
{

ffffffff800003f0:	f3 c3                	repz retq 
ffffffff800003f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800003f9:	00 00 00 
ffffffff800003fc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000400 <outb>:
#include <stdint.h>
#include <stddef.h>

void outb(uint16_t port, uint8_t val)
{
    asm volatile ( "outb %0, %1" : : "a"(val), "Nd"(port) );
ffffffff80000400:	89 f0                	mov    %esi,%eax
ffffffff80000402:	89 fa                	mov    %edi,%edx
ffffffff80000404:	ee                   	out    %al,(%dx)
}
ffffffff80000405:	c3                   	retq   
ffffffff80000406:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000040d:	00 00 00 

ffffffff80000410 <inb>:

uint8_t inb(uint16_t port)
{
    uint8_t ret;
    asm volatile ( "inb %1, %0"
ffffffff80000410:	89 fa                	mov    %edi,%edx
ffffffff80000412:	ec                   	in     (%dx),%al
                   : "=a"(ret)
                   : "Nd"(port) );
    return ret;
}
ffffffff80000413:	c3                   	retq   
ffffffff80000414:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000041b:	00 00 00 00 
ffffffff8000041f:	90                   	nop

ffffffff80000420 <io_wait>:
    asm volatile ( "inb %1, %0"
ffffffff80000420:	e4 80                	in     $0x80,%al

void io_wait()
{
    inb(0x80);
ffffffff80000422:	c3                   	retq   
ffffffff80000423:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000042a:	00 00 00 
ffffffff8000042d:	0f 1f 00             	nopl   (%rax)

ffffffff80000430 <schedule>:
ffffffff80000430:	f3 c3                	repz retq 
ffffffff80000432:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000439:	00 00 00 00 
ffffffff8000043d:	0f 1f 00             	nopl   (%rax)

ffffffff80000440 <scheduler_init>:
}

void scheduler_init()
{

ffffffff80000440:	f3 c3                	repz retq 
ffffffff80000442:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80000449:	00 00 00 
ffffffff8000044c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000450 <_start>:



    // Let's get the terminal structure tag from the bootloader.
    struct stivale2_struct_tag_terminal *term_str_tag;
    term_str_tag = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_TERMINAL_ID);
ffffffff80000450:	48 8b 87 80 00 00 00 	mov    0x80(%rdi),%rax
        if (current_tag == NULL) {
ffffffff80000457:	48 85 c0             	test   %rax,%rax
ffffffff8000045a:	74 2c                	je     ffffffff80000488 <_start+0x38>
        if (current_tag->identifier == id) {
ffffffff8000045c:	48 8b 10             	mov    (%rax),%rdx
ffffffff8000045f:	48 be 74 09 3b 23 c3 	movabs $0xc2b3f4c3233b0974,%rsi
ffffffff80000466:	f4 b3 c2 
ffffffff80000469:	48 39 f2             	cmp    %rsi,%rdx
ffffffff8000046c:	0f 84 71 01 00 00    	je     ffffffff800005e3 <_start+0x193>
ffffffff80000472:	48 89 c1             	mov    %rax,%rcx
ffffffff80000475:	eb 05                	jmp    ffffffff8000047c <_start+0x2c>
ffffffff80000477:	48 39 31             	cmp    %rsi,(%rcx)
ffffffff8000047a:	74 0f                	je     ffffffff8000048b <_start+0x3b>
        current_tag = (void *)current_tag->next;
ffffffff8000047c:	48 8b 49 08          	mov    0x8(%rcx),%rcx
        if (current_tag == NULL) {
ffffffff80000480:	48 85 c9             	test   %rcx,%rcx
ffffffff80000483:	75 f2                	jne    ffffffff80000477 <_start+0x27>
ffffffff80000485:	0f 1f 00             	nopl   (%rax)

    // Check if the tag was actually found.
    if (term_str_tag == NULL) {
        // It wasn't found, just hang...
        for (;;) {
            asm ("hlt");
ffffffff80000488:	f4                   	hlt    
ffffffff80000489:	eb fd                	jmp    ffffffff80000488 <_start+0x38>
        }
    }

    void* term_write_ptr = (void *)term_str_tag->term_write;
    term_write = term_write_ptr;
ffffffff8000048b:	48 8b 49 18          	mov    0x18(%rcx),%rcx
ffffffff8000048f:	48 89 0d 0a 9e 00 00 	mov    %rcx,0x9e0a(%rip)        # ffffffff8000a2a0 <term_write>
        if (current_tag->identifier == id) {
ffffffff80000496:	48 b9 fa 08 04 95 d2 	movabs $0x506461d2950408fa,%rcx
ffffffff8000049d:	61 64 50 
ffffffff800004a0:	48 39 ca             	cmp    %rcx,%rdx
ffffffff800004a3:	0f 84 6b 01 00 00    	je     ffffffff80000614 <_start+0x1c4>
ffffffff800004a9:	48 89 c1             	mov    %rax,%rcx
ffffffff800004ac:	48 be fa 08 04 95 d2 	movabs $0x506461d2950408fa,%rsi
ffffffff800004b3:	61 64 50 
ffffffff800004b6:	eb 05                	jmp    ffffffff800004bd <_start+0x6d>
ffffffff800004b8:	48 39 31             	cmp    %rsi,(%rcx)
ffffffff800004bb:	74 1e                	je     ffffffff800004db <_start+0x8b>
        current_tag = (void *)current_tag->next;
ffffffff800004bd:	48 8b 49 08          	mov    0x8(%rcx),%rcx
        if (current_tag == NULL) {
ffffffff800004c1:	48 85 c9             	test   %rcx,%rcx
ffffffff800004c4:	75 f2                	jne    ffffffff800004b8 <_start+0x68>
    //printf("Terminal Initialized\n");

    //Grab the Framebuffer
    boot_info.tag_framebuffer = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_FRAMEBUFFER_ID);
ffffffff800004c6:	48 c7 05 a7 9d 00 00 	movq   $0x0,0x9da7(%rip)        # ffffffff8000a278 <boot_info+0x18>
ffffffff800004cd:	00 00 00 00 
ffffffff800004d1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if (boot_info.tag_framebuffer == NULL)
    {
    //    printf("Framebuffer Not Found\n");
        for( ;; ) 
            asm("hlt");
ffffffff800004d8:	f4                   	hlt    
ffffffff800004d9:	eb fd                	jmp    ffffffff800004d8 <_start+0x88>
    boot_info.tag_framebuffer = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_FRAMEBUFFER_ID);
ffffffff800004db:	48 89 0d 96 9d 00 00 	mov    %rcx,0x9d96(%rip)        # ffffffff8000a278 <boot_info+0x18>
        if (current_tag->identifier == id) {
ffffffff800004e2:	48 b9 07 de 12 86 9e 	movabs $0x2187f79e8612de07,%rcx
ffffffff800004e9:	f7 87 21 
ffffffff800004ec:	48 39 ca             	cmp    %rcx,%rdx
ffffffff800004ef:	0f 84 13 01 00 00    	je     ffffffff80000608 <_start+0x1b8>
ffffffff800004f5:	48 89 c1             	mov    %rax,%rcx
ffffffff800004f8:	48 be 07 de 12 86 9e 	movabs $0x2187f79e8612de07,%rsi
ffffffff800004ff:	f7 87 21 
        current_tag = (void *)current_tag->next;
ffffffff80000502:	48 8b 49 08          	mov    0x8(%rcx),%rcx
        if (current_tag == NULL) {
ffffffff80000506:	48 85 c9             	test   %rcx,%rcx
ffffffff80000509:	0f 84 bc 00 00 00    	je     ffffffff800005cb <_start+0x17b>
        if (current_tag->identifier == id) {
ffffffff8000050f:	48 39 31             	cmp    %rsi,(%rcx)
ffffffff80000512:	75 ee                	jne    ffffffff80000502 <_start+0xb2>
    }
    //printf("Framebuffer found at %x\n", boot_info.tag_framebuffer->framebuffer_addr);

    //Memory Map
    boot_info.tag_memmap = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MEMMAP_ID);
ffffffff80000514:	48 89 0d 55 9d 00 00 	mov    %rcx,0x9d55(%rip)        # ffffffff8000a270 <boot_info+0x10>
        if (current_tag->identifier == id) {
ffffffff8000051b:	48 b9 f0 8a 2a 4a 87 	movabs $0x60d78874a2a8af0,%rcx
ffffffff80000522:	78 0d 06 
ffffffff80000525:	48 39 ca             	cmp    %rcx,%rdx
ffffffff80000528:	0f 84 ce 00 00 00    	je     ffffffff800005fc <_start+0x1ac>
ffffffff8000052e:	48 89 c1             	mov    %rax,%rcx
ffffffff80000531:	48 be f0 8a 2a 4a 87 	movabs $0x60d78874a2a8af0,%rsi
ffffffff80000538:	78 0d 06 
ffffffff8000053b:	eb 05                	jmp    ffffffff80000542 <_start+0xf2>
ffffffff8000053d:	48 39 31             	cmp    %rsi,(%rcx)
ffffffff80000540:	74 09                	je     ffffffff8000054b <_start+0xfb>
        current_tag = (void *)current_tag->next;
ffffffff80000542:	48 8b 49 08          	mov    0x8(%rcx),%rcx
        if (current_tag == NULL) {
ffffffff80000546:	48 85 c9             	test   %rcx,%rcx
ffffffff80000549:	75 f2                	jne    ffffffff8000053d <_start+0xed>
            asm("hlt");
    }
    //printf("Memory Map at %x\n", boot_info.tag_memmap);

    //Kernel Base Address
    boot_info.tag_kernel_base_address = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_KERNEL_BASE_ADDRESS_ID);
ffffffff8000054b:	48 89 0d 0e 9d 00 00 	mov    %rcx,0x9d0e(%rip)        # ffffffff8000a260 <boot_info>
        if (current_tag->identifier == id) {
ffffffff80000552:	48 b9 78 5e 37 0a 93 	movabs $0x9e1786930a375e78,%rcx
ffffffff80000559:	86 17 9e 
ffffffff8000055c:	48 39 ca             	cmp    %rcx,%rdx
ffffffff8000055f:	0f 84 8e 00 00 00    	je     ffffffff800005f3 <_start+0x1a3>
            return NULL;
ffffffff80000565:	48 89 c1             	mov    %rax,%rcx
        if (current_tag->identifier == id) {
ffffffff80000568:	48 be 78 5e 37 0a 93 	movabs $0x9e1786930a375e78,%rsi
ffffffff8000056f:	86 17 9e 
ffffffff80000572:	eb 05                	jmp    ffffffff80000579 <_start+0x129>
ffffffff80000574:	48 39 31             	cmp    %rsi,(%rcx)
ffffffff80000577:	74 09                	je     ffffffff80000582 <_start+0x132>
        current_tag = (void *)current_tag->next;
ffffffff80000579:	48 8b 49 08          	mov    0x8(%rcx),%rcx
        if (current_tag == NULL) {
ffffffff8000057d:	48 85 c9             	test   %rcx,%rcx
ffffffff80000580:	75 f2                	jne    ffffffff80000574 <_start+0x124>
    }
    //printf("Kernel Physical Base Address %x\n", boot_info.tag_kernel_base_address->physical_base_address);
    //printf("Kernel Virtual Base Address  %x\n", boot_info.tag_kernel_base_address->virtual_base_address);
    //printf("--------\n");

    boot_info.tag_rsdp = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_RSDP_ID);
ffffffff80000582:	48 89 0d ff 9c 00 00 	mov    %rcx,0x9cff(%rip)        # ffffffff8000a288 <boot_info+0x28>
        if (current_tag->identifier == id) {
ffffffff80000589:	48 b9 8f b5 8c b1 7d 	movabs $0xb0ed257db18cb58f,%rcx
ffffffff80000590:	25 ed b0 
ffffffff80000593:	48 39 ca             	cmp    %rcx,%rdx
ffffffff80000596:	74 1a                	je     ffffffff800005b2 <_start+0x162>
ffffffff80000598:	48 ba 8f b5 8c b1 7d 	movabs $0xb0ed257db18cb58f,%rdx
ffffffff8000059f:	25 ed b0 
ffffffff800005a2:	eb 05                	jmp    ffffffff800005a9 <_start+0x159>
ffffffff800005a4:	48 39 10             	cmp    %rdx,(%rax)
ffffffff800005a7:	74 09                	je     ffffffff800005b2 <_start+0x162>
        current_tag = (void *)current_tag->next;
ffffffff800005a9:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (current_tag == NULL) {
ffffffff800005ad:	48 85 c0             	test   %rax,%rax
ffffffff800005b0:	75 f2                	jne    ffffffff800005a4 <_start+0x154>
{
ffffffff800005b2:	52                   	push   %rdx
    
    boot_info.tag_hhdm = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_HHDM_ID);
ffffffff800005b3:	48 89 05 de 9c 00 00 	mov    %rax,0x9cde(%rip)        # ffffffff8000a298 <boot_info+0x38>

    kernel();
ffffffff800005ba:	31 c0                	xor    %eax,%eax
ffffffff800005bc:	e8 af 2f 00 00       	callq  ffffffff80003570 <kernel>
ffffffff800005c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)


    // We should never get here, but just in case...
    for (;;) {
        asm ("hlt");
ffffffff800005c8:	f4                   	hlt    
ffffffff800005c9:	eb fd                	jmp    ffffffff800005c8 <_start+0x178>
    boot_info.tag_memmap = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MEMMAP_ID);
ffffffff800005cb:	48 c7 05 9a 9c 00 00 	movq   $0x0,0x9c9a(%rip)        # ffffffff8000a270 <boot_info+0x10>
ffffffff800005d2:	00 00 00 00 
ffffffff800005d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800005dd:	00 00 00 
            asm("hlt");
ffffffff800005e0:	f4                   	hlt    
ffffffff800005e1:	eb fd                	jmp    ffffffff800005e0 <_start+0x190>
    term_write = term_write_ptr;
ffffffff800005e3:	48 8b 48 18          	mov    0x18(%rax),%rcx
ffffffff800005e7:	48 89 0d b2 9c 00 00 	mov    %rcx,0x9cb2(%rip)        # ffffffff8000a2a0 <term_write>
ffffffff800005ee:	e9 b6 fe ff ff       	jmpq   ffffffff800004a9 <_start+0x59>
    boot_info.tag_rsdp = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_RSDP_ID);
ffffffff800005f3:	48 89 05 8e 9c 00 00 	mov    %rax,0x9c8e(%rip)        # ffffffff8000a288 <boot_info+0x28>
ffffffff800005fa:	eb 9c                	jmp    ffffffff80000598 <_start+0x148>
    boot_info.tag_kernel_base_address = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_KERNEL_BASE_ADDRESS_ID);
ffffffff800005fc:	48 89 05 5d 9c 00 00 	mov    %rax,0x9c5d(%rip)        # ffffffff8000a260 <boot_info>
ffffffff80000603:	e9 5d ff ff ff       	jmpq   ffffffff80000565 <_start+0x115>
    boot_info.tag_memmap = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_MEMMAP_ID);
ffffffff80000608:	48 89 05 61 9c 00 00 	mov    %rax,0x9c61(%rip)        # ffffffff8000a270 <boot_info+0x10>
ffffffff8000060f:	e9 1a ff ff ff       	jmpq   ffffffff8000052e <_start+0xde>
    boot_info.tag_framebuffer = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_FRAMEBUFFER_ID);
ffffffff80000614:	48 89 05 5d 9c 00 00 	mov    %rax,0x9c5d(%rip)        # ffffffff8000a278 <boot_info+0x18>
ffffffff8000061b:	e9 d5 fe ff ff       	jmpq   ffffffff800004f5 <_start+0xa5>

ffffffff80000620 <vmm_create_page_table>:
struct PageTable* kernel_cr3 = {0};

uint64_t magic = 0xdeadbeef;

struct PageTable* vmm_create_page_table()
{
ffffffff80000620:	53                   	push   %rbx
    void* page = pmm_allocpage();   //get a page
ffffffff80000621:	31 c0                	xor    %eax,%eax
ffffffff80000623:	e8 18 0e 00 00       	callq  ffffffff80001440 <pmm_allocpage>
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff80000628:	48 85 c0             	test   %rax,%rax
    void* page = pmm_allocpage();   //get a page
ffffffff8000062b:	48 89 c3             	mov    %rax,%rbx
    if(page == NULL) return NULL;   //If it's null, we can't continue
ffffffff8000062e:	74 0f                	je     ffffffff8000063f <vmm_create_page_table+0x1f>

    memset((uint8_t*)page, 0, 4096);    //clear the page
ffffffff80000630:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff80000635:	31 f6                	xor    %esi,%esi
ffffffff80000637:	48 89 c7             	mov    %rax,%rdi
ffffffff8000063a:	e8 d1 2e 00 00       	callq  ffffffff80003510 <memset>
    return (struct PageTable*)page;
    
    //return (struct PageTable*)phys_to_hh_data((uint64_t)page);
}
ffffffff8000063f:	48 89 d8             	mov    %rbx,%rax
ffffffff80000642:	5b                   	pop    %rbx
ffffffff80000643:	c3                   	retq   
ffffffff80000644:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000064b:	00 00 00 00 
ffffffff8000064f:	90                   	nop

ffffffff80000650 <vmm_map_2Mpage>:
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
    }
}

void vmm_map_2Mpage(struct PageTable* pagetable, uint64_t virtual, uint64_t physical, uint64_t flags)
{
ffffffff80000650:	41 56                	push   %r14
    uint64_t index2, index3, index4;
    vaddr >>= 12;
    //index1 = vaddr & 0x1ff;
    vaddr >>= 9;
    index2 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff80000652:	49 89 f6             	mov    %rsi,%r14
{
ffffffff80000655:	41 55                	push   %r13
ffffffff80000657:	41 54                	push   %r12
ffffffff80000659:	55                   	push   %rbp
    vaddr >>= 9;
ffffffff8000065a:	48 89 f5             	mov    %rsi,%rbp
    index3 = vaddr & 0x1ff;
    vaddr >>= 9;
    index4 = vaddr & 0x1ff;
ffffffff8000065d:	48 c1 ee 24          	shr    $0x24,%rsi
{
ffffffff80000661:	53                   	push   %rbx
    vaddr >>= 9;
ffffffff80000662:	48 c1 ed 15          	shr    $0x15,%rbp
ffffffff80000666:	81 e6 f8 0f 00 00    	and    $0xff8,%esi
    vaddr >>= 9;
ffffffff8000066c:	49 c1 ee 1e          	shr    $0x1e,%r14
    index2 = vaddr & 0x1ff;
ffffffff80000670:	81 e5 ff 01 00 00    	and    $0x1ff,%ebp
ffffffff80000676:	4c 8d 2c 37          	lea    (%rdi,%rsi,1),%r13
    index3 = vaddr & 0x1ff;
ffffffff8000067a:	41 81 e6 ff 01 00 00 	and    $0x1ff,%r14d
{
ffffffff80000681:	48 89 d3             	mov    %rdx,%rbx
ffffffff80000684:	49 89 cc             	mov    %rcx,%r12
    if(pagemap->entry[index] & 1)
ffffffff80000687:	49 8b 45 00          	mov    0x0(%r13),%rax
ffffffff8000068b:	a8 01                	test   $0x1,%al
ffffffff8000068d:	74 41                	je     ffffffff800006d0 <vmm_map_2Mpage+0x80>
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff8000068f:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
ffffffff80000695:	4e 8d 2c f0          	lea    (%rax,%r14,8),%r13
    if(pagemap->entry[index] & 1)
ffffffff80000699:	49 8b 45 00          	mov    0x0(%r13),%rax
ffffffff8000069d:	a8 01                	test   $0x1,%al
ffffffff8000069f:	75 0e                	jne    ffffffff800006af <vmm_map_2Mpage+0x5f>
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff800006a1:	31 c0                	xor    %eax,%eax
ffffffff800006a3:	e8 78 ff ff ff       	callq  ffffffff80000620 <vmm_create_page_table>
        pagemap->entry[index] = newentry | flags;
ffffffff800006a8:	4c 09 e0             	or     %r12,%rax
ffffffff800006ab:	49 89 45 00          	mov    %rax,0x0(%r13)

    PML4 = pagetable;
    PML3 = vmm_get_pagemap(PML4, index4, flags);
    PML2 = vmm_get_pagemap(PML3, index3, flags);

    PML2->entry[index2] = physical | flags | PTE_PAGESIZE;
ffffffff800006af:	80 cb 80             	or     $0x80,%bl
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff800006b2:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
    PML2->entry[index2] = physical | flags | PTE_PAGESIZE;
ffffffff800006b8:	48 89 d9             	mov    %rbx,%rcx
ffffffff800006bb:	4c 09 e1             	or     %r12,%rcx
ffffffff800006be:	48 89 0c e8          	mov    %rcx,(%rax,%rbp,8)
}
ffffffff800006c2:	5b                   	pop    %rbx
ffffffff800006c3:	5d                   	pop    %rbp
ffffffff800006c4:	41 5c                	pop    %r12
ffffffff800006c6:	41 5d                	pop    %r13
ffffffff800006c8:	41 5e                	pop    %r14
ffffffff800006ca:	c3                   	retq   
ffffffff800006cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff800006d0:	31 c0                	xor    %eax,%eax
ffffffff800006d2:	e8 49 ff ff ff       	callq  ffffffff80000620 <vmm_create_page_table>
        pagemap->entry[index] = newentry | flags;
ffffffff800006d7:	4c 09 e0             	or     %r12,%rax
ffffffff800006da:	49 89 45 00          	mov    %rax,0x0(%r13)
ffffffff800006de:	eb af                	jmp    ffffffff8000068f <vmm_map_2Mpage+0x3f>

ffffffff800006e0 <vmm_map_page>:

void vmm_map_page(struct PageTable* pagetable, uint64_t virtual, uint64_t physical, uint64_t flags)
{
ffffffff800006e0:	41 57                	push   %r15
    uint64_t index1, index2, index3, index4;
    vaddr >>= 12;
    index1 = vaddr & 0x1ff;
    vaddr >>= 9;
    index2 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff800006e2:	49 89 f7             	mov    %rsi,%r15
{
ffffffff800006e5:	41 56                	push   %r14
ffffffff800006e7:	41 55                	push   %r13
    vaddr >>= 9;
ffffffff800006e9:	49 89 f5             	mov    %rsi,%r13
{
ffffffff800006ec:	41 54                	push   %r12
ffffffff800006ee:	55                   	push   %rbp
ffffffff800006ef:	53                   	push   %rbx
    vaddr >>= 12;
ffffffff800006f0:	48 89 f3             	mov    %rsi,%rbx
    index3 = vaddr & 0x1ff;
    vaddr >>= 9;
    index4 = vaddr & 0x1ff;
ffffffff800006f3:	48 c1 ee 24          	shr    $0x24,%rsi
    vaddr >>= 12;
ffffffff800006f7:	48 c1 eb 0c          	shr    $0xc,%rbx
    vaddr >>= 9;
ffffffff800006fb:	49 c1 ed 15          	shr    $0x15,%r13
ffffffff800006ff:	81 e6 f8 0f 00 00    	and    $0xff8,%esi
{
ffffffff80000705:	48 83 ec 08          	sub    $0x8,%rsp
    vaddr >>= 9;
ffffffff80000709:	49 c1 ef 1e          	shr    $0x1e,%r15
ffffffff8000070d:	4c 8d 34 37          	lea    (%rdi,%rsi,1),%r14
    index1 = vaddr & 0x1ff;
ffffffff80000711:	81 e3 ff 01 00 00    	and    $0x1ff,%ebx
    index2 = vaddr & 0x1ff;
ffffffff80000717:	41 81 e5 ff 01 00 00 	and    $0x1ff,%r13d
    index3 = vaddr & 0x1ff;
ffffffff8000071e:	41 81 e7 ff 01 00 00 	and    $0x1ff,%r15d
{
ffffffff80000725:	48 89 d5             	mov    %rdx,%rbp
ffffffff80000728:	49 89 cc             	mov    %rcx,%r12
    if(pagemap->entry[index] & 1)
ffffffff8000072b:	49 8b 06             	mov    (%r14),%rax
ffffffff8000072e:	a8 01                	test   $0x1,%al
ffffffff80000730:	74 5e                	je     ffffffff80000790 <vmm_map_page+0xb0>
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff80000732:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
ffffffff80000738:	4e 8d 34 f8          	lea    (%rax,%r15,8),%r14
    if(pagemap->entry[index] & 1)
ffffffff8000073c:	49 8b 06             	mov    (%r14),%rax
ffffffff8000073f:	a8 01                	test   $0x1,%al
ffffffff80000741:	74 3d                	je     ffffffff80000780 <vmm_map_page+0xa0>
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff80000743:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
ffffffff80000749:	4e 8d 2c e8          	lea    (%rax,%r13,8),%r13
    if(pagemap->entry[index] & 1)
ffffffff8000074d:	49 8b 45 00          	mov    0x0(%r13),%rax
ffffffff80000751:	a8 01                	test   $0x1,%al
ffffffff80000753:	75 0e                	jne    ffffffff80000763 <vmm_map_page+0x83>
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff80000755:	31 c0                	xor    %eax,%eax
ffffffff80000757:	e8 c4 fe ff ff       	callq  ffffffff80000620 <vmm_create_page_table>
        pagemap->entry[index] = newentry | flags;
ffffffff8000075c:	4c 09 e0             	or     %r12,%rax
ffffffff8000075f:	49 89 45 00          	mov    %rax,0x0(%r13)
    PML4 = pagetable;
    PML3 = vmm_get_pagemap(PML4, index4, flags);
    PML2 = vmm_get_pagemap(PML3, index3, flags);
    PML1 = vmm_get_pagemap(PML2, index2, flags);

    PML1->entry[index1] = physical | flags;
ffffffff80000763:	4c 09 e5             	or     %r12,%rbp
        return (struct PageTable*)(pagemap->entry[index] & (~0x1ff));
ffffffff80000766:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
    PML1->entry[index1] = physical | flags;
ffffffff8000076c:	48 89 2c d8          	mov    %rbp,(%rax,%rbx,8)

    //vmm_flush_tlb((void*)virtual);

}
ffffffff80000770:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80000774:	5b                   	pop    %rbx
ffffffff80000775:	5d                   	pop    %rbp
ffffffff80000776:	41 5c                	pop    %r12
ffffffff80000778:	41 5d                	pop    %r13
ffffffff8000077a:	41 5e                	pop    %r14
ffffffff8000077c:	41 5f                	pop    %r15
ffffffff8000077e:	c3                   	retq   
ffffffff8000077f:	90                   	nop
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff80000780:	31 c0                	xor    %eax,%eax
ffffffff80000782:	e8 99 fe ff ff       	callq  ffffffff80000620 <vmm_create_page_table>
        pagemap->entry[index] = newentry | flags;
ffffffff80000787:	4c 09 e0             	or     %r12,%rax
ffffffff8000078a:	49 89 06             	mov    %rax,(%r14)
ffffffff8000078d:	eb b4                	jmp    ffffffff80000743 <vmm_map_page+0x63>
ffffffff8000078f:	90                   	nop
        uint64_t newentry = (uint64_t)vmm_create_page_table();
ffffffff80000790:	31 c0                	xor    %eax,%eax
ffffffff80000792:	e8 89 fe ff ff       	callq  ffffffff80000620 <vmm_create_page_table>
        pagemap->entry[index] = newentry | flags;
ffffffff80000797:	4c 09 e0             	or     %r12,%rax
ffffffff8000079a:	49 89 06             	mov    %rax,(%r14)
ffffffff8000079d:	eb 93                	jmp    ffffffff80000732 <vmm_map_page+0x52>
ffffffff8000079f:	90                   	nop

ffffffff800007a0 <vmm_pagewalk>:
uint64_t vmm_pagewalk(uint64_t vaddr, uint64_t* cr3)
{
    uint64_t* PML4 = (uint64_t*)(phys_to_hh_data((uint64_t)cr3));
    
    uint64_t index1, index2, index3, index4;
    vaddr >>= 12;
ffffffff800007a0:	49 89 f8             	mov    %rdi,%r8
    index1 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff800007a3:	48 89 f9             	mov    %rdi,%rcx
    index2 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff800007a6:	48 89 fa             	mov    %rdi,%rdx
    index3 = vaddr & 0x1ff;
    vaddr >>= 9;
ffffffff800007a9:	48 c1 ef 27          	shr    $0x27,%rdi
    index4 = vaddr & 0x1ff;
   
    uint64_t* PDPTE = (uint64_t*)((phys_to_hh_data(PML4[index4]) >> 12) * 4096);
ffffffff800007ad:	48 b8 00 00 00 00 00 	movabs $0xffff800000000000,%rax
ffffffff800007b4:	80 ff ff 
{
ffffffff800007b7:	53                   	push   %rbx
    index4 = vaddr & 0x1ff;
ffffffff800007b8:	81 e7 ff 01 00 00    	and    $0x1ff,%edi
    vaddr >>= 9;
ffffffff800007be:	48 c1 ea 1e          	shr    $0x1e,%rdx
    vaddr >>= 9;
ffffffff800007c2:	48 c1 e9 15          	shr    $0x15,%rcx
    uint64_t* PDPTE = (uint64_t*)((phys_to_hh_data(PML4[index4]) >> 12) * 4096);
ffffffff800007c6:	48 8d 34 fe          	lea    (%rsi,%rdi,8),%rsi
    index3 = vaddr & 0x1ff;
ffffffff800007ca:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
    index2 = vaddr & 0x1ff;
ffffffff800007d0:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
    vaddr >>= 12;
ffffffff800007d6:	49 c1 e8 0c          	shr    $0xc,%r8
    return addr - 0xFFFF800000000000;
}

static inline uint64_t phys_to_hh_data(uint64_t addr)
{
    return 0xFFFF800000000000 + addr;
ffffffff800007da:	48 8b 1c 06          	mov    (%rsi,%rax,1),%rbx
    index1 = vaddr & 0x1ff;
ffffffff800007de:	41 81 e0 ff 01 00 00 	and    $0x1ff,%r8d
ffffffff800007e5:	48 01 c3             	add    %rax,%rbx
ffffffff800007e8:	48 89 de             	mov    %rbx,%rsi
    uint64_t* PDE = (uint64_t*)((phys_to_hh_data(PDPTE[index3]) >> 12) * 4096);
ffffffff800007eb:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
ffffffff800007f2:	48 8b 1c d6          	mov    (%rsi,%rdx,8),%rbx
ffffffff800007f6:	48 01 c3             	add    %rax,%rbx
ffffffff800007f9:	48 89 de             	mov    %rbx,%rsi
    uint64_t* PTE = (uint64_t*)((phys_to_hh_data(PDE[index2]) >> 12) * 4096);
ffffffff800007fc:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
ffffffff80000803:	48 8b 1c ce          	mov    (%rsi,%rcx,8),%rbx
ffffffff80000807:	48 01 c3             	add    %rax,%rbx
ffffffff8000080a:	48 89 de             	mov    %rbx,%rsi
    return addr - 0xFFFF800000000000;
ffffffff8000080d:	48 bb 00 00 00 00 00 	movabs $0x800000000000,%rbx
ffffffff80000814:	80 00 00 
    uint64_t* PD = (uint64_t*)((phys_to_hh_data(PTE[index1]) >> 12) * 4096);
ffffffff80000817:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
    return 0xFFFF800000000000 + addr;
ffffffff8000081e:	4a 03 04 c6          	add    (%rsi,%r8,8),%rax

    uint64_t pageaddr = hh_data_to_phys((uint64_t)PD);
    
    printf("%d  %d  %d  %d  %p\n", index4, index3, index2, index1, pageaddr);
ffffffff80000822:	48 89 fe             	mov    %rdi,%rsi
ffffffff80000825:	48 c7 c7 e0 48 00 80 	mov    $0xffffffff800048e0,%rdi
    uint64_t* PD = (uint64_t*)((phys_to_hh_data(PTE[index1]) >> 12) * 4096);
ffffffff8000082c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
    return addr - 0xFFFF800000000000;
ffffffff80000832:	48 01 c3             	add    %rax,%rbx
    printf("%d  %d  %d  %d  %p\n", index4, index3, index2, index1, pageaddr);
ffffffff80000835:	31 c0                	xor    %eax,%eax
ffffffff80000837:	49 89 d9             	mov    %rbx,%r9
ffffffff8000083a:	e8 b1 29 00 00       	callq  ffffffff800031f0 <printf_>
    
    
    pageaddr >>= 12;
    pageaddr *= 4096;
ffffffff8000083f:	48 89 d8             	mov    %rbx,%rax

    return pageaddr;
}
ffffffff80000842:	5b                   	pop    %rbx
ffffffff80000843:	c3                   	retq   
ffffffff80000844:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000084b:	00 00 00 00 
ffffffff8000084f:	90                   	nop

ffffffff80000850 <vmm_init>:

void vmm_init()
{
ffffffff80000850:	41 55                	push   %r13
ffffffff80000852:	41 54                	push   %r12
    kernel_cr3 = (struct PageTable*)vmm_read_cr3();
ffffffff80000854:	31 c0                	xor    %eax,%eax
{
ffffffff80000856:	55                   	push   %rbp
ffffffff80000857:	53                   	push   %rbx
    printf("CR3: %p\n", (uint64_t)kernel_cr3);
 
    uint64_t kernel_phys = boot_info.tag_kernel_base_address->physical_base_address;
    uint64_t kernel_virt = boot_info.tag_kernel_base_address->virtual_base_address;
    uint64_t kernel_size = (uint64_t)&_end_of_kernel - (uint64_t)&_start_of_kernel;
ffffffff80000858:	48 c7 c3 80 f8 00 80 	mov    $0xffffffff8000f880,%rbx
ffffffff8000085f:	48 89 dd             	mov    %rbx,%rbp
{
ffffffff80000862:	48 83 ec 08          	sub    $0x8,%rsp
    uint64_t kernel_size = (uint64_t)&_end_of_kernel - (uint64_t)&_start_of_kernel;
ffffffff80000866:	48 81 ed 00 00 00 80 	sub    $0xffffffff80000000,%rbp
    kernel_cr3 = (struct PageTable*)vmm_read_cr3();
ffffffff8000086d:	e8 be f7 ff ff       	callq  ffffffff80000030 <vmm_read_cr3>
    printf("CR3: %p\n", (uint64_t)kernel_cr3);
ffffffff80000872:	48 c7 c7 f4 48 00 80 	mov    $0xffffffff800048f4,%rdi
ffffffff80000879:	48 89 c6             	mov    %rax,%rsi
    kernel_cr3 = (struct PageTable*)vmm_read_cr3();
ffffffff8000087c:	48 89 05 3d de 00 00 	mov    %rax,0xde3d(%rip)        # ffffffff8000e6c0 <kernel_cr3>
    printf("CR3: %p\n", (uint64_t)kernel_cr3);
ffffffff80000883:	31 c0                	xor    %eax,%eax
ffffffff80000885:	e8 66 29 00 00       	callq  ffffffff800031f0 <printf_>
    uint64_t kernel_phys = boot_info.tag_kernel_base_address->physical_base_address;
ffffffff8000088a:	48 8b 05 cf 99 00 00 	mov    0x99cf(%rip),%rax        # ffffffff8000a260 <boot_info>

    printf("Kernel Virtual: %p   Kernal Physical: %p\n", kernel_virt, kernel_phys);
ffffffff80000891:	48 c7 c7 90 49 00 80 	mov    $0xffffffff80004990,%rdi
    uint64_t kernel_phys = boot_info.tag_kernel_base_address->physical_base_address;
ffffffff80000898:	4c 8b 60 10          	mov    0x10(%rax),%r12
    uint64_t kernel_virt = boot_info.tag_kernel_base_address->virtual_base_address;
ffffffff8000089c:	4c 8b 68 18          	mov    0x18(%rax),%r13
    printf("Kernel Virtual: %p   Kernal Physical: %p\n", kernel_virt, kernel_phys);
ffffffff800008a0:	31 c0                	xor    %eax,%eax
ffffffff800008a2:	4c 89 e2             	mov    %r12,%rdx
ffffffff800008a5:	4c 89 ee             	mov    %r13,%rsi
ffffffff800008a8:	e8 43 29 00 00       	callq  ffffffff800031f0 <printf_>

    printf("Kernel: %p - %p Size: %d\n", &_start_of_kernel, &_end_of_kernel, kernel_size);
ffffffff800008ad:	48 89 e9             	mov    %rbp,%rcx
ffffffff800008b0:	48 89 da             	mov    %rbx,%rdx
ffffffff800008b3:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
ffffffff800008ba:	48 c7 c7 fd 48 00 80 	mov    $0xffffffff800048fd,%rdi
ffffffff800008c1:	31 c0                	xor    %eax,%eax
ffffffff800008c3:	e8 28 29 00 00       	callq  ffffffff800031f0 <printf_>
    printf("Text:   %p - %p \n", &_start_of_text, &_end_of_text);
ffffffff800008c8:	48 c7 c2 b6 38 00 80 	mov    $0xffffffff800038b6,%rdx
ffffffff800008cf:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
ffffffff800008d6:	48 c7 c7 17 49 00 80 	mov    $0xffffffff80004917,%rdi
ffffffff800008dd:	31 c0                	xor    %eax,%eax
ffffffff800008df:	e8 0c 29 00 00       	callq  ffffffff800031f0 <printf_>
    printf("Data:   %p - %p \n", &_start_of_data, &_end_of_data);
ffffffff800008e4:	48 c7 c2 60 82 00 80 	mov    $0xffffffff80008260,%rdx
ffffffff800008eb:	48 c7 c6 7c 6c 00 80 	mov    $0xffffffff80006c7c,%rsi
ffffffff800008f2:	48 c7 c7 29 49 00 80 	mov    $0xffffffff80004929,%rdi
ffffffff800008f9:	31 c0                	xor    %eax,%eax
ffffffff800008fb:	e8 f0 28 00 00       	callq  ffffffff800031f0 <printf_>
    printf("ROData: %p - %p \n", &_start_of_rodata, &_end_of_rodata);
ffffffff80000900:	48 c7 c2 40 51 00 80 	mov    $0xffffffff80005140,%rdx
ffffffff80000907:	48 c7 c6 e0 48 00 80 	mov    $0xffffffff800048e0,%rsi
ffffffff8000090e:	48 c7 c7 3b 49 00 80 	mov    $0xffffffff8000493b,%rdi
ffffffff80000915:	31 c0                	xor    %eax,%eax
ffffffff80000917:	e8 d4 28 00 00       	callq  ffffffff800031f0 <printf_>
    printf("BSS:    %p - %p \n", &_start_of_bss, &_end_of_bss);
ffffffff8000091c:	48 c7 c2 80 f8 00 80 	mov    $0xffffffff8000f880,%rdx
ffffffff80000923:	48 c7 c6 60 82 00 80 	mov    $0xffffffff80008260,%rsi
ffffffff8000092a:	48 c7 c7 4d 49 00 80 	mov    $0xffffffff8000494d,%rdi
ffffffff80000931:	31 c0                	xor    %eax,%eax
ffffffff80000933:	e8 b8 28 00 00       	callq  ffffffff800031f0 <printf_>

    //vmm_pagewalk((uint64_t)&_start_of_kernel, (uint64_t*)read_cr3());
    //vmm_pagewalk((uint64_t)&_end_of_kernel, (uint64_t*)read_cr3());

    //Create the Kernel PML4 table
    RootPageDirectory = vmm_create_page_table();
ffffffff80000938:	31 c0                	xor    %eax,%eax
ffffffff8000093a:	e8 e1 fc ff ff       	callq  ffffffff80000620 <vmm_create_page_table>

    printf("Root = %p\n", RootPageDirectory);
ffffffff8000093f:	48 c7 c7 5f 49 00 80 	mov    $0xffffffff8000495f,%rdi
    RootPageDirectory = vmm_create_page_table();
ffffffff80000946:	48 89 05 7b dd 00 00 	mov    %rax,0xdd7b(%rip)        # ffffffff8000e6c8 <RootPageDirectory>
    printf("Root = %p\n", RootPageDirectory);
ffffffff8000094d:	48 89 c6             	mov    %rax,%rsi
ffffffff80000950:	31 c0                	xor    %eax,%eax
ffffffff80000952:	e8 99 28 00 00       	callq  ffffffff800031f0 <printf_>

    //Map the Kernel
    //TODO - Make the pages sensitive to RO/RW
    for(uint64_t i = 0; i < kernel_size; i += 4096)
ffffffff80000957:	48 85 ed             	test   %rbp,%rbp
ffffffff8000095a:	74 2a                	je     ffffffff80000986 <vmm_init+0x136>
ffffffff8000095c:	31 db                	xor    %ebx,%ebx
ffffffff8000095e:	66 90                	xchg   %ax,%ax
    {
        vmm_map_page(RootPageDirectory, kernel_virt + i, kernel_phys + i, PTE_PRESENT | PTE_READWRITE);
ffffffff80000960:	48 8b 3d 61 dd 00 00 	mov    0xdd61(%rip),%rdi        # ffffffff8000e6c8 <RootPageDirectory>
ffffffff80000967:	49 8d 14 1c          	lea    (%r12,%rbx,1),%rdx
ffffffff8000096b:	49 8d 74 1d 00       	lea    0x0(%r13,%rbx,1),%rsi
ffffffff80000970:	b9 03 00 00 00       	mov    $0x3,%ecx
    for(uint64_t i = 0; i < kernel_size; i += 4096)
ffffffff80000975:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
        vmm_map_page(RootPageDirectory, kernel_virt + i, kernel_phys + i, PTE_PRESENT | PTE_READWRITE);
ffffffff8000097c:	e8 5f fd ff ff       	callq  ffffffff800006e0 <vmm_map_page>
    for(uint64_t i = 0; i < kernel_size; i += 4096)
ffffffff80000981:	48 39 dd             	cmp    %rbx,%rbp
ffffffff80000984:	77 da                	ja     ffffffff80000960 <vmm_init+0x110>
    }

    //Map Physical Memory
    printf("HHDM: %p\n", boot_info.tag_hhdm->addr);
ffffffff80000986:	48 8b 05 0b 99 00 00 	mov    0x990b(%rip),%rax        # ffffffff8000a298 <boot_info+0x38>
ffffffff8000098d:	48 c7 c7 6a 49 00 80 	mov    $0xffffffff8000496a,%rdi
ffffffff80000994:	bb 00 10 00 00       	mov    $0x1000,%ebx
ffffffff80000999:	48 8b 70 10          	mov    0x10(%rax),%rsi
ffffffff8000099d:	31 c0                	xor    %eax,%eax
ffffffff8000099f:	e8 4c 28 00 00       	callq  ffffffff800031f0 <printf_>
ffffffff800009a4:	0f 1f 40 00          	nopl   0x0(%rax)
    for(uint64_t i = 1; i < 261; i++)
    {   
        vmm_map_2Mpage(RootPageDirectory, boot_info.tag_hhdm->addr + (0x1000 * i), (0x1000 * i), PTE_PRESENT | PTE_READWRITE);
ffffffff800009a8:	48 8b 05 e9 98 00 00 	mov    0x98e9(%rip),%rax        # ffffffff8000a298 <boot_info+0x38>
ffffffff800009af:	48 8b 3d 12 dd 00 00 	mov    0xdd12(%rip),%rdi        # ffffffff8000e6c8 <RootPageDirectory>
ffffffff800009b6:	48 89 da             	mov    %rbx,%rdx
ffffffff800009b9:	b9 03 00 00 00       	mov    $0x3,%ecx
ffffffff800009be:	48 8b 70 10          	mov    0x10(%rax),%rsi
ffffffff800009c2:	48 01 de             	add    %rbx,%rsi
ffffffff800009c5:	48 81 c3 00 10 00 00 	add    $0x1000,%rbx
ffffffff800009cc:	e8 7f fc ff ff       	callq  ffffffff80000650 <vmm_map_2Mpage>
    for(uint64_t i = 1; i < 261; i++)
ffffffff800009d1:	48 81 fb 00 50 10 00 	cmp    $0x105000,%rbx
ffffffff800009d8:	75 ce                	jne    ffffffff800009a8 <vmm_init+0x158>
    }

    printf("New CR3: %p -- & %p \n", (uint64_t)RootPageDirectory, &RootPageDirectory);
ffffffff800009da:	48 8b 35 e7 dc 00 00 	mov    0xdce7(%rip),%rsi        # ffffffff8000e6c8 <RootPageDirectory>
ffffffff800009e1:	48 c7 c7 74 49 00 80 	mov    $0xffffffff80004974,%rdi
ffffffff800009e8:	48 c7 c2 c8 e6 00 80 	mov    $0xffffffff8000e6c8,%rdx
ffffffff800009ef:	31 c0                	xor    %eax,%eax
ffffffff800009f1:	e8 fa 27 00 00       	callq  ffffffff800031f0 <printf_>
    //*value = 0xdeadbeef;
    //printf("Magic: %p\n", *value);

    //vmm_pagewalk((uint64_t)&_start_of_kernel, (uint64_t*)RootPageDirectory);
    
}
ffffffff800009f6:	48 83 c4 08          	add    $0x8,%rsp
    serial_write(0x3F8, 'v');
ffffffff800009fa:	be 76 00 00 00       	mov    $0x76,%esi
ffffffff800009ff:	bf f8 03 00 00       	mov    $0x3f8,%edi
}
ffffffff80000a04:	5b                   	pop    %rbx
ffffffff80000a05:	5d                   	pop    %rbp
ffffffff80000a06:	41 5c                	pop    %r12
ffffffff80000a08:	41 5d                	pop    %r13
    serial_write(0x3F8, 'v');
ffffffff80000a0a:	e9 b1 12 00 00       	jmpq   ffffffff80001cc0 <serial_write>
ffffffff80000a0f:	90                   	nop

ffffffff80000a10 <liballoc_lock>:

extern struct PageTable* kernel_cr3;

int liballoc_lock()
{
    asm("cli");
ffffffff80000a10:	fa                   	cli    
    return 0;
}
ffffffff80000a11:	31 c0                	xor    %eax,%eax
ffffffff80000a13:	c3                   	retq   
ffffffff80000a14:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000a1b:	00 00 00 00 
ffffffff80000a1f:	90                   	nop

ffffffff80000a20 <liballoc_unlock>:


int liballoc_unlock()
{
    asm("sti");
ffffffff80000a20:	fb                   	sti    
    return 0;
}
ffffffff80000a21:	31 c0                	xor    %eax,%eax
ffffffff80000a23:	c3                   	retq   
ffffffff80000a24:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000a2b:	00 00 00 00 
ffffffff80000a2f:	90                   	nop

ffffffff80000a30 <liballoc_free>:

int liballoc_free(void* page, size_t count)
{
    
}
ffffffff80000a30:	f3 c3                	repz retq 
ffffffff80000a32:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80000a39:	00 00 00 00 
ffffffff80000a3d:	0f 1f 00             	nopl   (%rax)

ffffffff80000a40 <liballoc_alloc>:

void* liballoc_alloc(size_t count)
{
    for(int i = 0; i < count; i++)
ffffffff80000a40:	48 85 ff             	test   %rdi,%rdi
ffffffff80000a43:	74 6b                	je     ffffffff80000ab0 <liballoc_alloc+0x70>
{
ffffffff80000a45:	55                   	push   %rbp
ffffffff80000a46:	53                   	push   %rbx
ffffffff80000a47:	89 fd                	mov    %edi,%ebp
    for(int i = 0; i < count; i++)
ffffffff80000a49:	31 db                	xor    %ebx,%ebx
{
ffffffff80000a4b:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80000a4f:	90                   	nop
    {
        vmm_map_page(kernel_cr3, ((uint64_t)kernel_heap_top + 4096), (uint64_t)pmm_allocpage(), PTE_PRESENT | PTE_READWRITE);
ffffffff80000a50:	31 c0                	xor    %eax,%eax
    for(int i = 0; i < count; i++)
ffffffff80000a52:	83 c3 01             	add    $0x1,%ebx
        vmm_map_page(kernel_cr3, ((uint64_t)kernel_heap_top + 4096), (uint64_t)pmm_allocpage(), PTE_PRESENT | PTE_READWRITE);
ffffffff80000a55:	e8 e6 09 00 00       	callq  ffffffff80001440 <pmm_allocpage>
ffffffff80000a5a:	48 8b 0d 67 98 00 00 	mov    0x9867(%rip),%rcx        # ffffffff8000a2c8 <kernel_heap_top>
ffffffff80000a61:	48 8b 3d 58 dc 00 00 	mov    0xdc58(%rip),%rdi        # ffffffff8000e6c0 <kernel_cr3>
ffffffff80000a68:	48 89 c2             	mov    %rax,%rdx
ffffffff80000a6b:	48 8d b1 00 10 00 00 	lea    0x1000(%rcx),%rsi
ffffffff80000a72:	b9 03 00 00 00       	mov    $0x3,%ecx
ffffffff80000a77:	e8 64 fc ff ff       	callq  ffffffff800006e0 <vmm_map_page>
        kernel_heap_top += 4096;
ffffffff80000a7c:	48 8b 05 45 98 00 00 	mov    0x9845(%rip),%rax        # ffffffff8000a2c8 <kernel_heap_top>
ffffffff80000a83:	48 05 00 80 00 00    	add    $0x8000,%rax
    for(int i = 0; i < count; i++)
ffffffff80000a89:	39 eb                	cmp    %ebp,%ebx
        kernel_heap_top += 4096;
ffffffff80000a8b:	48 89 05 36 98 00 00 	mov    %rax,0x9836(%rip)        # ffffffff8000a2c8 <kernel_heap_top>
    for(int i = 0; i < count; i++)
ffffffff80000a92:	75 bc                	jne    ffffffff80000a50 <liballoc_alloc+0x10>
    }
    return (void*)(phys_to_hh_data((uint64_t)kernel_heap_top));
ffffffff80000a94:	48 83 c4 08          	add    $0x8,%rsp
{
ffffffff80000a98:	48 ba 00 00 00 00 00 	movabs $0xffff800000000000,%rdx
ffffffff80000a9f:	80 ff ff 
ffffffff80000aa2:	48 01 d0             	add    %rdx,%rax
ffffffff80000aa5:	5b                   	pop    %rbx
ffffffff80000aa6:	5d                   	pop    %rbp
ffffffff80000aa7:	c3                   	retq   
ffffffff80000aa8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80000aaf:	00 
ffffffff80000ab0:	48 8b 05 11 98 00 00 	mov    0x9811(%rip),%rax        # ffffffff8000a2c8 <kernel_heap_top>
ffffffff80000ab7:	48 ba 00 00 00 00 00 	movabs $0xffff800000000000,%rdx
ffffffff80000abe:	80 ff ff 
ffffffff80000ac1:	48 01 d0             	add    %rdx,%rax
ffffffff80000ac4:	c3                   	retq   
ffffffff80000ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80000acc:	00 00 00 
ffffffff80000acf:	90                   	nop

ffffffff80000ad0 <allocate_new_page>:
	unsigned int st;
	struct liballoc_major *maj;

		// This is how much space is required.
		st  = size + sizeof(struct liballoc_major);
		st += sizeof(struct liballoc_minor);
ffffffff80000ad0:	83 c7 50             	add    $0x50,%edi
{
ffffffff80000ad3:	53                   	push   %rbx
ffffffff80000ad4:	bb 10 00 00 00       	mov    $0x10,%ebx
ffffffff80000ad9:	89 f8                	mov    %edi,%eax

				// Perfect amount of space?
		if ( (st % l_pageSize) == 0 )
ffffffff80000adb:	81 e7 ff 0f 00 00    	and    $0xfff,%edi
ffffffff80000ae1:	c1 e8 0c             	shr    $0xc,%eax
			st  = st / (l_pageSize);
		else
			st  = st / (l_pageSize) + 1;
ffffffff80000ae4:	83 ff 01             	cmp    $0x1,%edi
ffffffff80000ae7:	83 d8 ff             	sbb    $0xffffffff,%eax
ffffffff80000aea:	83 f8 10             	cmp    $0x10,%eax
ffffffff80000aed:	0f 43 d8             	cmovae %eax,%ebx

		
		// Make sure it's >= the minimum size.
		if ( st < l_pageCount ) st = l_pageCount;
		
		maj = (struct liballoc_major*)liballoc_alloc( st );
ffffffff80000af0:	89 df                	mov    %ebx,%edi
ffffffff80000af2:	e8 49 ff ff ff       	callq  ffffffff80000a40 <liballoc_alloc>

		if ( maj == NULL ) 
ffffffff80000af7:	48 85 c0             	test   %rax,%rax
ffffffff80000afa:	74 34                	je     ffffffff80000b30 <allocate_new_page+0x60>
			return NULL;	// uh oh, we ran out of memory.
		}
		
		maj->prev 	= NULL;
		maj->next 	= NULL;
		maj->pages 	= st;
ffffffff80000afc:	89 58 10             	mov    %ebx,0x10(%rax)
		maj->size 	= st * l_pageSize;
ffffffff80000aff:	c1 e3 0c             	shl    $0xc,%ebx
		maj->prev 	= NULL;
ffffffff80000b02:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		maj->next 	= NULL;
ffffffff80000b09:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff80000b10:	00 
		maj->size 	= st * l_pageSize;
ffffffff80000b11:	89 58 14             	mov    %ebx,0x14(%rax)
		maj->usage 	= sizeof(struct liballoc_major);
ffffffff80000b14:	c7 40 18 28 00 00 00 	movl   $0x28,0x18(%rax)
		maj->first 	= NULL;
ffffffff80000b1b:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff80000b22:	00 

		l_allocated += maj->size;
ffffffff80000b23:	48 01 1d c6 db 00 00 	add    %rbx,0xdbc6(%rip)        # ffffffff8000e6f0 <l_allocated>
		FLUSH();
		#endif
	
		
      return maj;
}
ffffffff80000b2a:	5b                   	pop    %rbx
ffffffff80000b2b:	c3                   	retq   
ffffffff80000b2c:	0f 1f 40 00          	nopl   0x0(%rax)
			l_warningCount += 1;
ffffffff80000b30:	48 83 05 a8 db 00 00 	addq   $0x1,0xdba8(%rip)        # ffffffff8000e6e0 <l_warningCount>
ffffffff80000b37:	01 
}
ffffffff80000b38:	5b                   	pop    %rbx
ffffffff80000b39:	c3                   	retq   
ffffffff80000b3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80000b40 <kmalloc>:

	


void *PREFIX(malloc)(size_t req_size)
{
ffffffff80000b40:	41 57                	push   %r15
ffffffff80000b42:	41 56                	push   %r14
ffffffff80000b44:	41 55                	push   %r13
ffffffff80000b46:	41 54                	push   %r12
ffffffff80000b48:	49 89 fd             	mov    %rdi,%r13
ffffffff80000b4b:	55                   	push   %rbp
ffffffff80000b4c:	53                   	push   %rbx
ffffffff80000b4d:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80000b51:	eb 1a                	jmp    ffffffff80000b6d <kmalloc+0x2d>
ffffffff80000b53:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		#if defined DEBUG || defined INFO
		printf( "liballoc: WARNING: alloc( 0 ) called from %x\n",
							__builtin_return_address(0) );
		FLUSH();
		#endif
		liballoc_unlock();
ffffffff80000b58:	31 c0                	xor    %eax,%eax
		return PREFIX(malloc)(1);
ffffffff80000b5a:	41 bd 01 00 00 00    	mov    $0x1,%r13d
		l_warningCount += 1;
ffffffff80000b60:	48 83 05 78 db 00 00 	addq   $0x1,0xdb78(%rip)        # ffffffff8000e6e0 <l_warningCount>
ffffffff80000b67:	01 
		liballoc_unlock();
ffffffff80000b68:	e8 b3 fe ff ff       	callq  ffffffff80000a20 <liballoc_unlock>
		size += ALIGNMENT + ALIGN_INFO;
ffffffff80000b6d:	4d 8d 65 20          	lea    0x20(%r13),%r12
	liballoc_lock();
ffffffff80000b71:	31 c0                	xor    %eax,%eax
ffffffff80000b73:	e8 98 fe ff ff       	callq  ffffffff80000a10 <liballoc_lock>
	if ( size == 0 )
ffffffff80000b78:	4d 85 e4             	test   %r12,%r12
ffffffff80000b7b:	74 db                	je     ffffffff80000b58 <kmalloc+0x18>
	}
	

	if ( l_memRoot == NULL )
ffffffff80000b7d:	48 8b 35 7c db 00 00 	mov    0xdb7c(%rip),%rsi        # ffffffff8000e700 <l_memRoot>
ffffffff80000b84:	48 85 f6             	test   %rsi,%rsi
ffffffff80000b87:	0f 84 c3 02 00 00    	je     ffffffff80000e50 <kmalloc+0x310>

	maj = l_memRoot;
	startedBet = 0;
	
	// Start at the best bet....
	if ( l_bestBet != NULL )
ffffffff80000b8d:	48 8b 15 64 db 00 00 	mov    0xdb64(%rip),%rdx        # ffffffff8000e6f8 <l_bestBet>
ffffffff80000b94:	49 8d 5d 48          	lea    0x48(%r13),%rbx
ffffffff80000b98:	48 85 d2             	test   %rdx,%rdx
ffffffff80000b9b:	0f 84 3f 02 00 00    	je     ffffffff80000de0 <kmalloc+0x2a0>
	{
		bestSize = l_bestBet->size - l_bestBet->usage;
ffffffff80000ba1:	8b 42 14             	mov    0x14(%rdx),%eax
ffffffff80000ba4:	8b 4a 18             	mov    0x18(%rdx),%ecx

		if ( bestSize > (size + sizeof(struct liballoc_minor)))
		{
			maj = l_bestBet;
			startedBet = 1;
ffffffff80000ba7:	41 bf 01 00 00 00    	mov    $0x1,%r15d
		bestSize = l_bestBet->size - l_bestBet->usage;
ffffffff80000bad:	41 89 c6             	mov    %eax,%r14d
ffffffff80000bb0:	41 29 ce             	sub    %ecx,%r14d
		if ( bestSize > (size + sizeof(struct liballoc_minor)))
ffffffff80000bb3:	49 39 de             	cmp    %rbx,%r14
ffffffff80000bb6:	0f 86 b4 01 00 00    	jbe    ffffffff80000d70 <kmalloc+0x230>
		}
	}
	
	while ( maj != NULL )
	{
		diff  = maj->size - maj->usage;	
ffffffff80000bbc:	29 c8                	sub    %ecx,%eax
										// free memory in the block

		if ( bestSize < diff )
ffffffff80000bbe:	4c 39 f0             	cmp    %r14,%rax
ffffffff80000bc1:	76 0a                	jbe    ffffffff80000bcd <kmalloc+0x8d>
		{
			// Hmm.. this one has more memory then our bestBet. Remember!
			l_bestBet = maj;
ffffffff80000bc3:	48 89 15 2e db 00 00 	mov    %rdx,0xdb2e(%rip)        # ffffffff8000e6f8 <l_bestBet>
ffffffff80000bca:	49 89 c6             	mov    %rax,%r14
		
		
#ifdef USE_CASE1
			
		// CASE 1:  There is not enough space in this major block.
		if ( diff < (size + sizeof( struct liballoc_minor )) )
ffffffff80000bcd:	48 39 d8             	cmp    %rbx,%rax
ffffffff80000bd0:	73 22                	jae    ffffffff80000bf4 <kmalloc+0xb4>
			printf( "CASE 1: Insufficient space in block %x\n", maj);
			FLUSH();
			#endif
				
				// Another major block next to this one?
			if ( maj->next != NULL ) 
ffffffff80000bd2:	48 8b 42 08          	mov    0x8(%rdx),%rax
ffffffff80000bd6:	48 85 c0             	test   %rax,%rax
ffffffff80000bd9:	0f 84 b9 00 00 00    	je     ffffffff80000c98 <kmalloc+0x158>
ffffffff80000bdf:	48 89 c2             	mov    %rax,%rdx
ffffffff80000be2:	8b 42 14             	mov    0x14(%rdx),%eax
ffffffff80000be5:	8b 4a 18             	mov    0x18(%rdx),%ecx
		diff  = maj->size - maj->usage;	
ffffffff80000be8:	29 c8                	sub    %ecx,%eax
		if ( bestSize < diff )
ffffffff80000bea:	4c 39 f0             	cmp    %r14,%rax
ffffffff80000bed:	77 d4                	ja     ffffffff80000bc3 <kmalloc+0x83>
		if ( diff < (size + sizeof( struct liballoc_minor )) )
ffffffff80000bef:	48 39 d8             	cmp    %rbx,%rax
ffffffff80000bf2:	72 de                	jb     ffffffff80000bd2 <kmalloc+0x92>
ffffffff80000bf4:	48 89 d5             	mov    %rdx,%rbp
#endif

#ifdef USE_CASE2
		
		// CASE 2: It's a brand new block.
		if ( maj->first == NULL )
ffffffff80000bf7:	48 8b 55 20          	mov    0x20(%rbp),%rdx
ffffffff80000bfb:	48 85 d2             	test   %rdx,%rdx
ffffffff80000bfe:	0f 84 7d 01 00 00    	je     ffffffff80000d81 <kmalloc+0x241>
				
#ifdef USE_CASE3

		// CASE 3: Block in use and enough space at the start of the block.
		diff =  (uintptr_t)(maj->first);
		diff -= (uintptr_t)maj;
ffffffff80000c04:	48 89 d0             	mov    %rdx,%rax
ffffffff80000c07:	48 29 e8             	sub    %rbp,%rax
		diff -= sizeof(struct liballoc_major);
ffffffff80000c0a:	48 83 e8 28          	sub    $0x28,%rax

		if ( diff >= (size + sizeof(struct liballoc_minor)) )
ffffffff80000c0e:	48 39 d8             	cmp    %rbx,%rax
ffffffff80000c11:	0f 83 62 02 00 00    	jae    ffffffff80000e79 <kmalloc+0x339>
		
			// Looping within the block now...
		while ( min != NULL )
		{
				// CASE 4.1: End of minors in a block. Space from last and end?
				if ( min->next == NULL )
ffffffff80000c17:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
ffffffff80000c1b:	8b 72 1c             	mov    0x1c(%rdx),%esi
ffffffff80000c1e:	48 85 c9             	test   %rcx,%rcx
ffffffff80000c21:	74 25                	je     ffffffff80000c48 <kmalloc+0x108>
				// CASE 4.2: Is there space between two minors?
				if ( min->next != NULL )
				{
					// is the difference between here and next big enough?
					diff  = (uintptr_t)(min->next);
					diff -= (uintptr_t)min;
ffffffff80000c23:	48 89 c8             	mov    %rcx,%rax
ffffffff80000c26:	48 29 d0             	sub    %rdx,%rax
					diff -= sizeof( struct liballoc_minor );
ffffffff80000c29:	48 83 e8 28          	sub    $0x28,%rax
					diff -= min->size;
ffffffff80000c2d:	48 29 f0             	sub    %rsi,%rax
										// minus our existing usage.

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
ffffffff80000c30:	48 39 d8             	cmp    %rbx,%rax
ffffffff80000c33:	0f 83 b7 00 00 00    	jae    ffffffff80000cf0 <kmalloc+0x1b0>
ffffffff80000c39:	48 89 ca             	mov    %rcx,%rdx
				if ( min->next == NULL )
ffffffff80000c3c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
ffffffff80000c40:	8b 72 1c             	mov    0x1c(%rdx),%esi
ffffffff80000c43:	48 85 c9             	test   %rcx,%rcx
ffffffff80000c46:	75 db                	jne    ffffffff80000c23 <kmalloc+0xe3>
					diff = (uintptr_t)(maj) + maj->size;
ffffffff80000c48:	8b 45 14             	mov    0x14(%rbp),%eax
					diff -= sizeof( struct liballoc_minor );
ffffffff80000c4b:	48 8d 44 05 d8       	lea    -0x28(%rbp,%rax,1),%rax
ffffffff80000c50:	48 29 d0             	sub    %rdx,%rax
					diff -= min->size; 
ffffffff80000c53:	48 29 f0             	sub    %rsi,%rax
					if ( diff >= (size + sizeof( struct liballoc_minor )) )
ffffffff80000c56:	48 39 d8             	cmp    %rbx,%rax
ffffffff80000c59:	0f 83 99 01 00 00    	jae    ffffffff80000df8 <kmalloc+0x2b8>
#endif

#ifdef USE_CASE5

		// CASE 5: Block full! Ensure next block and loop.
		if ( maj->next == NULL ) 
ffffffff80000c5f:	48 8b 55 08          	mov    0x8(%rbp),%rdx
ffffffff80000c63:	48 85 d2             	test   %rdx,%rdx
ffffffff80000c66:	0f 85 76 ff ff ff    	jne    ffffffff80000be2 <kmalloc+0xa2>
			#ifdef DEBUG
			printf( "CASE 5: block full\n");
			FLUSH();
			#endif

			if ( startedBet == 1 )
ffffffff80000c6c:	41 83 ff 01          	cmp    $0x1,%r15d
ffffffff80000c70:	74 5e                	je     ffffffff80000cd0 <kmalloc+0x190>
				startedBet = 0;
				continue;
			}
				
			// we've run out. we need more...
			maj->next = allocate_new_page( size );		// next one guaranteed to be okay
ffffffff80000c72:	44 89 e7             	mov    %r12d,%edi
ffffffff80000c75:	e8 56 fe ff ff       	callq  ffffffff80000ad0 <allocate_new_page>
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
ffffffff80000c7a:	48 85 c0             	test   %rax,%rax
			maj->next = allocate_new_page( size );		// next one guaranteed to be okay
ffffffff80000c7d:	48 89 c2             	mov    %rax,%rdx
ffffffff80000c80:	48 89 45 08          	mov    %rax,0x8(%rbp)
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
ffffffff80000c84:	0f 84 e1 01 00 00    	je     ffffffff80000e6b <kmalloc+0x32b>
			maj->next->prev = maj;
ffffffff80000c8a:	48 89 28             	mov    %rbp,(%rax)
ffffffff80000c8d:	e9 50 ff ff ff       	jmpq   ffffffff80000be2 <kmalloc+0xa2>
ffffffff80000c92:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			if ( startedBet == 1 )		// If we started at the best bet,
ffffffff80000c98:	41 83 ff 01          	cmp    $0x1,%r15d
ffffffff80000c9c:	74 32                	je     ffffffff80000cd0 <kmalloc+0x190>
			maj->next = allocate_new_page( size );	// next one will be okay.
ffffffff80000c9e:	44 89 e7             	mov    %r12d,%edi
ffffffff80000ca1:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
ffffffff80000ca6:	e8 25 fe ff ff       	callq  ffffffff80000ad0 <allocate_new_page>
ffffffff80000cab:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
			if ( maj->next == NULL ) break;			// no more memory.
ffffffff80000cb0:	48 85 c0             	test   %rax,%rax
			maj->next = allocate_new_page( size );	// next one will be okay.
ffffffff80000cb3:	48 89 c5             	mov    %rax,%rbp
ffffffff80000cb6:	48 89 42 08          	mov    %rax,0x8(%rdx)
			if ( maj->next == NULL ) break;			// no more memory.
ffffffff80000cba:	0f 84 ab 01 00 00    	je     ffffffff80000e6b <kmalloc+0x32b>
			maj->next->prev = maj;
ffffffff80000cc0:	48 89 10             	mov    %rdx,(%rax)
ffffffff80000cc3:	e9 2f ff ff ff       	jmpq   ffffffff80000bf7 <kmalloc+0xb7>
ffffffff80000cc8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80000ccf:	00 
				maj = l_memRoot;
ffffffff80000cd0:	48 8b 15 29 da 00 00 	mov    0xda29(%rip),%rdx        # ffffffff8000e700 <l_memRoot>
	while ( maj != NULL )
ffffffff80000cd7:	48 85 d2             	test   %rdx,%rdx
ffffffff80000cda:	0f 84 8b 01 00 00    	je     ffffffff80000e6b <kmalloc+0x32b>
ffffffff80000ce0:	45 31 ff             	xor    %r15d,%r15d
ffffffff80000ce3:	e9 fa fe ff ff       	jmpq   ffffffff80000be2 <kmalloc+0xa2>
ffffffff80000ce8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80000cef:	00 
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff80000cf0:	48 8d 1c 16          	lea    (%rsi,%rdx,1),%rbx
						l_inuse += size;
ffffffff80000cf4:	4c 01 25 ed d9 00 00 	add    %r12,0xd9ed(%rip)        # ffffffff8000e6e8 <l_inuse>
						new_min->next = min->next;
ffffffff80000cfb:	48 89 4b 30          	mov    %rcx,0x30(%rbx)
						min->next->prev = new_min;
ffffffff80000cff:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff80000d03:	48 8d 43 28          	lea    0x28(%rbx),%rax
						new_min->magic = LIBALLOC_MAGIC;
ffffffff80000d07:	c7 43 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rbx)
						ALIGN( p );
ffffffff80000d0e:	48 83 c3 60          	add    $0x60,%rbx
						new_min->prev = min;
ffffffff80000d12:	48 89 53 c8          	mov    %rdx,-0x38(%rbx)
						new_min->size = size;
ffffffff80000d16:	44 89 63 e4          	mov    %r12d,-0x1c(%rbx)
						new_min->req_size = req_size;
ffffffff80000d1a:	44 89 6b e8          	mov    %r13d,-0x18(%rbx)
						new_min->block = maj;
ffffffff80000d1e:	48 89 6b d8          	mov    %rbp,-0x28(%rbx)
						min->next->prev = new_min;
ffffffff80000d22:	48 89 01             	mov    %rax,(%rcx)
						min->next = new_min;
ffffffff80000d25:	48 89 42 08          	mov    %rax,0x8(%rdx)
						ALIGN( p );
ffffffff80000d29:	48 89 da             	mov    %rbx,%rdx
						maj->usage += size + sizeof( struct liballoc_minor );
ffffffff80000d2c:	41 8d 44 24 28       	lea    0x28(%r12),%eax
ffffffff80000d31:	01 45 18             	add    %eax,0x18(%rbp)
						ALIGN( p );
ffffffff80000d34:	83 e2 0f             	and    $0xf,%edx
ffffffff80000d37:	0f 84 93 00 00 00    	je     ffffffff80000dd0 <kmalloc+0x290>
ffffffff80000d3d:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80000d42:	48 29 d0             	sub    %rdx,%rax
ffffffff80000d45:	48 01 c3             	add    %rax,%rbx
ffffffff80000d48:	83 c0 10             	add    $0x10,%eax
ffffffff80000d4b:	88 43 f0             	mov    %al,-0x10(%rbx)
						liballoc_unlock();		// release the lock
ffffffff80000d4e:	31 c0                	xor    %eax,%eax
ffffffff80000d50:	e8 cb fc ff ff       	callq  ffffffff80000a20 <liballoc_unlock>
	printf( "liballoc: WARNING: PREFIX(malloc)( %i ) returning NULL.\n", size);
	liballoc_dump();
	FLUSH();
	#endif
	return NULL;
}
ffffffff80000d55:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80000d59:	48 89 d8             	mov    %rbx,%rax
ffffffff80000d5c:	5b                   	pop    %rbx
ffffffff80000d5d:	5d                   	pop    %rbp
ffffffff80000d5e:	41 5c                	pop    %r12
ffffffff80000d60:	41 5d                	pop    %r13
ffffffff80000d62:	41 5e                	pop    %r14
ffffffff80000d64:	41 5f                	pop    %r15
ffffffff80000d66:	c3                   	retq   
ffffffff80000d67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80000d6e:	00 00 
ffffffff80000d70:	8b 46 14             	mov    0x14(%rsi),%eax
ffffffff80000d73:	8b 4e 18             	mov    0x18(%rsi),%ecx
		if ( bestSize > (size + sizeof(struct liballoc_minor)))
ffffffff80000d76:	48 89 f2             	mov    %rsi,%rdx
	startedBet = 0;
ffffffff80000d79:	45 31 ff             	xor    %r15d,%r15d
ffffffff80000d7c:	e9 3b fe ff ff       	jmpq   ffffffff80000bbc <kmalloc+0x7c>
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
ffffffff80000d81:	48 8d 45 28          	lea    0x28(%rbp),%rax
			maj->first->magic 		= LIBALLOC_MAGIC;
ffffffff80000d85:	c7 45 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rbp)
			maj->first->prev 		= NULL;
ffffffff80000d8c:	48 c7 45 28 00 00 00 	movq   $0x0,0x28(%rbp)
ffffffff80000d93:	00 
			maj->first->next 		= NULL;
ffffffff80000d94:	48 c7 45 30 00 00 00 	movq   $0x0,0x30(%rbp)
ffffffff80000d9b:	00 
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
ffffffff80000d9c:	48 89 45 20          	mov    %rax,0x20(%rbp)
			ALIGN( p );
ffffffff80000da0:	48 8d 5d 60          	lea    0x60(%rbp),%rbx
			maj->first->block 	= maj;
ffffffff80000da4:	48 89 6d 38          	mov    %rbp,0x38(%rbp)
			maj->first->size 	= size;
ffffffff80000da8:	44 89 65 44          	mov    %r12d,0x44(%rbp)
			maj->first->req_size 	= req_size;
ffffffff80000dac:	44 89 6d 48          	mov    %r13d,0x48(%rbp)
			maj->usage 			+= size + sizeof( struct liballoc_minor );
ffffffff80000db0:	41 8d 44 24 28       	lea    0x28(%r12),%eax
			l_inuse += size;
ffffffff80000db5:	4c 01 25 2c d9 00 00 	add    %r12,0xd92c(%rip)        # ffffffff8000e6e8 <l_inuse>
			ALIGN( p );
ffffffff80000dbc:	48 89 da             	mov    %rbx,%rdx
			maj->usage 			+= size + sizeof( struct liballoc_minor );
ffffffff80000dbf:	01 45 18             	add    %eax,0x18(%rbp)
			ALIGN( p );
ffffffff80000dc2:	83 e2 0f             	and    $0xf,%edx
ffffffff80000dc5:	0f 85 72 ff ff ff    	jne    ffffffff80000d3d <kmalloc+0x1fd>
ffffffff80000dcb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
						ALIGN( p );
ffffffff80000dd0:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80000dd5:	e9 71 ff ff ff       	jmpq   ffffffff80000d4b <kmalloc+0x20b>
ffffffff80000dda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff80000de0:	8b 46 14             	mov    0x14(%rsi),%eax
ffffffff80000de3:	8b 4e 18             	mov    0x18(%rsi),%ecx
	if ( l_bestBet != NULL )
ffffffff80000de6:	48 89 f2             	mov    %rsi,%rdx
	unsigned long long bestSize = 0;
ffffffff80000de9:	45 31 f6             	xor    %r14d,%r14d
	startedBet = 0;
ffffffff80000dec:	45 31 ff             	xor    %r15d,%r15d
ffffffff80000def:	e9 c8 fd ff ff       	jmpq   ffffffff80000bbc <kmalloc+0x7c>
ffffffff80000df4:	0f 1f 40 00          	nopl   0x0(%rax)
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff80000df8:	48 01 d6             	add    %rdx,%rsi
						l_inuse += size;
ffffffff80000dfb:	4c 01 25 e6 d8 00 00 	add    %r12,0xd8e6(%rip)        # ffffffff8000e6e8 <l_inuse>
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff80000e02:	48 8d 46 28          	lea    0x28(%rsi),%rax
						ALIGN( p );
ffffffff80000e06:	48 8d 5e 60          	lea    0x60(%rsi),%rbx
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
ffffffff80000e0a:	48 89 42 08          	mov    %rax,0x8(%rdx)
						maj->usage += size + sizeof( struct liballoc_minor );
ffffffff80000e0e:	41 8d 44 24 28       	lea    0x28(%r12),%eax
						min->next->prev = min;
ffffffff80000e13:	48 89 56 28          	mov    %rdx,0x28(%rsi)
						ALIGN( p );
ffffffff80000e17:	48 89 da             	mov    %rbx,%rdx
						min->next = NULL;
ffffffff80000e1a:	48 c7 46 30 00 00 00 	movq   $0x0,0x30(%rsi)
ffffffff80000e21:	00 
						min->magic = LIBALLOC_MAGIC;
ffffffff80000e22:	c7 46 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rsi)
						min->block = maj;
ffffffff80000e29:	48 89 6e 38          	mov    %rbp,0x38(%rsi)
						min->size = size;
ffffffff80000e2d:	44 89 66 44          	mov    %r12d,0x44(%rsi)
						min->req_size = req_size;
ffffffff80000e31:	44 89 6e 48          	mov    %r13d,0x48(%rsi)
						maj->usage += size + sizeof( struct liballoc_minor );
ffffffff80000e35:	01 45 18             	add    %eax,0x18(%rbp)
						ALIGN( p );
ffffffff80000e38:	83 e2 0f             	and    $0xf,%edx
ffffffff80000e3b:	0f 85 fc fe ff ff    	jne    ffffffff80000d3d <kmalloc+0x1fd>
						ALIGN( p );
ffffffff80000e41:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80000e46:	e9 00 ff ff ff       	jmpq   ffffffff80000d4b <kmalloc+0x20b>
ffffffff80000e4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		l_memRoot = allocate_new_page( size );
ffffffff80000e50:	44 89 e7             	mov    %r12d,%edi
ffffffff80000e53:	e8 78 fc ff ff       	callq  ffffffff80000ad0 <allocate_new_page>
		if ( l_memRoot == NULL )
ffffffff80000e58:	48 85 c0             	test   %rax,%rax
		l_memRoot = allocate_new_page( size );
ffffffff80000e5b:	48 89 c6             	mov    %rax,%rsi
ffffffff80000e5e:	48 89 05 9b d8 00 00 	mov    %rax,0xd89b(%rip)        # ffffffff8000e700 <l_memRoot>
		if ( l_memRoot == NULL )
ffffffff80000e65:	0f 85 22 fd ff ff    	jne    ffffffff80000b8d <kmalloc+0x4d>
		  liballoc_unlock();
ffffffff80000e6b:	31 c0                	xor    %eax,%eax
		  return NULL;
ffffffff80000e6d:	31 db                	xor    %ebx,%ebx
		  liballoc_unlock();
ffffffff80000e6f:	e8 ac fb ff ff       	callq  ffffffff80000a20 <liballoc_unlock>
		  return NULL;
ffffffff80000e74:	e9 dc fe ff ff       	jmpq   ffffffff80000d55 <kmalloc+0x215>
			maj->first->prev = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
ffffffff80000e79:	48 8d 45 28          	lea    0x28(%rbp),%rax
ffffffff80000e7d:	48 89 02             	mov    %rax,(%rdx)
			maj->first->prev->next = maj->first;
ffffffff80000e80:	48 89 55 30          	mov    %rdx,0x30(%rbp)
			maj->first = maj->first->prev;
ffffffff80000e84:	48 89 45 20          	mov    %rax,0x20(%rbp)
			maj->first->magic 	= LIBALLOC_MAGIC;
ffffffff80000e88:	c7 45 40 de c0 01 c0 	movl   $0xc001c0de,0x40(%rbp)
			maj->first->prev 	= NULL;
ffffffff80000e8f:	48 c7 45 28 00 00 00 	movq   $0x0,0x28(%rbp)
ffffffff80000e96:	00 
ffffffff80000e97:	e9 04 ff ff ff       	jmpq   ffffffff80000da0 <kmalloc+0x260>
ffffffff80000e9c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80000ea0 <kfree>:
void PREFIX(free)(void *ptr)
{
	struct liballoc_minor *min;
	struct liballoc_major *maj;

	if ( ptr == NULL ) 
ffffffff80000ea0:	48 85 ff             	test   %rdi,%rdi
ffffffff80000ea3:	0f 84 d7 00 00 00    	je     ffffffff80000f80 <kfree+0xe0>
{
ffffffff80000ea9:	53                   	push   %rbx
		FLUSH();
		#endif
		return;
	}

	UNALIGN( ptr );
ffffffff80000eaa:	48 0f be 47 f0       	movsbq -0x10(%rdi),%rax
ffffffff80000eaf:	48 89 fb             	mov    %rdi,%rbx
ffffffff80000eb2:	48 29 c3             	sub    %rax,%rbx
ffffffff80000eb5:	48 83 f8 20          	cmp    $0x20,%rax
ffffffff80000eb9:	48 0f 43 df          	cmovae %rdi,%rbx

	liballoc_lock();		// lockit
ffffffff80000ebd:	31 c0                	xor    %eax,%eax
ffffffff80000ebf:	e8 4c fb ff ff       	callq  ffffffff80000a10 <liballoc_lock>


	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));

	
	if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff80000ec4:	8b 43 f0             	mov    -0x10(%rbx),%eax
	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
ffffffff80000ec7:	48 8d 73 d8          	lea    -0x28(%rbx),%rsi
	if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff80000ecb:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
ffffffff80000ed0:	74 2e                	je     ffffffff80000f00 <kfree+0x60>
	{
		l_errorCount += 1;

		// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
		if ( 
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80000ed2:	89 c2                	mov    %eax,%edx
		l_errorCount += 1;
ffffffff80000ed4:	48 83 05 fc d7 00 00 	addq   $0x1,0xd7fc(%rip)        # ffffffff8000e6d8 <l_errorCount>
ffffffff80000edb:	01 
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80000edc:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
		if ( 
ffffffff80000ee2:	81 fa de c0 01 00    	cmp    $0x1c0de,%edx
ffffffff80000ee8:	0f 84 82 00 00 00    	je     ffffffff80000f70 <kfree+0xd0>
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80000eee:	66 3d de c0          	cmp    $0xc0de,%ax
ffffffff80000ef2:	74 7c                	je     ffffffff80000f70 <kfree+0xd0>
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
ffffffff80000ef4:	3c de                	cmp    $0xde,%al
ffffffff80000ef6:	74 78                	je     ffffffff80000f70 <kfree+0xd0>
	printf( "OK\n");
	FLUSH();
	#endif
	
	liballoc_unlock();		// release the lock
}
ffffffff80000ef8:	5b                   	pop    %rbx
		liballoc_unlock();		// release the lock
ffffffff80000ef9:	31 c0                	xor    %eax,%eax
ffffffff80000efb:	e9 20 fb ff ff       	jmpq   ffffffff80000a20 <liballoc_unlock>
		maj = min->block;
ffffffff80000f00:	48 8b 7b e8          	mov    -0x18(%rbx),%rdi
		l_inuse -= min->size;
ffffffff80000f04:	8b 53 f4             	mov    -0xc(%rbx),%edx
ffffffff80000f07:	48 29 15 da d7 00 00 	sub    %rdx,0xd7da(%rip)        # ffffffff8000e6e8 <l_inuse>
		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
ffffffff80000f0e:	8b 4f 18             	mov    0x18(%rdi),%ecx
ffffffff80000f11:	29 d1                	sub    %edx,%ecx
		if ( min->next != NULL ) min->next->prev = min->prev;
ffffffff80000f13:	48 8b 53 e0          	mov    -0x20(%rbx),%rdx
		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
ffffffff80000f17:	89 c8                	mov    %ecx,%eax
ffffffff80000f19:	48 8b 4b d8          	mov    -0x28(%rbx),%rcx
ffffffff80000f1d:	83 e8 28             	sub    $0x28,%eax
		if ( min->next != NULL ) min->next->prev = min->prev;
ffffffff80000f20:	48 85 d2             	test   %rdx,%rdx
		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
ffffffff80000f23:	89 47 18             	mov    %eax,0x18(%rdi)
		min->magic  = LIBALLOC_DEAD;		// No mojo.
ffffffff80000f26:	c7 43 f0 ad de ad de 	movl   $0xdeaddead,-0x10(%rbx)
		if ( min->next != NULL ) min->next->prev = min->prev;
ffffffff80000f2d:	74 06                	je     ffffffff80000f35 <kfree+0x95>
ffffffff80000f2f:	48 89 0a             	mov    %rcx,(%rdx)
ffffffff80000f32:	48 8b 0e             	mov    (%rsi),%rcx
		if ( min->prev != NULL ) min->prev->next = min->next;
ffffffff80000f35:	48 85 c9             	test   %rcx,%rcx
ffffffff80000f38:	74 56                	je     ffffffff80000f90 <kfree+0xf0>
ffffffff80000f3a:	48 89 51 08          	mov    %rdx,0x8(%rcx)
ffffffff80000f3e:	48 8b 57 20          	mov    0x20(%rdi),%rdx
	if ( maj->first == NULL )	// Block completely unused.
ffffffff80000f42:	48 85 d2             	test   %rdx,%rdx
ffffffff80000f45:	48 8b 0d ac d7 00 00 	mov    0xd7ac(%rip),%rcx        # ffffffff8000e6f8 <l_bestBet>
ffffffff80000f4c:	74 52                	je     ffffffff80000fa0 <kfree+0x100>
		if ( l_bestBet != NULL )
ffffffff80000f4e:	48 85 c9             	test   %rcx,%rcx
ffffffff80000f51:	74 a5                	je     ffffffff80000ef8 <kfree+0x58>
			int bestSize = l_bestBet->size  - l_bestBet->usage;
ffffffff80000f53:	8b 51 14             	mov    0x14(%rcx),%edx
			int majSize = maj->size - maj->usage;
ffffffff80000f56:	8b 77 14             	mov    0x14(%rdi),%esi
			int bestSize = l_bestBet->size  - l_bestBet->usage;
ffffffff80000f59:	2b 51 18             	sub    0x18(%rcx),%edx
			int majSize = maj->size - maj->usage;
ffffffff80000f5c:	29 c6                	sub    %eax,%esi
			if ( majSize > bestSize ) l_bestBet = maj;
ffffffff80000f5e:	39 f2                	cmp    %esi,%edx
ffffffff80000f60:	7d 96                	jge    ffffffff80000ef8 <kfree+0x58>
ffffffff80000f62:	48 89 3d 8f d7 00 00 	mov    %rdi,0xd78f(%rip)        # ffffffff8000e6f8 <l_bestBet>
ffffffff80000f69:	eb 8d                	jmp    ffffffff80000ef8 <kfree+0x58>
ffffffff80000f6b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
			l_possibleOverruns += 1;
ffffffff80000f70:	48 83 05 58 d7 00 00 	addq   $0x1,0xd758(%rip)        # ffffffff8000e6d0 <l_possibleOverruns>
ffffffff80000f77:	01 
		liballoc_unlock();		// release the lock
ffffffff80000f78:	31 c0                	xor    %eax,%eax
}
ffffffff80000f7a:	5b                   	pop    %rbx
		liballoc_unlock();		// release the lock
ffffffff80000f7b:	e9 a0 fa ff ff       	jmpq   ffffffff80000a20 <liballoc_unlock>
		l_warningCount += 1;
ffffffff80000f80:	48 83 05 58 d7 00 00 	addq   $0x1,0xd758(%rip)        # ffffffff8000e6e0 <l_warningCount>
ffffffff80000f87:	01 
ffffffff80000f88:	c3                   	retq   
ffffffff80000f89:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		if ( min->prev == NULL ) maj->first = min->next;	
ffffffff80000f90:	48 89 57 20          	mov    %rdx,0x20(%rdi)
ffffffff80000f94:	eb ac                	jmp    ffffffff80000f42 <kfree+0xa2>
ffffffff80000f96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80000f9d:	00 00 00 
		if ( l_memRoot == maj ) l_memRoot = maj->next;
ffffffff80000fa0:	48 39 3d 59 d7 00 00 	cmp    %rdi,0xd759(%rip)        # ffffffff8000e700 <l_memRoot>
ffffffff80000fa7:	48 8b 47 08          	mov    0x8(%rdi),%rax
ffffffff80000fab:	74 3b                	je     ffffffff80000fe8 <kfree+0x148>
		if ( l_bestBet == maj ) l_bestBet = NULL;
ffffffff80000fad:	48 39 cf             	cmp    %rcx,%rdi
ffffffff80000fb0:	74 46                	je     ffffffff80000ff8 <kfree+0x158>
		if ( maj->prev != NULL ) maj->prev->next = maj->next;
ffffffff80000fb2:	48 8b 17             	mov    (%rdi),%rdx
ffffffff80000fb5:	48 85 d2             	test   %rdx,%rdx
ffffffff80000fb8:	74 08                	je     ffffffff80000fc2 <kfree+0x122>
ffffffff80000fba:	48 89 42 08          	mov    %rax,0x8(%rdx)
ffffffff80000fbe:	48 8b 47 08          	mov    0x8(%rdi),%rax
		if ( maj->next != NULL ) maj->next->prev = maj->prev;
ffffffff80000fc2:	48 85 c0             	test   %rax,%rax
ffffffff80000fc5:	74 03                	je     ffffffff80000fca <kfree+0x12a>
ffffffff80000fc7:	48 89 10             	mov    %rdx,(%rax)
		liballoc_free( maj, maj->pages );
ffffffff80000fca:	8b 77 10             	mov    0x10(%rdi),%esi
		l_allocated -= maj->size;
ffffffff80000fcd:	8b 47 14             	mov    0x14(%rdi),%eax
ffffffff80000fd0:	48 29 05 19 d7 00 00 	sub    %rax,0xd719(%rip)        # ffffffff8000e6f0 <l_allocated>
		liballoc_free( maj, maj->pages );
ffffffff80000fd7:	e8 54 fa ff ff       	callq  ffffffff80000a30 <liballoc_free>
ffffffff80000fdc:	e9 17 ff ff ff       	jmpq   ffffffff80000ef8 <kfree+0x58>
ffffffff80000fe1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		if ( l_memRoot == maj ) l_memRoot = maj->next;
ffffffff80000fe8:	48 89 05 11 d7 00 00 	mov    %rax,0xd711(%rip)        # ffffffff8000e700 <l_memRoot>
ffffffff80000fef:	eb bc                	jmp    ffffffff80000fad <kfree+0x10d>
ffffffff80000ff1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
		if ( l_bestBet == maj ) l_bestBet = NULL;
ffffffff80000ff8:	48 c7 05 f5 d6 00 00 	movq   $0x0,0xd6f5(%rip)        # ffffffff8000e6f8 <l_bestBet>
ffffffff80000fff:	00 00 00 00 
ffffffff80001003:	eb ad                	jmp    ffffffff80000fb2 <kfree+0x112>
ffffffff80001005:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000100c:	00 00 00 00 

ffffffff80001010 <kcalloc>:
void* PREFIX(calloc)(size_t nobj, size_t size)
{
       int real_size;
       void *p;

       real_size = nobj * size;
ffffffff80001010:	0f af fe             	imul   %esi,%edi
{
ffffffff80001013:	53                   	push   %rbx
       
       p = PREFIX(malloc)( real_size );
ffffffff80001014:	48 63 df             	movslq %edi,%rbx
ffffffff80001017:	48 89 df             	mov    %rbx,%rdi
ffffffff8000101a:	e8 21 fb ff ff       	callq  ffffffff80000b40 <kmalloc>
	for ( i = 0; i < n ; i++)
ffffffff8000101f:	48 85 db             	test   %rbx,%rbx
ffffffff80001022:	74 1b                	je     ffffffff8000103f <kcalloc+0x2f>
ffffffff80001024:	31 c9                	xor    %ecx,%ecx
ffffffff80001026:	31 d2                	xor    %edx,%edx
ffffffff80001028:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000102f:	00 
		((char*)s)[i] = c;
ffffffff80001030:	c6 04 10 00          	movb   $0x0,(%rax,%rdx,1)
	for ( i = 0; i < n ; i++)
ffffffff80001034:	8d 51 01             	lea    0x1(%rcx),%edx
ffffffff80001037:	48 39 d3             	cmp    %rdx,%rbx
ffffffff8000103a:	48 89 d1             	mov    %rdx,%rcx
ffffffff8000103d:	77 f1                	ja     ffffffff80001030 <kcalloc+0x20>

       liballoc_memset( p, 0, real_size );

       return p;
}
ffffffff8000103f:	5b                   	pop    %rbx
ffffffff80001040:	c3                   	retq   
ffffffff80001041:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001048:	00 00 00 00 
ffffffff8000104c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001050 <krealloc>:



void*   PREFIX(realloc)(void *p, size_t size)
{
ffffffff80001050:	41 54                	push   %r12
ffffffff80001052:	55                   	push   %rbp
ffffffff80001053:	53                   	push   %rbx
ffffffff80001054:	48 89 fb             	mov    %rdi,%rbx
ffffffff80001057:	48 83 ec 10          	sub    $0x10,%rsp
	void *ptr;
	struct liballoc_minor *min;
	unsigned int real_size;
	
	// Honour the case of size == 0 => free old and return NULL
	if ( size == 0 )
ffffffff8000105b:	48 85 f6             	test   %rsi,%rsi
ffffffff8000105e:	0f 84 54 01 00 00    	je     ffffffff800011b8 <krealloc+0x168>
		PREFIX(free)( p );
		return NULL;
	}

	// In the case of a NULL pointer, return a simple malloc.
	if ( p == NULL ) return PREFIX(malloc)( size );
ffffffff80001064:	48 85 ff             	test   %rdi,%rdi
ffffffff80001067:	49 89 f4             	mov    %rsi,%r12
ffffffff8000106a:	0f 84 e0 00 00 00    	je     ffffffff80001150 <krealloc+0x100>

	// Unalign the pointer if required.
	ptr = p;
	UNALIGN(ptr);
ffffffff80001070:	48 0f be 47 f0       	movsbq -0x10(%rdi),%rax
ffffffff80001075:	48 89 fd             	mov    %rdi,%rbp
ffffffff80001078:	48 29 c5             	sub    %rax,%rbp
ffffffff8000107b:	48 83 f8 20          	cmp    $0x20,%rax
ffffffff8000107f:	48 0f 43 ef          	cmovae %rdi,%rbp

	liballoc_lock();		// lockit
ffffffff80001083:	31 c0                	xor    %eax,%eax
ffffffff80001085:	e8 86 f9 ff ff       	callq  ffffffff80000a10 <liballoc_lock>

		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));

		// Ensure it is a valid structure.
		if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff8000108a:	8b 45 f0             	mov    -0x10(%rbp),%eax
		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
ffffffff8000108d:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
		if ( min->magic != LIBALLOC_MAGIC ) 
ffffffff80001091:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
ffffffff80001096:	0f 85 c4 00 00 00    	jne    ffffffff80001160 <krealloc+0x110>
		
		// Definitely a memory block.
		
		real_size = min->req_size;

		if ( real_size >= size ) 
ffffffff8000109c:	8b 6d f8             	mov    -0x8(%rbp),%ebp
ffffffff8000109f:	4c 39 e5             	cmp    %r12,%rbp
ffffffff800010a2:	0f 83 90 00 00 00    	jae    ffffffff80001138 <krealloc+0xe8>
			min->req_size = size;
			liballoc_unlock();
			return p;
		}

	liballoc_unlock();
ffffffff800010a8:	31 c0                	xor    %eax,%eax
ffffffff800010aa:	e8 71 f9 ff ff       	callq  ffffffff80000a20 <liballoc_unlock>

	// If we got here then we're reallocating to a block bigger than us.
	ptr = PREFIX(malloc)( size );					// We need to allocate new memory
ffffffff800010af:	4c 89 e7             	mov    %r12,%rdi
ffffffff800010b2:	e8 89 fa ff ff       	callq  ffffffff80000b40 <kmalloc>
  while ( n >= sizeof(unsigned int) )
ffffffff800010b7:	48 83 fd 03          	cmp    $0x3,%rbp
ffffffff800010bb:	0f 86 e7 00 00 00    	jbe    ffffffff800011a8 <krealloc+0x158>
ffffffff800010c1:	48 83 ed 04          	sub    $0x4,%rbp
ffffffff800010c5:	31 d2                	xor    %edx,%edx
ffffffff800010c7:	48 89 ef             	mov    %rbp,%rdi
ffffffff800010ca:	48 c1 ef 02          	shr    $0x2,%rdi
ffffffff800010ce:	48 8d 34 bd 04 00 00 	lea    0x4(,%rdi,4),%rsi
ffffffff800010d5:	00 
ffffffff800010d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800010dd:	00 00 00 
      *ldest++ = *lsrc++;
ffffffff800010e0:	8b 0c 13             	mov    (%rbx,%rdx,1),%ecx
ffffffff800010e3:	89 0c 10             	mov    %ecx,(%rax,%rdx,1)
ffffffff800010e6:	48 83 c2 04          	add    $0x4,%rdx
  while ( n >= sizeof(unsigned int) )
ffffffff800010ea:	48 39 f2             	cmp    %rsi,%rdx
ffffffff800010ed:	75 f1                	jne    ffffffff800010e0 <krealloc+0x90>
ffffffff800010ef:	48 f7 df             	neg    %rdi
ffffffff800010f2:	4c 8d 04 13          	lea    (%rbx,%rdx,1),%r8
ffffffff800010f6:	48 01 c2             	add    %rax,%rdx
ffffffff800010f9:	48 8d 6c bd 00       	lea    0x0(%rbp,%rdi,4),%rbp
  while ( n > 0 )
ffffffff800010fe:	48 85 ed             	test   %rbp,%rbp
ffffffff80001101:	74 14                	je     ffffffff80001117 <krealloc+0xc7>
ffffffff80001103:	31 c9                	xor    %ecx,%ecx
      *cdest++ = *csrc++;
ffffffff80001105:	41 0f b6 34 08       	movzbl (%r8,%rcx,1),%esi
ffffffff8000110a:	40 88 34 0a          	mov    %sil,(%rdx,%rcx,1)
ffffffff8000110e:	48 83 c1 01          	add    $0x1,%rcx
  while ( n > 0 )
ffffffff80001112:	48 39 e9             	cmp    %rbp,%rcx
ffffffff80001115:	75 ee                	jne    ffffffff80001105 <krealloc+0xb5>
	liballoc_memcpy( ptr, p, real_size );
	PREFIX(free)( p );
ffffffff80001117:	48 89 df             	mov    %rbx,%rdi
ffffffff8000111a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff8000111f:	e8 7c fd ff ff       	callq  ffffffff80000ea0 <kfree>
ffffffff80001124:	48 8b 44 24 08       	mov    0x8(%rsp),%rax

	return ptr;
}
ffffffff80001129:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8000112d:	5b                   	pop    %rbx
ffffffff8000112e:	5d                   	pop    %rbp
ffffffff8000112f:	41 5c                	pop    %r12
ffffffff80001131:	c3                   	retq   
ffffffff80001132:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			min->req_size = size;
ffffffff80001138:	44 89 62 20          	mov    %r12d,0x20(%rdx)
			liballoc_unlock();
ffffffff8000113c:	31 c0                	xor    %eax,%eax
ffffffff8000113e:	e8 dd f8 ff ff       	callq  ffffffff80000a20 <liballoc_unlock>
			return p;
ffffffff80001143:	48 89 d8             	mov    %rbx,%rax
}
ffffffff80001146:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8000114a:	5b                   	pop    %rbx
ffffffff8000114b:	5d                   	pop    %rbp
ffffffff8000114c:	41 5c                	pop    %r12
ffffffff8000114e:	c3                   	retq   
ffffffff8000114f:	90                   	nop
ffffffff80001150:	48 83 c4 10          	add    $0x10,%rsp
	if ( p == NULL ) return PREFIX(malloc)( size );
ffffffff80001154:	48 89 f7             	mov    %rsi,%rdi
}
ffffffff80001157:	5b                   	pop    %rbx
ffffffff80001158:	5d                   	pop    %rbp
ffffffff80001159:	41 5c                	pop    %r12
	if ( p == NULL ) return PREFIX(malloc)( size );
ffffffff8000115b:	e9 e0 f9 ff ff       	jmpq   ffffffff80000b40 <kmalloc>
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80001160:	89 c2                	mov    %eax,%edx
			l_errorCount += 1;
ffffffff80001162:	48 83 05 6e d5 00 00 	addq   $0x1,0xd56e(%rip)        # ffffffff8000e6d8 <l_errorCount>
ffffffff80001169:	01 
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff8000116a:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
			if ( 
ffffffff80001170:	81 fa de c0 01 00    	cmp    $0x1c0de,%edx
ffffffff80001176:	74 20                	je     ffffffff80001198 <krealloc+0x148>
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
ffffffff80001178:	66 3d de c0          	cmp    $0xc0de,%ax
ffffffff8000117c:	74 1a                	je     ffffffff80001198 <krealloc+0x148>
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
ffffffff8000117e:	3c de                	cmp    $0xde,%al
ffffffff80001180:	74 16                	je     ffffffff80001198 <krealloc+0x148>
			liballoc_unlock();		// release the lock
ffffffff80001182:	31 c0                	xor    %eax,%eax
ffffffff80001184:	e8 97 f8 ff ff       	callq  ffffffff80000a20 <liballoc_unlock>
}
ffffffff80001189:	48 83 c4 10          	add    $0x10,%rsp
			return NULL;
ffffffff8000118d:	31 c0                	xor    %eax,%eax
}
ffffffff8000118f:	5b                   	pop    %rbx
ffffffff80001190:	5d                   	pop    %rbp
ffffffff80001191:	41 5c                	pop    %r12
ffffffff80001193:	c3                   	retq   
ffffffff80001194:	0f 1f 40 00          	nopl   0x0(%rax)
				l_possibleOverruns += 1;
ffffffff80001198:	48 83 05 30 d5 00 00 	addq   $0x1,0xd530(%rip)        # ffffffff8000e6d0 <l_possibleOverruns>
ffffffff8000119f:	01 
ffffffff800011a0:	eb e0                	jmp    ffffffff80001182 <krealloc+0x132>
ffffffff800011a2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	ptr = PREFIX(malloc)( size );					// We need to allocate new memory
ffffffff800011a8:	48 89 c2             	mov    %rax,%rdx
  while ( n >= sizeof(unsigned int) )
ffffffff800011ab:	49 89 d8             	mov    %rbx,%r8
ffffffff800011ae:	e9 4b ff ff ff       	jmpq   ffffffff800010fe <krealloc+0xae>
ffffffff800011b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		PREFIX(free)( p );
ffffffff800011b8:	e8 e3 fc ff ff       	callq  ffffffff80000ea0 <kfree>
		return NULL;
ffffffff800011bd:	31 c0                	xor    %eax,%eax
ffffffff800011bf:	eb 85                	jmp    ffffffff80001146 <krealloc+0xf6>
ffffffff800011c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800011c8:	00 00 00 
ffffffff800011cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff800011d0 <pmm_init>:

//Initialize the Physical Memory Manager
void pmm_init()
{
    //memory map helper variables
    uint64_t mmap_entries = boot_info.tag_memmap->entries;
ffffffff800011d0:	48 8b 05 99 90 00 00 	mov    0x9099(%rip),%rax        # ffffffff8000a270 <boot_info+0x10>
ffffffff800011d7:	48 8b 35 42 d5 00 00 	mov    0xd542(%rip),%rsi        # ffffffff8000e720 <pmm_info>
ffffffff800011de:	4c 8b 58 10          	mov    0x10(%rax),%r11
    uint64_t mmap_largest_segment_base = 0;     //Address of the largest segment
    uint64_t mmap_largest_segment_size = 0;     //Size of the largest segment
    //uint8_t* type = NULL;

    //iterate through the memory map, find the largest memory segment, calculate total memory size
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800011e2:	4d 85 db             	test   %r11,%r11
ffffffff800011e5:	0f 84 c5 00 00 00    	je     ffffffff800012b0 <pmm_init+0xe0>
{
ffffffff800011eb:	41 56                	push   %r14
ffffffff800011ed:	4c 8b 05 e4 90 00 00 	mov    0x90e4(%rip),%r8        # ffffffff8000a2d8 <pmm_vmm_info+0x8>
ffffffff800011f4:	48 83 c0 18          	add    $0x18,%rax
ffffffff800011f8:	55                   	push   %rbp
ffffffff800011f9:	48 8b 3d e0 90 00 00 	mov    0x90e0(%rip),%rdi        # ffffffff8000a2e0 <pmm_vmm_info+0x10>
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80001200:	45 31 c9             	xor    %r9d,%r9d
{
ffffffff80001203:	53                   	push   %rbx
    uint64_t mmap_largest_segment_size = 0;     //Size of the largest segment
ffffffff80001204:	45 31 d2             	xor    %r10d,%r10d
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80001207:	31 db                	xor    %ebx,%ebx
    uint64_t mmap_largest_segment_base = 0;     //Address of the largest segment
ffffffff80001209:	31 c9                	xor    %ecx,%ecx
ffffffff8000120b:	eb 20                	jmp    ffffffff8000122d <pmm_init+0x5d>
ffffffff8000120d:	0f 1f 00             	nopl   (%rax)
        {
            continue;
        }

        //Capture the largest segment size
        if(current_entry->length > mmap_largest_segment_size)
ffffffff80001210:	4c 39 d2             	cmp    %r10,%rdx
ffffffff80001213:	76 0b                	jbe    ffffffff80001220 <pmm_init+0x50>
ffffffff80001215:	83 fd 01             	cmp    $0x1,%ebp
ffffffff80001218:	75 06                	jne    ffffffff80001220 <pmm_init+0x50>
        {
            mmap_largest_segment_base = current_entry->base;
ffffffff8000121a:	48 8b 08             	mov    (%rax),%rcx
ffffffff8000121d:	49 89 d2             	mov    %rdx,%r10
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80001220:	48 83 c3 01          	add    $0x1,%rbx
ffffffff80001224:	48 83 c0 18          	add    $0x18,%rax
ffffffff80001228:	49 39 db             	cmp    %rbx,%r11
ffffffff8000122b:	74 2b                	je     ffffffff80001258 <pmm_init+0x88>
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff8000122d:	48 8b 50 08          	mov    0x8(%rax),%rdx
        if(current_entry->type == 0x1002)
ffffffff80001231:	8b 68 10             	mov    0x10(%rax),%ebp
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff80001234:	48 01 d6             	add    %rdx,%rsi
        if(current_entry->type == 0x1002)
ffffffff80001237:	81 fd 02 10 00 00    	cmp    $0x1002,%ebp
ffffffff8000123d:	75 d1                	jne    ffffffff80001210 <pmm_init+0x40>
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff8000123f:	48 83 c3 01          	add    $0x1,%rbx
            pmm_vmm_info.fb_base = current_entry->base;
ffffffff80001243:	4c 8b 00             	mov    (%rax),%r8
ffffffff80001246:	48 83 c0 18          	add    $0x18,%rax
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff8000124a:	49 39 db             	cmp    %rbx,%r11
        pmm_info.totalmem = pmm_info.totalmem + current_entry->length;
ffffffff8000124d:	48 89 d7             	mov    %rdx,%rdi
            pmm_vmm_info.fb_base = current_entry->base;
ffffffff80001250:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80001256:	75 d5                	jne    ffffffff8000122d <pmm_init+0x5d>
ffffffff80001258:	45 84 c9             	test   %r9b,%r9b
ffffffff8000125b:	48 89 35 be d4 00 00 	mov    %rsi,0xd4be(%rip)        # ffffffff8000e720 <pmm_info>
ffffffff80001262:	74 0e                	je     ffffffff80001272 <pmm_init+0xa2>
ffffffff80001264:	4c 89 05 6d 90 00 00 	mov    %r8,0x906d(%rip)        # ffffffff8000a2d8 <pmm_vmm_info+0x8>
ffffffff8000126b:	48 89 3d 6e 90 00 00 	mov    %rdi,0x906e(%rip)        # ffffffff8000a2e0 <pmm_vmm_info+0x10>
            mmap_largest_segment_size = current_entry->length;
        }
    };

    //Populate the PMM state variables
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff80001272:	48 89 f0             	mov    %rsi,%rax
ffffffff80001275:	48 c1 e8 0c          	shr    $0xc,%rax
ffffffff80001279:	48 89 05 b0 d4 00 00 	mov    %rax,0xd4b0(%rip)        # ffffffff8000e730 <pmm_info+0x10>
    pmm_info.usedpages = pmm_info.totalpages;
ffffffff80001280:	48 89 05 a1 d4 00 00 	mov    %rax,0xd4a1(%rip)        # ffffffff8000e728 <pmm_info+0x8>
    pmm_info.bitmap_size = (pmm_info.totalpages / 8) + 1;
ffffffff80001287:	48 89 f0             	mov    %rsi,%rax
ffffffff8000128a:	48 c1 e8 0f          	shr    $0xf,%rax
ffffffff8000128e:	48 83 c0 01          	add    $0x1,%rax
    
    if(pmm_info.bitmap_size > current_entry->length) 
ffffffff80001292:	48 39 c2             	cmp    %rax,%rdx
    pmm_info.bitmap_size = (pmm_info.totalpages / 8) + 1;
ffffffff80001295:	48 89 05 a4 d4 00 00 	mov    %rax,0xd4a4(%rip)        # ffffffff8000e740 <pmm_info+0x20>
    if(pmm_info.bitmap_size > current_entry->length) 
ffffffff8000129c:	73 4a                	jae    ffffffff800012e8 <pmm_init+0x118>
        {
            printf("Bitmap too large");
ffffffff8000129e:	48 c7 c7 ba 49 00 80 	mov    $0xffffffff800049ba,%rdi
ffffffff800012a5:	31 c0                	xor    %eax,%eax
ffffffff800012a7:	e8 44 1f 00 00       	callq  ffffffff800031f0 <printf_>
ffffffff800012ac:	eb fe                	jmp    ffffffff800012ac <pmm_init+0xdc>
ffffffff800012ae:	66 90                	xchg   %ax,%ax
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff800012b0:	48 89 f0             	mov    %rsi,%rax
ffffffff800012b3:	48 c1 e8 0c          	shr    $0xc,%rax
    pmm_info.usedpages = pmm_info.totalpages;
ffffffff800012b7:	48 89 05 6a d4 00 00 	mov    %rax,0xd46a(%rip)        # ffffffff8000e728 <pmm_info+0x8>
    pmm_info.totalpages = pmm_info.totalmem / 4096;
ffffffff800012be:	48 89 05 6b d4 00 00 	mov    %rax,0xd46b(%rip)        # ffffffff8000e730 <pmm_info+0x10>
    pmm_info.bitmap_size = (pmm_info.totalpages / 8) + 1;
ffffffff800012c5:	48 89 f0             	mov    %rsi,%rax
ffffffff800012c8:	48 c1 e8 0f          	shr    $0xf,%rax
ffffffff800012cc:	48 83 c0 01          	add    $0x1,%rax
ffffffff800012d0:	48 89 05 69 d4 00 00 	mov    %rax,0xd469(%rip)        # ffffffff8000e740 <pmm_info+0x20>
    if(pmm_info.bitmap_size > current_entry->length) 
ffffffff800012d7:	48 8b 04 25 08 00 00 	mov    0x8,%rax
ffffffff800012de:	00 
ffffffff800012df:	0f 0b                	ud2    
ffffffff800012e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    return 0xFFFF800000000000 + addr;
ffffffff800012e8:	48 b8 00 00 00 00 00 	movabs $0xffff800000000000,%rax
ffffffff800012ef:	80 ff ff 
            for(;;){}   //hang
        }
    
    pmm_info.bitmap = (uint8_t*)phys_to_hh_data(mmap_largest_segment_base); 

    printf("Total Memory: %d\n", (pmm_info.totalmem));
ffffffff800012f2:	48 c7 c7 cb 49 00 80 	mov    $0xffffffff800049cb,%rdi
ffffffff800012f9:	48 01 c1             	add    %rax,%rcx
ffffffff800012fc:	31 c0                	xor    %eax,%eax
ffffffff800012fe:	48 89 0d 33 d4 00 00 	mov    %rcx,0xd433(%rip)        # ffffffff8000e738 <pmm_info+0x18>
ffffffff80001305:	e8 e6 1e 00 00       	callq  ffffffff800031f0 <printf_>
    printf("Total Pages: %d   Used Pages: %d\n", pmm_info.totalpages, pmm_info.usedpages);
ffffffff8000130a:	48 8b 15 17 d4 00 00 	mov    0xd417(%rip),%rdx        # ffffffff8000e728 <pmm_info+0x8>
ffffffff80001311:	48 8b 35 18 d4 00 00 	mov    0xd418(%rip),%rsi        # ffffffff8000e730 <pmm_info+0x10>
ffffffff80001318:	48 c7 c7 08 4a 00 80 	mov    $0xffffffff80004a08,%rdi
ffffffff8000131f:	31 c0                	xor    %eax,%eax
ffffffff80001321:	e8 ca 1e 00 00       	callq  ffffffff800031f0 <printf_>
    printf("Bitmap Addr: %p  Bitmap Size (bytes): %d\n", pmm_info.bitmap, pmm_info.bitmap_size);
ffffffff80001326:	48 8b 35 0b d4 00 00 	mov    0xd40b(%rip),%rsi        # ffffffff8000e738 <pmm_info+0x18>
ffffffff8000132d:	48 8b 15 0c d4 00 00 	mov    0xd40c(%rip),%rdx        # ffffffff8000e740 <pmm_info+0x20>
ffffffff80001334:	31 c0                	xor    %eax,%eax
ffffffff80001336:	48 c7 c7 30 4a 00 80 	mov    $0xffffffff80004a30,%rdi
ffffffff8000133d:	e8 ae 1e 00 00       	callq  ffffffff800031f0 <printf_>

    //Set all bitmap bits to 1
    for (uint64_t i = 0; i < pmm_info.bitmap_size; i++)
ffffffff80001342:	48 8b 05 f7 d3 00 00 	mov    0xd3f7(%rip),%rax        # ffffffff8000e740 <pmm_info+0x20>
        {
        pmm_info.bitmap[i] = 0xff;
ffffffff80001349:	48 8b 35 e8 d3 00 00 	mov    0xd3e8(%rip),%rsi        # ffffffff8000e738 <pmm_info+0x18>
    for (uint64_t i = 0; i < pmm_info.bitmap_size; i++)
ffffffff80001350:	48 85 c0             	test   %rax,%rax
ffffffff80001353:	74 17                	je     ffffffff8000136c <pmm_init+0x19c>
ffffffff80001355:	48 89 f2             	mov    %rsi,%rdx
ffffffff80001358:	48 01 f0             	add    %rsi,%rax
ffffffff8000135b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        pmm_info.bitmap[i] = 0xff;
ffffffff80001360:	c6 02 ff             	movb   $0xff,(%rdx)
ffffffff80001363:	48 83 c2 01          	add    $0x1,%rdx
    for (uint64_t i = 0; i < pmm_info.bitmap_size; i++)
ffffffff80001367:	48 39 c2             	cmp    %rax,%rdx
ffffffff8000136a:	75 f4                	jne    ffffffff80001360 <pmm_init+0x190>
ffffffff8000136c:	4c 8b 0d b5 d3 00 00 	mov    0xd3b5(%rip),%r9        # ffffffff8000e728 <pmm_info+0x8>
            mmap_largest_segment_base = current_entry->base;
ffffffff80001373:	31 c9                	xor    %ecx,%ecx
    

    //printf("Number of MMAP Entries: %d\n", mmap_entries);

    //Iterate through the memory map again, unset bitmap for available memory
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80001375:	31 ff                	xor    %edi,%edi
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff80001377:	41 ba 01 00 00 00    	mov    $0x1,%r10d
            mmap_largest_segment_base = current_entry->base;
ffffffff8000137d:	4c 89 c8             	mov    %r9,%rax
ffffffff80001380:	eb 0f                	jmp    ffffffff80001391 <pmm_init+0x1c1>
ffffffff80001382:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff80001388:	48 83 c7 01          	add    $0x1,%rdi
ffffffff8000138c:	48 39 df             	cmp    %rbx,%rdi
ffffffff8000138f:	74 64                	je     ffffffff800013f5 <pmm_init+0x225>
    {
        current_entry = &boot_info.tag_memmap->memmap[i];

        if(current_entry->type == 1)
ffffffff80001391:	4c 8b 05 d8 8e 00 00 	mov    0x8ed8(%rip),%r8        # ffffffff8000a270 <boot_info+0x10>
ffffffff80001398:	48 8d 14 7f          	lea    (%rdi,%rdi,2),%rdx
ffffffff8000139c:	49 8d 14 d0          	lea    (%r8,%rdx,8),%rdx
ffffffff800013a0:	83 7a 28 01          	cmpl   $0x1,0x28(%rdx)
ffffffff800013a4:	75 e2                	jne    ffffffff80001388 <pmm_init+0x1b8>
        {
            uint64_t pages = current_entry->length / 4096;
ffffffff800013a6:	4c 8b 42 20          	mov    0x20(%rdx),%r8
            uint64_t align = current_entry->base / 4096;
ffffffff800013aa:	48 8b 52 18          	mov    0x18(%rdx),%rdx
            uint64_t pages = current_entry->length / 4096;
ffffffff800013ae:	49 c1 e8 0c          	shr    $0xc,%r8
            uint64_t align = current_entry->base / 4096;
ffffffff800013b2:	48 c1 ea 0c          	shr    $0xc,%rdx
            //printf("Index: %d  Pages: %d\n", align, pages);

            for(uint64_t j = 0; j < pages; j++)
ffffffff800013b6:	4d 85 c0             	test   %r8,%r8
ffffffff800013b9:	74 cd                	je     ffffffff80001388 <pmm_init+0x1b8>
ffffffff800013bb:	49 8d 2c 10          	lea    (%r8,%rdx,1),%rbp
ffffffff800013bf:	90                   	nop
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800013c0:	89 d1                	mov    %edx,%ecx
ffffffff800013c2:	45 89 d6             	mov    %r10d,%r14d
ffffffff800013c5:	49 89 d3             	mov    %rdx,%r11
ffffffff800013c8:	83 e1 07             	and    $0x7,%ecx
ffffffff800013cb:	49 c1 eb 03          	shr    $0x3,%r11
                //uint64_t bitindex = align % 8;
                //pmm_info.bitmap[byteindex] &= ~(1 << bitindex);
                
                bitmap_unset(pmm_info.bitmap, align);

                align++;                    //increment page index
ffffffff800013cf:	48 83 c2 01          	add    $0x1,%rdx
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800013d3:	41 d3 e6             	shl    %cl,%r14d
ffffffff800013d6:	44 89 f1             	mov    %r14d,%ecx
ffffffff800013d9:	f7 d1                	not    %ecx
ffffffff800013db:	42 20 0c 1e          	and    %cl,(%rsi,%r11,1)
            for(uint64_t j = 0; j < pages; j++)
ffffffff800013df:	48 39 ea             	cmp    %rbp,%rdx
ffffffff800013e2:	75 dc                	jne    ffffffff800013c0 <pmm_init+0x1f0>
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800013e4:	48 83 c7 01          	add    $0x1,%rdi
ffffffff800013e8:	4c 29 c0             	sub    %r8,%rax
            for(uint64_t j = 0; j < pages; j++)
ffffffff800013eb:	b9 01 00 00 00       	mov    $0x1,%ecx
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800013f0:	48 39 df             	cmp    %rbx,%rdi
ffffffff800013f3:	75 9c                	jne    ffffffff80001391 <pmm_init+0x1c1>
ffffffff800013f5:	84 c9                	test   %cl,%cl

    //Make certain the NULL page is unavailable
    bitmap_set(pmm_info.bitmap, 0);
    pmm_info.usedpages++;

    printf("Available Pages: %d\n", (pmm_info.totalpages - pmm_info.usedpages));
ffffffff800013f7:	48 c7 c7 dd 49 00 80 	mov    $0xffffffff800049dd,%rdi
    for (uint64_t i = 0; i < mmap_entries; i++)
ffffffff800013fe:	49 0f 44 c1          	cmove  %r9,%rax
    bitmap[bit / 8] |= (1 << (bit % 8));
ffffffff80001402:	80 0e 01             	orb    $0x1,(%rsi)
    printf("Available Pages: %d\n", (pmm_info.totalpages - pmm_info.usedpages));
ffffffff80001405:	48 8b 35 24 d3 00 00 	mov    0xd324(%rip),%rsi        # ffffffff8000e730 <pmm_info+0x10>
    pmm_info.usedpages++;
ffffffff8000140c:	48 83 c0 01          	add    $0x1,%rax
ffffffff80001410:	48 89 05 11 d3 00 00 	mov    %rax,0xd311(%rip)        # ffffffff8000e728 <pmm_info+0x8>
    printf("Available Pages: %d\n", (pmm_info.totalpages - pmm_info.usedpages));
ffffffff80001417:	48 29 c6             	sub    %rax,%rsi
ffffffff8000141a:	31 c0                	xor    %eax,%eax
ffffffff8000141c:	e8 cf 1d 00 00       	callq  ffffffff800031f0 <printf_>
    printf("PMM Initialized\n");

}
ffffffff80001421:	5b                   	pop    %rbx
ffffffff80001422:	5d                   	pop    %rbp
ffffffff80001423:	41 5e                	pop    %r14
    printf("PMM Initialized\n");
ffffffff80001425:	48 c7 c7 f2 49 00 80 	mov    $0xffffffff800049f2,%rdi
ffffffff8000142c:	31 c0                	xor    %eax,%eax
ffffffff8000142e:	e9 bd 1d 00 00       	jmpq   ffffffff800031f0 <printf_>
ffffffff80001433:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000143a:	00 00 00 00 
ffffffff8000143e:	66 90                	xchg   %ax,%ax

ffffffff80001440 <pmm_allocpage>:


void* pmm_allocpage()
{
    if(pmm_info.usedpages >= pmm_info.totalpages)
ffffffff80001440:	48 8b 35 e1 d2 00 00 	mov    0xd2e1(%rip),%rsi        # ffffffff8000e728 <pmm_info+0x8>
ffffffff80001447:	48 3b 35 e2 d2 00 00 	cmp    0xd2e2(%rip),%rsi        # ffffffff8000e730 <pmm_info+0x10>
ffffffff8000144e:	73 68                	jae    ffffffff800014b8 <pmm_allocpage+0x78>
        return NULL;
    
    uint64_t index = get_first_unset(pmm_info.bitmap, pmm_info.bitmap_size);
ffffffff80001450:	48 8b 3d e9 d2 00 00 	mov    0xd2e9(%rip),%rdi        # ffffffff8000e740 <pmm_info+0x20>
ffffffff80001457:	4c 8b 05 da d2 00 00 	mov    0xd2da(%rip),%r8        # ffffffff8000e738 <pmm_info+0x18>
    for(uint64_t i = 0; i < size; i++)
ffffffff8000145e:	48 85 ff             	test   %rdi,%rdi
ffffffff80001461:	74 26                	je     ffffffff80001489 <pmm_allocpage+0x49>
ffffffff80001463:	31 c9                	xor    %ecx,%ecx
        if(bitmap[i] != 0xff)
ffffffff80001465:	41 0f b6 14 08       	movzbl (%r8,%rcx,1),%edx
ffffffff8000146a:	80 fa ff             	cmp    $0xff,%dl
ffffffff8000146d:	74 11                	je     ffffffff80001480 <pmm_allocpage+0x40>
            for(uint64_t j = 0; j < 8; j++)
ffffffff8000146f:	31 c0                	xor    %eax,%eax
                if(!(bitmap[i] & (1 << j)))
ffffffff80001471:	0f a3 c2             	bt     %eax,%edx
ffffffff80001474:	73 2a                	jae    ffffffff800014a0 <pmm_allocpage+0x60>
            for(uint64_t j = 0; j < 8; j++)
ffffffff80001476:	48 83 c0 01          	add    $0x1,%rax
ffffffff8000147a:	48 83 f8 08          	cmp    $0x8,%rax
ffffffff8000147e:	75 f1                	jne    ffffffff80001471 <pmm_allocpage+0x31>
    for(uint64_t i = 0; i < size; i++)
ffffffff80001480:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80001484:	48 39 cf             	cmp    %rcx,%rdi
ffffffff80001487:	75 dc                	jne    ffffffff80001465 <pmm_allocpage+0x25>

    pmm_info.usedpages++;
ffffffff80001489:	48 83 c6 01          	add    $0x1,%rsi
    for(uint64_t i = 0; i < size; i++)
ffffffff8000148d:	31 c0                	xor    %eax,%eax
    pmm_info.usedpages++;
ffffffff8000148f:	48 89 35 92 d2 00 00 	mov    %rsi,0xd292(%rip)        # ffffffff8000e728 <pmm_info+0x8>

    return (void*)(index * PAGE_SIZE);
ffffffff80001496:	c3                   	retq   
ffffffff80001497:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000149e:	00 00 
                    return (i * 8) + j;
ffffffff800014a0:	48 8d 04 c8          	lea    (%rax,%rcx,8),%rax
    pmm_info.usedpages++;
ffffffff800014a4:	48 83 c6 01          	add    $0x1,%rsi
ffffffff800014a8:	48 89 35 79 d2 00 00 	mov    %rsi,0xd279(%rip)        # ffffffff8000e728 <pmm_info+0x8>
ffffffff800014af:	48 c1 e0 0c          	shl    $0xc,%rax
    return (void*)(index * PAGE_SIZE);
ffffffff800014b3:	c3                   	retq   
ffffffff800014b4:	0f 1f 40 00          	nopl   0x0(%rax)
        return NULL;
ffffffff800014b8:	31 c0                	xor    %eax,%eax
}
ffffffff800014ba:	c3                   	retq   
ffffffff800014bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff800014c0 <pmm_freepage>:
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800014c0:	48 89 fa             	mov    %rdi,%rdx


void pmm_freepage(void* page)
{
    uint64_t index = (uint64_t)page / PAGE_SIZE;
ffffffff800014c3:	48 c1 ef 0c          	shr    $0xc,%rdi
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800014c7:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff800014cc:	48 c1 ea 0f          	shr    $0xf,%rdx
ffffffff800014d0:	48 03 15 61 d2 00 00 	add    0xd261(%rip),%rdx        # ffffffff8000e738 <pmm_info+0x18>
ffffffff800014d7:	89 f9                	mov    %edi,%ecx
ffffffff800014d9:	83 e1 07             	and    $0x7,%ecx
    bitmap_unset(pmm_info.bitmap, index);
    pmm_info.usedpages--;
ffffffff800014dc:	48 83 2d 44 d2 00 00 	subq   $0x1,0xd244(%rip)        # ffffffff8000e728 <pmm_info+0x8>
ffffffff800014e3:	01 
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800014e4:	d3 e0                	shl    %cl,%eax
ffffffff800014e6:	f7 d0                	not    %eax
ffffffff800014e8:	20 02                	and    %al,(%rdx)
}
ffffffff800014ea:	c3                   	retq   
ffffffff800014eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff800014f0 <pmm_allocpages>:

void* pmm_allocpages(uint64_t count)
{
    if(pmm_info.usedpages >= pmm_info.totalpages)
ffffffff800014f0:	4c 8b 15 31 d2 00 00 	mov    0xd231(%rip),%r10        # ffffffff8000e728 <pmm_info+0x8>
ffffffff800014f7:	4c 3b 15 32 d2 00 00 	cmp    0xd232(%rip),%r10        # ffffffff8000e730 <pmm_info+0x10>
ffffffff800014fe:	73 73                	jae    ffffffff80001573 <pmm_allocpages+0x83>
        return NULL;
    
    uint64_t index = get_first_unset(pmm_info.bitmap, pmm_info.bitmap_size);
ffffffff80001500:	48 8b 05 39 d2 00 00 	mov    0xd239(%rip),%rax        # ffffffff8000e740 <pmm_info+0x20>
ffffffff80001507:	4c 8b 05 2a d2 00 00 	mov    0xd22a(%rip),%r8        # ffffffff8000e738 <pmm_info+0x18>
    for(uint64_t i = 0; i < size; i++)
ffffffff8000150e:	48 85 c0             	test   %rax,%rax
ffffffff80001511:	74 28                	je     ffffffff8000153b <pmm_allocpages+0x4b>
ffffffff80001513:	31 f6                	xor    %esi,%esi
        if(bitmap[i] != 0xff)
ffffffff80001515:	41 0f b6 0c 30       	movzbl (%r8,%rsi,1),%ecx
ffffffff8000151a:	80 f9 ff             	cmp    $0xff,%cl
ffffffff8000151d:	74 11                	je     ffffffff80001530 <pmm_allocpages+0x40>
            for(uint64_t j = 0; j < 8; j++)
ffffffff8000151f:	31 d2                	xor    %edx,%edx
                if(!(bitmap[i] & (1 << j)))
ffffffff80001521:	0f a3 d1             	bt     %edx,%ecx
ffffffff80001524:	73 5a                	jae    ffffffff80001580 <pmm_allocpages+0x90>
            for(uint64_t j = 0; j < 8; j++)
ffffffff80001526:	48 83 c2 01          	add    $0x1,%rdx
ffffffff8000152a:	48 83 fa 08          	cmp    $0x8,%rdx
ffffffff8000152e:	75 f1                	jne    ffffffff80001521 <pmm_allocpages+0x31>
    for(uint64_t i = 0; i < size; i++)
ffffffff80001530:	48 83 c6 01          	add    $0x1,%rsi
ffffffff80001534:	48 39 f0             	cmp    %rsi,%rax
ffffffff80001537:	75 dc                	jne    ffffffff80001515 <pmm_allocpages+0x25>
    return 0;
ffffffff80001539:	31 c0                	xor    %eax,%eax
    for(uint64_t i = 0; i < count; i++)
ffffffff8000153b:	48 85 ff             	test   %rdi,%rdi
ffffffff8000153e:	74 50                	je     ffffffff80001590 <pmm_allocpages+0xa0>
ffffffff80001540:	31 d2                	xor    %edx,%edx
    {
        if(bitmap_get(pmm_info.bitmap, i) == 1)
ffffffff80001542:	41 f6 00 01          	testb  $0x1,(%r8)
    return bitmap[bit/8] & (1 << (bit & 8));
ffffffff80001546:	41 b9 01 00 00 00    	mov    $0x1,%r9d
        if(bitmap_get(pmm_info.bitmap, i) == 1)
ffffffff8000154c:	74 25                	je     ffffffff80001573 <pmm_allocpages+0x83>
    for(uint64_t i = 0; i < count; i++)
ffffffff8000154e:	48 83 c2 01          	add    $0x1,%rdx
ffffffff80001552:	48 39 d7             	cmp    %rdx,%rdi
ffffffff80001555:	74 39                	je     ffffffff80001590 <pmm_allocpages+0xa0>
    return bitmap[bit/8] & (1 << (bit & 8));
ffffffff80001557:	48 89 d1             	mov    %rdx,%rcx
ffffffff8000155a:	45 89 cb             	mov    %r9d,%r11d
ffffffff8000155d:	48 c1 e9 03          	shr    $0x3,%rcx
ffffffff80001561:	41 0f b6 34 08       	movzbl (%r8,%rcx,1),%esi
ffffffff80001566:	89 d1                	mov    %edx,%ecx
ffffffff80001568:	83 e1 08             	and    $0x8,%ecx
ffffffff8000156b:	41 d3 e3             	shl    %cl,%r11d
        if(bitmap_get(pmm_info.bitmap, i) == 1)
ffffffff8000156e:	44 85 de             	test   %r11d,%esi
ffffffff80001571:	75 db                	jne    ffffffff8000154e <pmm_allocpages+0x5e>
        return NULL;
ffffffff80001573:	31 c0                	xor    %eax,%eax
    }

    pmm_info.usedpages += count;

    return (void*)(index * PAGE_SIZE);
}
ffffffff80001575:	c3                   	retq   
ffffffff80001576:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000157d:	00 00 00 
                    return (i * 8) + j;
ffffffff80001580:	48 8d 04 f2          	lea    (%rdx,%rsi,8),%rax
ffffffff80001584:	eb b5                	jmp    ffffffff8000153b <pmm_allocpages+0x4b>
ffffffff80001586:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000158d:	00 00 00 
    pmm_info.usedpages += count;
ffffffff80001590:	4c 01 d7             	add    %r10,%rdi
    return (void*)(index * PAGE_SIZE);
ffffffff80001593:	48 c1 e0 0c          	shl    $0xc,%rax
    pmm_info.usedpages += count;
ffffffff80001597:	48 89 3d 8a d1 00 00 	mov    %rdi,0xd18a(%rip)        # ffffffff8000e728 <pmm_info+0x8>
    return (void*)(index * PAGE_SIZE);
ffffffff8000159e:	c3                   	retq   
ffffffff8000159f:	90                   	nop

ffffffff800015a0 <pmm_freepages>:

uint64_t pmm_freepages(void* page, uint64_t count)
{
    uint64_t pg = (uint64_t)page;

    for(uint64_t i=0; i < count; i++)
ffffffff800015a0:	48 85 f6             	test   %rsi,%rsi
ffffffff800015a3:	74 51                	je     ffffffff800015f6 <pmm_freepages+0x56>
    bitmap_unset(pmm_info.bitmap, index);
ffffffff800015a5:	4c 8b 0d 8c d1 00 00 	mov    0xd18c(%rip),%r9        # ffffffff8000e738 <pmm_info+0x18>
ffffffff800015ac:	4c 8b 1d 75 d1 00 00 	mov    0xd175(%rip),%r11        # ffffffff8000e728 <pmm_info+0x8>
    for(uint64_t i=0; i < count; i++)
ffffffff800015b3:	31 d2                	xor    %edx,%edx
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800015b5:	41 ba 01 00 00 00    	mov    $0x1,%r10d
ffffffff800015bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    uint64_t index = (uint64_t)page / PAGE_SIZE;
ffffffff800015c0:	48 89 f9             	mov    %rdi,%rcx
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800015c3:	49 89 f8             	mov    %rdi,%r8
ffffffff800015c6:	44 89 d0             	mov    %r10d,%eax
    uint64_t index = (uint64_t)page / PAGE_SIZE;
ffffffff800015c9:	48 c1 e9 0c          	shr    $0xc,%rcx
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800015cd:	49 c1 e8 0f          	shr    $0xf,%r8
    for(uint64_t i=0; i < count; i++)
ffffffff800015d1:	48 83 c2 01          	add    $0x1,%rdx
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800015d5:	83 e1 07             	and    $0x7,%ecx
    {
        pmm_freepage((void*)pg);
        pg += 0x1000;
ffffffff800015d8:	48 81 c7 00 10 00 00 	add    $0x1000,%rdi
    bitmap[bit / 8] &= ~(1 << (bit % 8));
ffffffff800015df:	d3 e0                	shl    %cl,%eax
ffffffff800015e1:	f7 d0                	not    %eax
ffffffff800015e3:	43 20 04 01          	and    %al,(%r9,%r8,1)
    for(uint64_t i=0; i < count; i++)
ffffffff800015e7:	48 39 d6             	cmp    %rdx,%rsi
ffffffff800015ea:	75 d4                	jne    ffffffff800015c0 <pmm_freepages+0x20>
ffffffff800015ec:	49 29 f3             	sub    %rsi,%r11
ffffffff800015ef:	4c 89 1d 32 d1 00 00 	mov    %r11,0xd132(%rip)        # ffffffff8000e728 <pmm_info+0x8>
    }

    return 0;
}
ffffffff800015f6:	31 c0                	xor    %eax,%eax
ffffffff800015f8:	c3                   	retq   
ffffffff800015f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80001600 <pmm_get_free_memory>:

uint64_t pmm_get_free_memory()
{
    return (pmm_info.totalpages - pmm_info.usedpages) * PAGE_SIZE;
ffffffff80001600:	48 8b 05 29 d1 00 00 	mov    0xd129(%rip),%rax        # ffffffff8000e730 <pmm_info+0x10>
ffffffff80001607:	48 2b 05 1a d1 00 00 	sub    0xd11a(%rip),%rax        # ffffffff8000e728 <pmm_info+0x8>
ffffffff8000160e:	48 c1 e0 0c          	shl    $0xc,%rax
}
ffffffff80001612:	c3                   	retq   
ffffffff80001613:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000161a:	00 00 00 00 
ffffffff8000161e:	66 90                	xchg   %ax,%ax

ffffffff80001620 <pmm_get_total_memory>:

uint64_t pmm_get_total_memory()
{   
    return (pmm_info.totalpages) * PAGE_SIZE;
ffffffff80001620:	48 8b 05 09 d1 00 00 	mov    0xd109(%rip),%rax        # ffffffff8000e730 <pmm_info+0x10>
ffffffff80001627:	48 c1 e0 0c          	shl    $0xc,%rax
ffffffff8000162b:	c3                   	retq   
ffffffff8000162c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001630 <fb_init>:



void fb_init()
{
    fb_info.base = boot_info.tag_framebuffer->framebuffer_addr;
ffffffff80001630:	48 8b 15 41 8c 00 00 	mov    0x8c41(%rip),%rdx        # ffffffff8000a278 <boot_info+0x18>
ffffffff80001637:	48 8b 42 10          	mov    0x10(%rdx),%rax
    fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
    fb_info.width = boot_info.tag_framebuffer->framebuffer_width;
ffffffff8000163b:	0f b7 4a 18          	movzwl 0x18(%rdx),%ecx
    fb_info.pitch = boot_info.tag_framebuffer->framebuffer_pitch;
ffffffff8000163f:	0f b7 72 1c          	movzwl 0x1c(%rdx),%esi
    fb_info.base = boot_info.tag_framebuffer->framebuffer_addr;
ffffffff80001643:	48 89 05 66 8c 00 00 	mov    %rax,0x8c66(%rip)        # ffffffff8000a2b0 <fb_info>
    fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
ffffffff8000164a:	0f b7 42 1a          	movzwl 0x1a(%rdx),%eax
    fb_info.bpp = boot_info.tag_framebuffer->framebuffer_bpp;
ffffffff8000164e:	0f b7 52 1e          	movzwl 0x1e(%rdx),%edx
    fb_info.width = boot_info.tag_framebuffer->framebuffer_width;
ffffffff80001652:	66 89 0d 61 8c 00 00 	mov    %cx,0x8c61(%rip)        # ffffffff8000a2ba <fb_info+0xa>
    fb_info.pitch = boot_info.tag_framebuffer->framebuffer_pitch;
ffffffff80001659:	66 89 35 5c 8c 00 00 	mov    %si,0x8c5c(%rip)        # ffffffff8000a2bc <fb_info+0xc>
    fb_info.height = boot_info.tag_framebuffer->framebuffer_height;
ffffffff80001660:	66 89 05 51 8c 00 00 	mov    %ax,0x8c51(%rip)        # ffffffff8000a2b8 <fb_info+0x8>
    fb_info.max_pixels = fb_info.height * fb_info.width;
ffffffff80001667:	0f af c1             	imul   %ecx,%eax
    fb_info.bpp = boot_info.tag_framebuffer->framebuffer_bpp;
ffffffff8000166a:	66 89 15 4d 8c 00 00 	mov    %dx,0x8c4d(%rip)        # ffffffff8000a2be <fb_info+0xe>
    fb_info.max_pixels = fb_info.height * fb_info.width;
ffffffff80001671:	89 05 49 8c 00 00    	mov    %eax,0x8c49(%rip)        # ffffffff8000a2c0 <fb_info+0x10>
    //printf("FB Base: %p", fb_info.base);
    //printf("FB Height: %d  FB Width: %d\n", fb_info.height, fb_info.width);
    //printf("FB BPP: %d   FB Pitch: %d\n", fb_info.bpp, fb_info.pitch);

    //fb_putpixel(100,100,FB_COLOR_WHITE);
}
ffffffff80001677:	c3                   	retq   
ffffffff80001678:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000167f:	00 

ffffffff80001680 <fb_putpixel>:

void fb_putpixel(uint32_t x, uint32_t y, enum fb_color col)
{
    uint64_t index = y * (fb_info.pitch / (fb_info.bpp / 8)) + x;
ffffffff80001680:	0f b7 0d 37 8c 00 00 	movzwl 0x8c37(%rip),%ecx        # ffffffff8000a2be <fb_info+0xe>
ffffffff80001687:	0f b7 05 2e 8c 00 00 	movzwl 0x8c2e(%rip),%eax        # ffffffff8000a2bc <fb_info+0xc>
{
ffffffff8000168e:	41 89 d0             	mov    %edx,%r8d
    uint64_t index = y * (fb_info.pitch / (fb_info.bpp / 8)) + x;
ffffffff80001691:	31 d2                	xor    %edx,%edx
ffffffff80001693:	66 c1 e9 03          	shr    $0x3,%cx
ffffffff80001697:	66 f7 f1             	div    %cx
ffffffff8000169a:	0f b7 c0             	movzwl %ax,%eax
ffffffff8000169d:	0f af c6             	imul   %esi,%eax
ffffffff800016a0:	8d 14 38             	lea    (%rax,%rdi,1),%edx
    //if(index > fb_info.max_pixels) return;
    *((uint32_t*)fb_info.base + index) = col;
ffffffff800016a3:	48 8b 05 06 8c 00 00 	mov    0x8c06(%rip),%rax        # ffffffff8000a2b0 <fb_info>
ffffffff800016aa:	44 89 04 90          	mov    %r8d,(%rax,%rdx,4)
}
ffffffff800016ae:	c3                   	retq   
ffffffff800016af:	90                   	nop

ffffffff800016b0 <fb_clearscreen>:

void fb_clearscreen(enum fb_color col)
{
    for (uint64_t i = 0; i < (fb_info.height*fb_info.width); i++)
ffffffff800016b0:	0f b7 05 01 8c 00 00 	movzwl 0x8c01(%rip),%eax        # ffffffff8000a2b8 <fb_info+0x8>
ffffffff800016b7:	0f b7 15 fc 8b 00 00 	movzwl 0x8bfc(%rip),%edx        # ffffffff8000a2ba <fb_info+0xa>
ffffffff800016be:	0f af c2             	imul   %edx,%eax
ffffffff800016c1:	85 c0                	test   %eax,%eax
ffffffff800016c3:	48 63 c8             	movslq %eax,%rcx
ffffffff800016c6:	74 1f                	je     ffffffff800016e7 <fb_clearscreen+0x37>
    {
        *((uint32_t*)fb_info.base + i) = col;
ffffffff800016c8:	48 8b 15 e1 8b 00 00 	mov    0x8be1(%rip),%rdx        # ffffffff8000a2b0 <fb_info>
    for (uint64_t i = 0; i < (fb_info.height*fb_info.width); i++)
ffffffff800016cf:	31 c0                	xor    %eax,%eax
ffffffff800016d1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff800016d8:	48 83 c0 01          	add    $0x1,%rax
        *((uint32_t*)fb_info.base + i) = col;
ffffffff800016dc:	89 3a                	mov    %edi,(%rdx)
ffffffff800016de:	48 83 c2 04          	add    $0x4,%rdx
    for (uint64_t i = 0; i < (fb_info.height*fb_info.width); i++)
ffffffff800016e2:	48 39 c8             	cmp    %rcx,%rax
ffffffff800016e5:	75 f1                	jne    ffffffff800016d8 <fb_clearscreen+0x28>
    }
}
ffffffff800016e7:	f3 c3                	repz retq 
ffffffff800016e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff800016f0 <fb_drawline>:

void fb_drawline(uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, enum fb_color col)
{

ffffffff800016f0:	f3 c3                	repz retq 
ffffffff800016f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800016f9:	00 00 00 
ffffffff800016fc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001700 <console_input>:

    //write the output buffer to screen
}

void console_input(KEY_INFO_t key)
{
ffffffff80001700:	89 f8                	mov    %edi,%eax
ffffffff80001702:	0f b6 fc             	movzbl %ah,%edi
    con_input_buffer.index++;
ffffffff80001705:	48 8b 05 24 9c 00 00 	mov    0x9c24(%rip),%rax        # ffffffff8000b330 <con_input_buffer+0x10>
ffffffff8000170c:	48 8d 50 01          	lea    0x1(%rax),%rdx
ffffffff80001710:	48 89 15 19 9c 00 00 	mov    %rdx,0x9c19(%rip)        # ffffffff8000b330 <con_input_buffer+0x10>
    con_input_buffer.buffer[con_input_buffer.index] = key.ascii;
ffffffff80001717:	48 8b 15 02 9c 00 00 	mov    0x9c02(%rip),%rdx        # ffffffff8000b320 <con_input_buffer>
ffffffff8000171e:	40 88 7c 02 01       	mov    %dil,0x1(%rdx,%rax,1)
    

    con_output_buffer.buffer[con_output_buffer.index] = key.ascii;
ffffffff80001723:	48 8b 05 e6 9b 00 00 	mov    0x9be6(%rip),%rax        # ffffffff8000b310 <con_output_buffer+0x10>
ffffffff8000172a:	48 8b 15 cf 9b 00 00 	mov    0x9bcf(%rip),%rdx        # ffffffff8000b300 <con_output_buffer>
ffffffff80001731:	40 88 3c 02          	mov    %dil,(%rdx,%rax,1)
    con_output_buffer.index++;
ffffffff80001735:	48 8b 05 d4 9b 00 00 	mov    0x9bd4(%rip),%rax        # ffffffff8000b310 <con_output_buffer+0x10>
ffffffff8000173c:	48 8d 50 01          	lea    0x1(%rax),%rdx
ffffffff80001740:	48 89 15 c9 9b 00 00 	mov    %rdx,0x9bc9(%rip)        # ffffffff8000b310 <con_output_buffer+0x10>
    con_output_buffer.buffer[con_output_buffer.index] = 0x00;
ffffffff80001747:	48 8b 15 b2 9b 00 00 	mov    0x9bb2(%rip),%rdx        # ffffffff8000b300 <con_output_buffer>
ffffffff8000174e:	c6 44 02 01 00       	movb   $0x0,0x1(%rdx,%rax,1)
    return;
ffffffff80001753:	c3                   	retq   
ffffffff80001754:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000175b:	00 00 00 00 
ffffffff8000175f:	90                   	nop

ffffffff80001760 <putchar>:
    switch(c)
ffffffff80001760:	40 80 ff 0a          	cmp    $0xa,%dil
ffffffff80001764:	0f 84 28 01 00 00    	je     ffffffff80001892 <putchar+0x132>
ffffffff8000176a:	40 80 ff 0d          	cmp    $0xd,%dil
ffffffff8000176e:	0f 84 ed 00 00 00    	je     ffffffff80001861 <putchar+0x101>
ffffffff80001774:	40 80 ff 09          	cmp    $0x9,%dil
ffffffff80001778:	0f 84 be 00 00 00    	je     ffffffff8000183c <putchar+0xdc>
{
ffffffff8000177e:	41 57                	push   %r15
ffffffff80001780:	41 56                	push   %r14
ffffffff80001782:	89 f8                	mov    %edi,%eax
ffffffff80001784:	41 55                	push   %r13
ffffffff80001786:	41 54                	push   %r12
    uint8_t* glyph = (uint8_t*)&_binary_zapl16_psf_start + 4 + (c * PSF1_FONT_HEIGHT);
ffffffff80001788:	48 c1 e0 04          	shl    $0x4,%rax
{
ffffffff8000178c:	55                   	push   %rbp
ffffffff8000178d:	53                   	push   %rbx
    uint8_t* glyph = (uint8_t*)&_binary_zapl16_psf_start + 4 + (c * PSF1_FONT_HEIGHT);
ffffffff8000178e:	25 f0 0f 00 00       	and    $0xff0,%eax
ffffffff80001793:	4c 8d a8 a4 6d 00 80 	lea    -0x7fff925c(%rax),%r13
ffffffff8000179a:	48 05 b4 6d 00 80    	add    $0xffffffff80006db4,%rax
{
ffffffff800017a0:	48 83 ec 18          	sub    $0x18,%rsp
    console_drawchar(c, console_info.cursor_x, console_info.cursor_y, console_info.foreground_color, console_info.background_color);
ffffffff800017a4:	8b 0d 9e 9b 00 00    	mov    0x9b9e(%rip),%ecx        # ffffffff8000b348 <console_info+0x8>
ffffffff800017aa:	0f b7 1d a1 9b 00 00 	movzwl 0x9ba1(%rip),%ebx        # ffffffff8000b352 <console_info+0x12>
ffffffff800017b1:	44 8b 25 94 9b 00 00 	mov    0x9b94(%rip),%r12d        # ffffffff8000b34c <console_info+0xc>
ffffffff800017b8:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff800017bd:	89 0c 24             	mov    %ecx,(%rsp)
ffffffff800017c0:	0f b7 0d 89 9b 00 00 	movzwl 0x9b89(%rip),%ecx        # ffffffff8000b350 <console_info+0x10>
ffffffff800017c7:	8d 69 08             	lea    0x8(%rcx),%ebp
ffffffff800017ca:	89 4c 24 04          	mov    %ecx,0x4(%rsp)
ffffffff800017ce:	66 90                	xchg   %ax,%ax
        row = glyph[i];
ffffffff800017d0:	45 0f b6 75 00       	movzbl 0x0(%r13),%r14d
ffffffff800017d5:	44 8b 7c 24 04       	mov    0x4(%rsp),%r15d
ffffffff800017da:	eb 1d                	jmp    ffffffff800017f9 <putchar+0x99>
ffffffff800017dc:	0f 1f 40 00          	nopl   0x0(%rax)
                fb_putpixel(x+j, y+i, background);
ffffffff800017e0:	44 89 ff             	mov    %r15d,%edi
ffffffff800017e3:	44 89 e2             	mov    %r12d,%edx
ffffffff800017e6:	89 de                	mov    %ebx,%esi
ffffffff800017e8:	41 83 c7 01          	add    $0x1,%r15d
            row = row << 1;
ffffffff800017ec:	45 01 f6             	add    %r14d,%r14d
                fb_putpixel(x+j, y+i, background);
ffffffff800017ef:	e8 8c fe ff ff       	callq  ffffffff80001680 <fb_putpixel>
        for (uint32_t j = 0; j < 8; j++)
ffffffff800017f4:	44 39 fd             	cmp    %r15d,%ebp
ffffffff800017f7:	74 1e                	je     ffffffff80001817 <putchar+0xb7>
            if(row & 0x80)
ffffffff800017f9:	45 84 f6             	test   %r14b,%r14b
ffffffff800017fc:	79 e2                	jns    ffffffff800017e0 <putchar+0x80>
                fb_putpixel(x+j, y+i, foreground);
ffffffff800017fe:	8b 14 24             	mov    (%rsp),%edx
ffffffff80001801:	44 89 ff             	mov    %r15d,%edi
ffffffff80001804:	89 de                	mov    %ebx,%esi
ffffffff80001806:	41 83 c7 01          	add    $0x1,%r15d
            row = row << 1;
ffffffff8000180a:	45 01 f6             	add    %r14d,%r14d
                fb_putpixel(x+j, y+i, foreground);
ffffffff8000180d:	e8 6e fe ff ff       	callq  ffffffff80001680 <fb_putpixel>
        for (uint32_t j = 0; j < 8; j++)
ffffffff80001812:	44 39 fd             	cmp    %r15d,%ebp
ffffffff80001815:	75 e2                	jne    ffffffff800017f9 <putchar+0x99>
ffffffff80001817:	49 83 c5 01          	add    $0x1,%r13
ffffffff8000181b:	83 c3 01             	add    $0x1,%ebx
    for (uint32_t i = 0; i < 16; i++)
ffffffff8000181e:	4c 39 6c 24 08       	cmp    %r13,0x8(%rsp)
ffffffff80001823:	75 ab                	jne    ffffffff800017d0 <putchar+0x70>
    console_info.cursor_x += 8;
ffffffff80001825:	66 83 05 23 9b 00 00 	addw   $0x8,0x9b23(%rip)        # ffffffff8000b350 <console_info+0x10>
ffffffff8000182c:	08 
}
ffffffff8000182d:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80001831:	5b                   	pop    %rbx
ffffffff80001832:	5d                   	pop    %rbp
ffffffff80001833:	41 5c                	pop    %r12
ffffffff80001835:	41 5d                	pop    %r13
ffffffff80001837:	41 5e                	pop    %r14
ffffffff80001839:	41 5f                	pop    %r15
ffffffff8000183b:	c3                   	retq   
            if((console_info.cursor_x += (PSF1_FONT_WIDTH * 4)) < fb_info.width)
ffffffff8000183c:	0f b7 05 0d 9b 00 00 	movzwl 0x9b0d(%rip),%eax        # ffffffff8000b350 <console_info+0x10>
ffffffff80001843:	0f b7 15 70 8a 00 00 	movzwl 0x8a70(%rip),%edx        # ffffffff8000a2ba <fb_info+0xa>
ffffffff8000184a:	8d 48 20             	lea    0x20(%rax),%ecx
ffffffff8000184d:	66 39 d1             	cmp    %dx,%cx
ffffffff80001850:	0f 83 4f 01 00 00    	jae    ffffffff800019a5 <putchar+0x245>
                console_info.cursor_x += (PSF1_FONT_WIDTH * 4);
ffffffff80001856:	83 c0 40             	add    $0x40,%eax
ffffffff80001859:	66 89 05 f0 9a 00 00 	mov    %ax,0x9af0(%rip)        # ffffffff8000b350 <console_info+0x10>
                return;
ffffffff80001860:	c3                   	retq   
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001861:	0f b7 05 ea 9a 00 00 	movzwl 0x9aea(%rip),%eax        # ffffffff8000b352 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001868:	0f b7 15 49 8a 00 00 	movzwl 0x8a49(%rip),%edx        # ffffffff8000a2b8 <fb_info+0x8>
    console_info.cursor_x = 0;
ffffffff8000186f:	31 f6                	xor    %esi,%esi
ffffffff80001871:	66 89 35 d8 9a 00 00 	mov    %si,0x9ad8(%rip)        # ffffffff8000b350 <console_info+0x10>
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001878:	83 c0 10             	add    $0x10,%eax
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff8000187b:	8d 4a f1             	lea    -0xf(%rdx),%ecx
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff8000187e:	66 89 05 cd 9a 00 00 	mov    %ax,0x9acd(%rip)        # ffffffff8000b352 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001885:	0f b7 c0             	movzwl %ax,%eax
ffffffff80001888:	39 c1                	cmp    %eax,%ecx
ffffffff8000188a:	0f 8e 9d 00 00 00    	jle    ffffffff8000192d <putchar+0x1cd>
ffffffff80001890:	f3 c3                	repz retq 
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff80001892:	0f b7 05 b9 9a 00 00 	movzwl 0x9ab9(%rip),%eax        # ffffffff8000b352 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff80001899:	0f b7 15 18 8a 00 00 	movzwl 0x8a18(%rip),%edx        # ffffffff8000a2b8 <fb_info+0x8>
    console_info.cursor_x = 0;
ffffffff800018a0:	31 ff                	xor    %edi,%edi
ffffffff800018a2:	66 89 3d a7 9a 00 00 	mov    %di,0x9aa7(%rip)        # ffffffff8000b350 <console_info+0x10>
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800018a9:	83 c0 10             	add    $0x10,%eax
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800018ac:	8d 4a f1             	lea    -0xf(%rdx),%ecx
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800018af:	66 89 05 9c 9a 00 00 	mov    %ax,0x9a9c(%rip)        # ffffffff8000b352 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800018b6:	0f b7 c0             	movzwl %ax,%eax
ffffffff800018b9:	39 c1                	cmp    %eax,%ecx
ffffffff800018bb:	7f d3                	jg     ffffffff80001890 <putchar+0x130>
    start_index = fb_info.width * 16 * 4;
ffffffff800018bd:	0f b7 05 f6 89 00 00 	movzwl 0x89f6(%rip),%eax        # ffffffff8000a2ba <fb_info+0xa>
    uint32_t* base = (uint32_t*)fb_info.base;
ffffffff800018c4:	4c 8b 05 e5 89 00 00 	mov    0x89e5(%rip),%r8        # ffffffff8000a2b0 <fb_info>
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff800018cb:	0f af d0             	imul   %eax,%edx
    start_index = fb_info.width * 16 * 4;
ffffffff800018ce:	89 c1                	mov    %eax,%ecx
ffffffff800018d0:	c1 e1 06             	shl    $0x6,%ecx
ffffffff800018d3:	48 63 c9             	movslq %ecx,%rcx
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff800018d6:	48 63 c2             	movslq %edx,%rax
    end_index = fb_info.height * fb_info.width - 1;
ffffffff800018d9:	83 ea 01             	sub    $0x1,%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff800018dc:	48 29 c8             	sub    %rcx,%rax
    end_index = fb_info.height * fb_info.width - 1;
ffffffff800018df:	48 63 d2             	movslq %edx,%rdx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff800018e2:	48 89 c7             	mov    %rax,%rdi
ffffffff800018e5:	74 20                	je     ffffffff80001907 <putchar+0x1a7>
ffffffff800018e7:	4d 8d 0c 80          	lea    (%r8,%rax,4),%r9
ffffffff800018eb:	48 c1 e1 02          	shl    $0x2,%rcx
ffffffff800018ef:	4c 89 c0             	mov    %r8,%rax
ffffffff800018f2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        base[i] = base[start_index + i];
ffffffff800018f8:	8b 34 08             	mov    (%rax,%rcx,1),%esi
ffffffff800018fb:	48 83 c0 04          	add    $0x4,%rax
ffffffff800018ff:	89 70 fc             	mov    %esi,-0x4(%rax)
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001902:	4c 39 c8             	cmp    %r9,%rax
ffffffff80001905:	75 f1                	jne    ffffffff800018f8 <putchar+0x198>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001907:	48 8d 47 01          	lea    0x1(%rdi),%rax
ffffffff8000190b:	48 39 c2             	cmp    %rax,%rdx
ffffffff8000190e:	76 80                	jbe    ffffffff80001890 <putchar+0x130>
        base[i] = console_info.background_color;
ffffffff80001910:	8b 0d 36 9a 00 00    	mov    0x9a36(%rip),%ecx        # ffffffff8000b34c <console_info+0xc>
ffffffff80001916:	49 8d 04 80          	lea    (%r8,%rax,4),%rax
ffffffff8000191a:	49 8d 14 90          	lea    (%r8,%rdx,4),%rdx
ffffffff8000191e:	66 90                	xchg   %ax,%ax
ffffffff80001920:	89 08                	mov    %ecx,(%rax)
ffffffff80001922:	48 83 c0 04          	add    $0x4,%rax
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001926:	48 39 c2             	cmp    %rax,%rdx
ffffffff80001929:	75 f5                	jne    ffffffff80001920 <putchar+0x1c0>
ffffffff8000192b:	f3 c3                	repz retq 
    start_index = fb_info.width * 16 * 4;
ffffffff8000192d:	0f b7 05 86 89 00 00 	movzwl 0x8986(%rip),%eax        # ffffffff8000a2ba <fb_info+0xa>
    uint32_t* base = (uint32_t*)fb_info.base;
ffffffff80001934:	4c 8b 05 75 89 00 00 	mov    0x8975(%rip),%r8        # ffffffff8000a2b0 <fb_info>
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff8000193b:	0f af d0             	imul   %eax,%edx
    start_index = fb_info.width * 16 * 4;
ffffffff8000193e:	89 c1                	mov    %eax,%ecx
ffffffff80001940:	c1 e1 06             	shl    $0x6,%ecx
ffffffff80001943:	48 63 c9             	movslq %ecx,%rcx
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff80001946:	48 63 c2             	movslq %edx,%rax
    end_index = fb_info.height * fb_info.width - 1;
ffffffff80001949:	83 ea 01             	sub    $0x1,%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff8000194c:	48 29 c8             	sub    %rcx,%rax
    end_index = fb_info.height * fb_info.width - 1;
ffffffff8000194f:	48 63 d2             	movslq %edx,%rdx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001952:	48 89 c7             	mov    %rax,%rdi
ffffffff80001955:	74 20                	je     ffffffff80001977 <putchar+0x217>
ffffffff80001957:	4d 8d 0c 80          	lea    (%r8,%rax,4),%r9
ffffffff8000195b:	48 c1 e1 02          	shl    $0x2,%rcx
ffffffff8000195f:	4c 89 c0             	mov    %r8,%rax
ffffffff80001962:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        base[i] = base[start_index + i];
ffffffff80001968:	8b 34 08             	mov    (%rax,%rcx,1),%esi
ffffffff8000196b:	48 83 c0 04          	add    $0x4,%rax
ffffffff8000196f:	89 70 fc             	mov    %esi,-0x4(%rax)
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001972:	4c 39 c8             	cmp    %r9,%rax
ffffffff80001975:	75 f1                	jne    ffffffff80001968 <putchar+0x208>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001977:	48 8d 47 01          	lea    0x1(%rdi),%rax
ffffffff8000197b:	48 39 c2             	cmp    %rax,%rdx
ffffffff8000197e:	0f 86 0c ff ff ff    	jbe    ffffffff80001890 <putchar+0x130>
        base[i] = console_info.background_color;
ffffffff80001984:	8b 0d c2 99 00 00    	mov    0x99c2(%rip),%ecx        # ffffffff8000b34c <console_info+0xc>
ffffffff8000198a:	49 8d 04 80          	lea    (%r8,%rax,4),%rax
ffffffff8000198e:	49 8d 14 90          	lea    (%r8,%rdx,4),%rdx
ffffffff80001992:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff80001998:	89 08                	mov    %ecx,(%rax)
ffffffff8000199a:	48 83 c0 04          	add    $0x4,%rax
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff8000199e:	48 39 d0             	cmp    %rdx,%rax
ffffffff800019a1:	75 f5                	jne    ffffffff80001998 <putchar+0x238>
ffffffff800019a3:	f3 c3                	repz retq 
    console_info.cursor_x = 0;
ffffffff800019a5:	31 c9                	xor    %ecx,%ecx
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800019a7:	0f b7 05 a4 99 00 00 	movzwl 0x99a4(%rip),%eax        # ffffffff8000b352 <console_info+0x12>
    console_info.cursor_x = 0;
ffffffff800019ae:	66 89 0d 9b 99 00 00 	mov    %cx,0x999b(%rip)        # ffffffff8000b350 <console_info+0x10>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800019b5:	0f b7 0d fc 88 00 00 	movzwl 0x88fc(%rip),%ecx        # ffffffff8000a2b8 <fb_info+0x8>
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800019bc:	83 c0 10             	add    $0x10,%eax
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800019bf:	8d 71 f1             	lea    -0xf(%rcx),%esi
    console_info.cursor_y += PSF1_FONT_HEIGHT;
ffffffff800019c2:	66 89 05 89 99 00 00 	mov    %ax,0x9989(%rip)        # ffffffff8000b352 <console_info+0x12>
    if (console_info.cursor_y > fb_info.height - PSF1_FONT_HEIGHT)
ffffffff800019c9:	0f b7 c0             	movzwl %ax,%eax
ffffffff800019cc:	39 c6                	cmp    %eax,%esi
ffffffff800019ce:	7e 0d                	jle    ffffffff800019dd <putchar+0x27d>
                console_info.cursor_x += (PSF1_FONT_WIDTH * 4);
ffffffff800019d0:	b8 20 00 00 00       	mov    $0x20,%eax
ffffffff800019d5:	66 89 05 74 99 00 00 	mov    %ax,0x9974(%rip)        # ffffffff8000b350 <console_info+0x10>
                return;
ffffffff800019dc:	c3                   	retq   
    start_index = fb_info.width * 16 * 4;
ffffffff800019dd:	89 d0                	mov    %edx,%eax
    uint32_t* base = (uint32_t*)fb_info.base;
ffffffff800019df:	48 8b 3d ca 88 00 00 	mov    0x88ca(%rip),%rdi        # ffffffff8000a2b0 <fb_info>
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff800019e6:	0f af d1             	imul   %ecx,%edx
    start_index = fb_info.width * 16 * 4;
ffffffff800019e9:	c1 e0 06             	shl    $0x6,%eax
ffffffff800019ec:	48 98                	cltq   
    finish_index = (fb_info.height * fb_info.width) - start_index;
ffffffff800019ee:	48 63 f2             	movslq %edx,%rsi
    end_index = fb_info.height * fb_info.width - 1;
ffffffff800019f1:	83 ea 01             	sub    $0x1,%edx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff800019f4:	48 29 c6             	sub    %rax,%rsi
    end_index = fb_info.height * fb_info.width - 1;
ffffffff800019f7:	48 63 d2             	movslq %edx,%rdx
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff800019fa:	74 20                	je     ffffffff80001a1c <putchar+0x2bc>
ffffffff800019fc:	4c 8d 0c b7          	lea    (%rdi,%rsi,4),%r9
ffffffff80001a00:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
ffffffff80001a07:	00 
ffffffff80001a08:	48 89 f8             	mov    %rdi,%rax
        base[i] = base[start_index + i];
ffffffff80001a0b:	44 8b 04 01          	mov    (%rcx,%rax,1),%r8d
ffffffff80001a0f:	48 83 c0 04          	add    $0x4,%rax
ffffffff80001a13:	44 89 40 fc          	mov    %r8d,-0x4(%rax)
    for(uint64_t i = 0; i < finish_index; i++)
ffffffff80001a17:	49 39 c1             	cmp    %rax,%r9
ffffffff80001a1a:	75 ef                	jne    ffffffff80001a0b <putchar+0x2ab>
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001a1c:	48 8d 46 01          	lea    0x1(%rsi),%rax
ffffffff80001a20:	48 39 c2             	cmp    %rax,%rdx
ffffffff80001a23:	76 ab                	jbe    ffffffff800019d0 <putchar+0x270>
        base[i] = console_info.background_color;
ffffffff80001a25:	8b 0d 21 99 00 00    	mov    0x9921(%rip),%ecx        # ffffffff8000b34c <console_info+0xc>
ffffffff80001a2b:	48 8d 04 87          	lea    (%rdi,%rax,4),%rax
ffffffff80001a2f:	48 8d 14 97          	lea    (%rdi,%rdx,4),%rdx
ffffffff80001a33:	89 08                	mov    %ecx,(%rax)
ffffffff80001a35:	48 83 c0 04          	add    $0x4,%rax
    for(uint64_t i = finish_index + 1; i < end_index; i++)
ffffffff80001a39:	48 39 d0             	cmp    %rdx,%rax
ffffffff80001a3c:	75 f5                	jne    ffffffff80001a33 <putchar+0x2d3>
ffffffff80001a3e:	eb 90                	jmp    ffffffff800019d0 <putchar+0x270>

ffffffff80001a40 <console_init>:
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80001a40:	0f b7 05 71 88 00 00 	movzwl 0x8871(%rip),%eax        # ffffffff8000a2b8 <fb_info+0x8>
    uint64_t index = y * fb_info.width;
ffffffff80001a47:	0f b7 3d 6c 88 00 00 	movzwl 0x886c(%rip),%edi        # ffffffff8000a2ba <fb_info+0xa>
    console_info.font = (struct PSF1_FONT*)&_binary_zapl16_psf_start;
ffffffff80001a4e:	48 c7 05 ff 98 00 00 	movq   $0xffffffff80006da0,0x98ff(%rip)        # ffffffff8000b358 <console_info+0x18>
ffffffff80001a55:	a0 6d 00 80 
    console_info.foreground_color = FB_COLOR_WHITE;
ffffffff80001a59:	c7 05 e5 98 00 00 ff 	movl   $0xffffffff,0x98e5(%rip)        # ffffffff8000b348 <console_info+0x8>
ffffffff80001a60:	ff ff ff 
    console_info.background_color = FB_COLOR_BLACK;
ffffffff80001a63:	c7 05 df 98 00 00 00 	movl   $0xff000000,0x98df(%rip)        # ffffffff8000b34c <console_info+0xc>
ffffffff80001a6a:	00 00 ff 
    console_info.cursor_x = 0;
ffffffff80001a6d:	c7 05 d9 98 00 00 00 	movl   $0x0,0x98d9(%rip)        # ffffffff8000b350 <console_info+0x10>
ffffffff80001a74:	00 00 00 
    con_output_buffer.buffer = console_buffer;
ffffffff80001a77:	48 c7 05 7e 98 00 00 	movq   $0xffffffff8000a300,0x987e(%rip)        # ffffffff8000b300 <con_output_buffer>
ffffffff80001a7e:	00 a3 00 80 
    con_output_buffer.buffer_size = sizeof(console_buffer);
ffffffff80001a82:	48 c7 05 7b 98 00 00 	movq   $0x1000,0x987b(%rip)        # ffffffff8000b308 <con_output_buffer+0x8>
ffffffff80001a89:	00 10 00 00 
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80001a8d:	89 c2                	mov    %eax,%edx
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80001a8f:	66 c1 e8 02          	shr    $0x2,%ax
    con_output_buffer.index = 0;
ffffffff80001a93:	48 c7 05 72 98 00 00 	movq   $0x0,0x9872(%rip)        # ffffffff8000b310 <con_output_buffer+0x10>
ffffffff80001a9a:	00 00 00 00 
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80001a9e:	0f b7 c0             	movzwl %ax,%eax
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80001aa1:	66 c1 ea 04          	shr    $0x4,%dx
    con_input_buffer.buffer = cmd_buffer;
ffffffff80001aa5:	48 c7 05 70 98 00 00 	movq   $0xffffffff8000b380,0x9870(%rip)        # ffffffff8000b320 <con_input_buffer>
ffffffff80001aac:	80 b3 00 80 
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80001ab0:	8d 04 40             	lea    (%rax,%rax,2),%eax
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80001ab3:	0f b7 d2             	movzwl %dx,%edx
    con_input_buffer.buffer_size = sizeof(cmd_buffer);
ffffffff80001ab6:	48 c7 05 67 98 00 00 	movq   $0x100,0x9867(%rip)        # ffffffff8000b328 <con_input_buffer+0x8>
ffffffff80001abd:	00 01 00 00 
    console_info.max_lines = fb_info.height / PSF1_FONT_HEIGHT;
ffffffff80001ac1:	89 15 7d 98 00 00    	mov    %edx,0x987d(%rip)        # ffffffff8000b344 <console_info+0x4>
    uint64_t index = y * fb_info.width;
ffffffff80001ac7:	48 89 f9             	mov    %rdi,%rcx
    console_draw_hline(console_info.start_pos, FB_COLOR_YELLOW);
ffffffff80001aca:	48 63 d0             	movslq %eax,%rdx
    console_info.start_pos = (fb_info.height / 4) * 3;
ffffffff80001acd:	89 05 6d 98 00 00    	mov    %eax,0x986d(%rip)        # ffffffff8000b340 <console_info>
    uint64_t index = y * fb_info.width;
ffffffff80001ad3:	48 0f af d7          	imul   %rdi,%rdx
    for(int i = 0; i < fb_info.width; i++)
ffffffff80001ad7:	66 85 ff             	test   %di,%di
ffffffff80001ada:	74 53                	je     ffffffff80001b2f <console_init+0xef>
        *((uint32_t*)fb_info.base + index + i) = color;
ffffffff80001adc:	48 8b 35 cd 87 00 00 	mov    0x87cd(%rip),%rsi        # ffffffff8000a2b0 <fb_info>
ffffffff80001ae3:	83 e9 01             	sub    $0x1,%ecx
ffffffff80001ae6:	4c 8d 46 04          	lea    0x4(%rsi),%r8
ffffffff80001aea:	48 8d 04 96          	lea    (%rsi,%rdx,4),%rax
ffffffff80001aee:	48 01 ca             	add    %rcx,%rdx
ffffffff80001af1:	49 8d 14 90          	lea    (%r8,%rdx,4),%rdx
ffffffff80001af5:	0f 1f 00             	nopl   (%rax)
ffffffff80001af8:	c7 00 00 ff ff ff    	movl   $0xffffff00,(%rax)
ffffffff80001afe:	48 83 c0 04          	add    $0x4,%rax
    for(int i = 0; i < fb_info.width; i++)
ffffffff80001b02:	48 39 d0             	cmp    %rdx,%rax
ffffffff80001b05:	75 f1                	jne    ffffffff80001af8 <console_init+0xb8>
    console_draw_hline(console_info.start_pos + 1, FB_COLOR_YELLOW);
ffffffff80001b07:	8b 05 33 98 00 00    	mov    0x9833(%rip),%eax        # ffffffff8000b340 <console_info>
ffffffff80001b0d:	8d 50 01             	lea    0x1(%rax),%edx
    uint64_t index = y * fb_info.width;
ffffffff80001b10:	48 0f af d7          	imul   %rdi,%rdx
ffffffff80001b14:	48 01 d1             	add    %rdx,%rcx
ffffffff80001b17:	48 8d 04 96          	lea    (%rsi,%rdx,4),%rax
ffffffff80001b1b:	49 8d 14 88          	lea    (%r8,%rcx,4),%rdx
ffffffff80001b1f:	90                   	nop
        *((uint32_t*)fb_info.base + index + i) = color;
ffffffff80001b20:	c7 00 00 ff ff ff    	movl   $0xffffff00,(%rax)
ffffffff80001b26:	48 83 c0 04          	add    $0x4,%rax
    for(int i = 0; i < fb_info.width; i++)
ffffffff80001b2a:	48 39 c2             	cmp    %rax,%rdx
ffffffff80001b2d:	75 f1                	jne    ffffffff80001b20 <console_init+0xe0>
    kbd_set_target(console_input);
ffffffff80001b2f:	48 c7 c7 00 17 00 80 	mov    $0xffffffff80001700,%rdi
ffffffff80001b36:	e9 15 02 00 00       	jmpq   ffffffff80001d50 <kbd_set_target>
ffffffff80001b3b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80001b40 <console_exec>:
    for(int i = console_info.start_pos + (fb_info.width * 2); i < (fb_info.height * fb_info.width); i++)
ffffffff80001b40:	0f b7 05 73 87 00 00 	movzwl 0x8773(%rip),%eax        # ffffffff8000a2ba <fb_info+0xa>
ffffffff80001b47:	8b 15 f3 97 00 00    	mov    0x97f3(%rip),%edx        # ffffffff8000b340 <console_info>
ffffffff80001b4d:	8d 34 42             	lea    (%rdx,%rax,2),%esi
ffffffff80001b50:	0f b7 15 61 87 00 00 	movzwl 0x8761(%rip),%edx        # ffffffff8000a2b8 <fb_info+0x8>
ffffffff80001b57:	0f af d0             	imul   %eax,%edx
ffffffff80001b5a:	39 d6                	cmp    %edx,%esi
ffffffff80001b5c:	7d 2d                	jge    ffffffff80001b8b <console_exec+0x4b>
        *((uint32_t*)fb_info.base + i) = console_info.background_color;
ffffffff80001b5e:	48 8b 3d 4b 87 00 00 	mov    0x874b(%rip),%rdi        # ffffffff8000a2b0 <fb_info>
ffffffff80001b65:	83 ea 01             	sub    $0x1,%edx
ffffffff80001b68:	4c 63 c6             	movslq %esi,%r8
ffffffff80001b6b:	29 f2                	sub    %esi,%edx
ffffffff80001b6d:	8b 0d d9 97 00 00    	mov    0x97d9(%rip),%ecx        # ffffffff8000b34c <console_info+0xc>
ffffffff80001b73:	4c 01 c2             	add    %r8,%rdx
ffffffff80001b76:	4a 8d 04 87          	lea    (%rdi,%r8,4),%rax
ffffffff80001b7a:	48 8d 54 97 04       	lea    0x4(%rdi,%rdx,4),%rdx
ffffffff80001b7f:	90                   	nop
ffffffff80001b80:	89 08                	mov    %ecx,(%rax)
ffffffff80001b82:	48 83 c0 04          	add    $0x4,%rax
    for(int i = console_info.start_pos + (fb_info.width * 2); i < (fb_info.height * fb_info.width); i++)
ffffffff80001b86:	48 39 d0             	cmp    %rdx,%rax
ffffffff80001b89:	75 f5                	jne    ffffffff80001b80 <console_exec+0x40>
}
ffffffff80001b8b:	f3 c3                	repz retq 
ffffffff80001b8d:	0f 1f 00             	nopl   (%rax)

ffffffff80001b90 <serial_init>:
#include "../../io/io.h"

char serial_buffer[256];

uint64_t serial_init(uint16_t port)
{
ffffffff80001b90:	41 55                	push   %r13
ffffffff80001b92:	41 54                	push   %r12
    outb(port + 1, 0x00);
ffffffff80001b94:	44 8d 67 01          	lea    0x1(%rdi),%r12d
{
ffffffff80001b98:	55                   	push   %rbp
ffffffff80001b99:	53                   	push   %rbx
ffffffff80001b9a:	89 fb                	mov    %edi,%ebx
    outb(port + 3, 0x80);
ffffffff80001b9c:	8d 6b 03             	lea    0x3(%rbx),%ebp
    outb(port + 1, 0x00);
ffffffff80001b9f:	45 0f b7 e4          	movzwl %r12w,%r12d
ffffffff80001ba3:	31 f6                	xor    %esi,%esi
{
ffffffff80001ba5:	48 83 ec 08          	sub    $0x8,%rsp
    outb(port + 1, 0x00);
ffffffff80001ba9:	44 89 e7             	mov    %r12d,%edi
    outb(port + 0, 0x00);
ffffffff80001bac:	44 0f b7 eb          	movzwl %bx,%r13d
    outb(port + 3, 0x80);
ffffffff80001bb0:	0f b7 ed             	movzwl %bp,%ebp
    outb(port + 1, 0x00);
ffffffff80001bb3:	e8 48 e8 ff ff       	callq  ffffffff80000400 <outb>
    outb(port + 3, 0x80);
ffffffff80001bb8:	be 80 00 00 00       	mov    $0x80,%esi
ffffffff80001bbd:	89 ef                	mov    %ebp,%edi
ffffffff80001bbf:	e8 3c e8 ff ff       	callq  ffffffff80000400 <outb>
    outb(port + 0, 0x00);
ffffffff80001bc4:	31 f6                	xor    %esi,%esi
ffffffff80001bc6:	44 89 ef             	mov    %r13d,%edi
ffffffff80001bc9:	e8 32 e8 ff ff       	callq  ffffffff80000400 <outb>
    outb(port + 1, 0x00);
ffffffff80001bce:	31 f6                	xor    %esi,%esi
ffffffff80001bd0:	44 89 e7             	mov    %r12d,%edi
ffffffff80001bd3:	e8 28 e8 ff ff       	callq  ffffffff80000400 <outb>
    outb(port + 3, 0x03);
ffffffff80001bd8:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff80001bdd:	89 ef                	mov    %ebp,%edi
ffffffff80001bdf:	e8 1c e8 ff ff       	callq  ffffffff80000400 <outb>
    outb(port + 2, 0xC7);
ffffffff80001be4:	8d 7b 02             	lea    0x2(%rbx),%edi
    outb(port + 4, 0x0B);
ffffffff80001be7:	83 c3 04             	add    $0x4,%ebx
    outb(port + 2, 0xC7);
ffffffff80001bea:	be c7 00 00 00       	mov    $0xc7,%esi
    outb(port + 4, 0x0B);
ffffffff80001bef:	0f b7 db             	movzwl %bx,%ebx
    outb(port + 2, 0xC7);
ffffffff80001bf2:	0f b7 ff             	movzwl %di,%edi
ffffffff80001bf5:	e8 06 e8 ff ff       	callq  ffffffff80000400 <outb>
    outb(port + 4, 0x0B);
ffffffff80001bfa:	be 0b 00 00 00       	mov    $0xb,%esi
ffffffff80001bff:	89 df                	mov    %ebx,%edi
ffffffff80001c01:	e8 fa e7 ff ff       	callq  ffffffff80000400 <outb>

    if(inb(port + 0) != 0xAE)
ffffffff80001c06:	44 89 ef             	mov    %r13d,%edi
ffffffff80001c09:	e8 02 e8 ff ff       	callq  ffffffff80000410 <inb>
ffffffff80001c0e:	3c ae                	cmp    $0xae,%al
ffffffff80001c10:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80001c15:	74 11                	je     ffffffff80001c28 <serial_init+0x98>
        return 1;
    }

    outb(port + 4, 0x0F);
    return 0;
}
ffffffff80001c17:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80001c1b:	48 89 d0             	mov    %rdx,%rax
ffffffff80001c1e:	5b                   	pop    %rbx
ffffffff80001c1f:	5d                   	pop    %rbp
ffffffff80001c20:	41 5c                	pop    %r12
ffffffff80001c22:	41 5d                	pop    %r13
ffffffff80001c24:	c3                   	retq   
ffffffff80001c25:	0f 1f 00             	nopl   (%rax)
    outb(port + 4, 0x0F);
ffffffff80001c28:	89 df                	mov    %ebx,%edi
ffffffff80001c2a:	be 0f 00 00 00       	mov    $0xf,%esi
ffffffff80001c2f:	e8 cc e7 ff ff       	callq  ffffffff80000400 <outb>
}
ffffffff80001c34:	48 83 c4 08          	add    $0x8,%rsp
    return 0;
ffffffff80001c38:	31 d2                	xor    %edx,%edx
}
ffffffff80001c3a:	5b                   	pop    %rbx
ffffffff80001c3b:	48 89 d0             	mov    %rdx,%rax
ffffffff80001c3e:	5d                   	pop    %rbp
ffffffff80001c3f:	41 5c                	pop    %r12
ffffffff80001c41:	41 5d                	pop    %r13
ffffffff80001c43:	c3                   	retq   
ffffffff80001c44:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001c4b:	00 00 00 00 
ffffffff80001c4f:	90                   	nop

ffffffff80001c50 <serial_received>:

uint64_t serial_received(uint16_t port)
{
    return inb(port + 5) & 1;
ffffffff80001c50:	83 c7 05             	add    $0x5,%edi
{
ffffffff80001c53:	48 83 ec 08          	sub    $0x8,%rsp
    return inb(port + 5) & 1;
ffffffff80001c57:	0f b7 ff             	movzwl %di,%edi
ffffffff80001c5a:	e8 b1 e7 ff ff       	callq  ffffffff80000410 <inb>
}
ffffffff80001c5f:	48 83 c4 08          	add    $0x8,%rsp
    return inb(port + 5) & 1;
ffffffff80001c63:	83 e0 01             	and    $0x1,%eax
}
ffffffff80001c66:	c3                   	retq   
ffffffff80001c67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80001c6e:	00 00 

ffffffff80001c70 <serial_read>:

uint8_t serial_read(uint16_t port)
{
ffffffff80001c70:	55                   	push   %rbp
ffffffff80001c71:	53                   	push   %rbx
ffffffff80001c72:	0f b7 ef             	movzwl %di,%ebp
ffffffff80001c75:	83 c7 05             	add    $0x5,%edi
ffffffff80001c78:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80001c7c:	0f b7 df             	movzwl %di,%ebx
ffffffff80001c7f:	90                   	nop
    return inb(port + 5) & 1;
ffffffff80001c80:	89 df                	mov    %ebx,%edi
ffffffff80001c82:	e8 89 e7 ff ff       	callq  ffffffff80000410 <inb>
    while(serial_received(port) == 0);
ffffffff80001c87:	a8 01                	test   $0x1,%al
ffffffff80001c89:	74 f5                	je     ffffffff80001c80 <serial_read+0x10>

    return inb(port);
}
ffffffff80001c8b:	48 83 c4 08          	add    $0x8,%rsp
    return inb(port);
ffffffff80001c8f:	89 ef                	mov    %ebp,%edi
}
ffffffff80001c91:	5b                   	pop    %rbx
ffffffff80001c92:	5d                   	pop    %rbp
    return inb(port);
ffffffff80001c93:	e9 78 e7 ff ff       	jmpq   ffffffff80000410 <inb>
ffffffff80001c98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80001c9f:	00 

ffffffff80001ca0 <serial_is_tx_empty>:

uint64_t serial_is_tx_empty(uint16_t port)
{
    return inb(port + 5) & 0x20;
ffffffff80001ca0:	83 c7 05             	add    $0x5,%edi
{
ffffffff80001ca3:	48 83 ec 08          	sub    $0x8,%rsp
    return inb(port + 5) & 0x20;
ffffffff80001ca7:	0f b7 ff             	movzwl %di,%edi
ffffffff80001caa:	e8 61 e7 ff ff       	callq  ffffffff80000410 <inb>
ffffffff80001caf:	83 e0 20             	and    $0x20,%eax
}
ffffffff80001cb2:	48 83 c4 08          	add    $0x8,%rsp
    return inb(port + 5) & 0x20;
ffffffff80001cb6:	0f b6 c0             	movzbl %al,%eax
}
ffffffff80001cb9:	c3                   	retq   
ffffffff80001cba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80001cc0 <serial_write>:

void serial_write(uint16_t port, uint8_t data)
{
ffffffff80001cc0:	41 54                	push   %r12
ffffffff80001cc2:	44 0f b7 e7          	movzwl %di,%r12d
ffffffff80001cc6:	83 c7 05             	add    $0x5,%edi
ffffffff80001cc9:	55                   	push   %rbp
ffffffff80001cca:	89 f5                	mov    %esi,%ebp
ffffffff80001ccc:	53                   	push   %rbx
ffffffff80001ccd:	0f b7 df             	movzwl %di,%ebx
    return inb(port + 5) & 0x20;
ffffffff80001cd0:	89 df                	mov    %ebx,%edi
ffffffff80001cd2:	e8 39 e7 ff ff       	callq  ffffffff80000410 <inb>
    while(serial_is_tx_empty(port) == 0);
ffffffff80001cd7:	a8 20                	test   $0x20,%al
ffffffff80001cd9:	74 f5                	je     ffffffff80001cd0 <serial_write+0x10>
    outb(port, data);
}
ffffffff80001cdb:	5b                   	pop    %rbx
    outb(port, data);
ffffffff80001cdc:	40 0f b6 f5          	movzbl %bpl,%esi
ffffffff80001ce0:	44 89 e7             	mov    %r12d,%edi
}
ffffffff80001ce3:	5d                   	pop    %rbp
ffffffff80001ce4:	41 5c                	pop    %r12
    outb(port, data);
ffffffff80001ce6:	e9 15 e7 ff ff       	jmpq   ffffffff80000400 <outb>
ffffffff80001ceb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80001cf0 <serial_write_str>:

void serial_write_str(uint16_t port, char* data)
{
    uint8_t i = 0;
    while(data[i] != 0)
ffffffff80001cf0:	0f b6 06             	movzbl (%rsi),%eax
ffffffff80001cf3:	84 c0                	test   %al,%al
ffffffff80001cf5:	74 39                	je     ffffffff80001d30 <serial_write_str+0x40>
{
ffffffff80001cf7:	41 54                	push   %r12
ffffffff80001cf9:	49 89 f4             	mov    %rsi,%r12
ffffffff80001cfc:	55                   	push   %rbp
ffffffff80001cfd:	0f b7 ef             	movzwl %di,%ebp
ffffffff80001d00:	53                   	push   %rbx
    uint8_t i = 0;
ffffffff80001d01:	31 db                	xor    %ebx,%ebx
ffffffff80001d03:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    {
        serial_write(port, data[i]);
ffffffff80001d08:	0f b6 f0             	movzbl %al,%esi
        i++;
ffffffff80001d0b:	83 c3 01             	add    $0x1,%ebx
        serial_write(port, data[i]);
ffffffff80001d0e:	89 ef                	mov    %ebp,%edi
ffffffff80001d10:	e8 ab ff ff ff       	callq  ffffffff80001cc0 <serial_write>
    while(data[i] != 0)
ffffffff80001d15:	0f b6 c3             	movzbl %bl,%eax
ffffffff80001d18:	41 0f b6 04 04       	movzbl (%r12,%rax,1),%eax
ffffffff80001d1d:	84 c0                	test   %al,%al
ffffffff80001d1f:	75 e7                	jne    ffffffff80001d08 <serial_write_str+0x18>
    }
ffffffff80001d21:	5b                   	pop    %rbx
ffffffff80001d22:	5d                   	pop    %rbp
ffffffff80001d23:	41 5c                	pop    %r12
ffffffff80001d25:	c3                   	retq   
ffffffff80001d26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001d2d:	00 00 00 
ffffffff80001d30:	f3 c3                	repz retq 
ffffffff80001d32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001d39:	00 00 00 
ffffffff80001d3c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001d40 <kbd_init>:


void kbd_init()
{

}
ffffffff80001d40:	f3 c3                	repz retq 
ffffffff80001d42:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80001d49:	00 00 00 00 
ffffffff80001d4d:	0f 1f 00             	nopl   (%rax)

ffffffff80001d50 <kbd_set_target>:

void kbd_set_target(void* handler)
{
    kbd_handler = handler;
ffffffff80001d50:	48 89 3d f1 c9 00 00 	mov    %rdi,0xc9f1(%rip)        # ffffffff8000e748 <kbd_handler>
    kbd_active = 1;
ffffffff80001d57:	c6 05 f2 c9 00 00 01 	movb   $0x1,0xc9f2(%rip)        # ffffffff8000e750 <kbd_active>
}
ffffffff80001d5e:	c3                   	retq   
ffffffff80001d5f:	90                   	nop

ffffffff80001d60 <kbd_translate>:

uint8_t kbd_translate(uint8_t scancode, uint8_t uppercase)
{
    if(scancode > 58) return 0;
ffffffff80001d60:	31 c0                	xor    %eax,%eax
ffffffff80001d62:	40 80 ff 3a          	cmp    $0x3a,%dil
ffffffff80001d66:	77 14                	ja     ffffffff80001d7c <kbd_translate+0x1c>
ffffffff80001d68:	40 0f b6 ff          	movzbl %dil,%edi

    if(uppercase) return kbd_table[scancode] - 32;
ffffffff80001d6c:	40 84 f6             	test   %sil,%sil
ffffffff80001d6f:	0f b6 87 60 4a 00 80 	movzbl -0x7fffb5a0(%rdi),%eax
ffffffff80001d76:	8d 50 e0             	lea    -0x20(%rax),%edx
ffffffff80001d79:	0f 45 c2             	cmovne %edx,%eax

    return kbd_table[scancode];
}
ffffffff80001d7c:	f3 c3                	repz retq 
ffffffff80001d7e:	66 90                	xchg   %ax,%ax

ffffffff80001d80 <kbd_handle>:
void kbd_handle()
{
    uint8_t data;
    KEY_INFO_t key_info;

    if(!kbd_active) return;
ffffffff80001d80:	80 3d c9 c9 00 00 00 	cmpb   $0x0,0xc9c9(%rip)        # ffffffff8000e750 <kbd_active>
ffffffff80001d87:	75 07                	jne    ffffffff80001d90 <kbd_handle+0x10>
ffffffff80001d89:	f3 c3                	repz retq 
ffffffff80001d8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{
ffffffff80001d90:	48 83 ec 08          	sub    $0x8,%rsp

    data = inb(0x60);
ffffffff80001d94:	bf 60 00 00 00       	mov    $0x60,%edi
ffffffff80001d99:	e8 72 e6 ff ff       	callq  ffffffff80000410 <inb>

    uint8_t buffer[20];

    switch(data)
ffffffff80001d9e:	3c 36                	cmp    $0x36,%al
ffffffff80001da0:	74 36                	je     ffffffff80001dd8 <kbd_handle+0x58>
ffffffff80001da2:	77 1c                	ja     ffffffff80001dc0 <kbd_handle+0x40>
ffffffff80001da4:	3c 01                	cmp    $0x1,%al
ffffffff80001da6:	0f 84 84 00 00 00    	je     ffffffff80001e30 <kbd_handle+0xb0>
ffffffff80001dac:	3c 2a                	cmp    $0x2a,%al
ffffffff80001dae:	75 48                	jne    ffffffff80001df8 <kbd_handle+0x78>
    {
        case KBD_LEFT_SHIFT:
            lshift_status = 1;
ffffffff80001db0:	c6 05 e9 98 00 00 01 	movb   $0x1,0x98e9(%rip)        # ffffffff8000b6a0 <lshift_status>
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
    key_info.scancode = data;

    kbd_handler(key_info);

ffffffff80001db7:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80001dbb:	c3                   	retq   
ffffffff80001dbc:	0f 1f 40 00          	nopl   0x0(%rax)
    switch(data)
ffffffff80001dc0:	3c aa                	cmp    $0xaa,%al
ffffffff80001dc2:	74 24                	je     ffffffff80001de8 <kbd_handle+0x68>
ffffffff80001dc4:	3c b6                	cmp    $0xb6,%al
ffffffff80001dc6:	75 30                	jne    ffffffff80001df8 <kbd_handle+0x78>
            rshift_status = 0;
ffffffff80001dc8:	c6 05 b9 97 00 00 00 	movb   $0x0,0x97b9(%rip)        # ffffffff8000b588 <rshift_status>
            return;
ffffffff80001dcf:	eb e6                	jmp    ffffffff80001db7 <kbd_handle+0x37>
ffffffff80001dd1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            rshift_status = 1;
ffffffff80001dd8:	c6 05 a9 97 00 00 01 	movb   $0x1,0x97a9(%rip)        # ffffffff8000b588 <rshift_status>
            return;
ffffffff80001ddf:	eb d6                	jmp    ffffffff80001db7 <kbd_handle+0x37>
ffffffff80001de1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            lshift_status = 0;
ffffffff80001de8:	c6 05 b1 98 00 00 00 	movb   $0x0,0x98b1(%rip)        # ffffffff8000b6a0 <lshift_status>
            return;
ffffffff80001def:	eb c6                	jmp    ffffffff80001db7 <kbd_handle+0x37>
ffffffff80001df1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if(scancode > 58) return 0;
ffffffff80001df8:	31 d2                	xor    %edx,%edx
ffffffff80001dfa:	3c 3a                	cmp    $0x3a,%al
ffffffff80001dfc:	77 1e                	ja     ffffffff80001e1c <kbd_handle+0x9c>
ffffffff80001dfe:	0f b6 d0             	movzbl %al,%edx
    if(uppercase) return kbd_table[scancode] - 32;
ffffffff80001e01:	0f b6 35 98 98 00 00 	movzbl 0x9898(%rip),%esi        # ffffffff8000b6a0 <lshift_status>
ffffffff80001e08:	0f b6 92 60 4a 00 80 	movzbl -0x7fffb5a0(%rdx),%edx
ffffffff80001e0f:	40 0a 35 72 97 00 00 	or     0x9772(%rip),%sil        # ffffffff8000b588 <rshift_status>
ffffffff80001e16:	8d 4a e0             	lea    -0x20(%rdx),%ecx
ffffffff80001e19:	0f 45 d1             	cmovne %ecx,%edx
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
ffffffff80001e1c:	31 c9                	xor    %ecx,%ecx
ffffffff80001e1e:	48 83 c4 08          	add    $0x8,%rsp
    key_info.ascii = kbd_translate(data, lshift_status | rshift_status);
ffffffff80001e22:	88 d5                	mov    %dl,%ch
    key_info.scancode = data;
ffffffff80001e24:	88 c1                	mov    %al,%cl
    kbd_handler(key_info);
ffffffff80001e26:	89 cf                	mov    %ecx,%edi
ffffffff80001e28:	ff 25 1a c9 00 00    	jmpq   *0xc91a(%rip)        # ffffffff8000e748 <kbd_handler>
ffffffff80001e2e:	66 90                	xchg   %ax,%ax
            printf("%d\n", pit_ticks);
ffffffff80001e30:	48 8b 35 29 ca 00 00 	mov    0xca29(%rip),%rsi        # ffffffff8000e860 <pit_ticks>
ffffffff80001e37:	48 c7 c7 13 49 00 80 	mov    $0xffffffff80004913,%rdi
ffffffff80001e3e:	31 c0                	xor    %eax,%eax
ffffffff80001e40:	48 83 c4 08          	add    $0x8,%rsp
            printf("%d\n", pit_ticks);
ffffffff80001e44:	e9 a7 13 00 00       	jmpq   ffffffff800031f0 <printf_>
ffffffff80001e49:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80001e50 <cpu_init>:

void cpu_init()
{
    uint64_t a,b,c,d;
    __cpuid(0,a,b,c,d);
ffffffff80001e50:	f3 c3                	repz retq 
ffffffff80001e52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001e59:	00 00 00 
ffffffff80001e5c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80001e60 <acpi_init>:
    struct RSDP20Descriptor* rsdp;

}ACPI_Info;

void acpi_init()
{
ffffffff80001e60:	48 83 ec 18          	sub    $0x18,%rsp
    ACPI_Info.rsdp = (struct RSDP20Descriptor*)boot_info.tag_rsdp->rsdp;
ffffffff80001e64:	48 8b 05 1d 84 00 00 	mov    0x841d(%rip),%rax        # ffffffff8000a288 <boot_info+0x28>
    
    uint8_t test[8] = {'R', 'S', 'P', ' ', 'P', 'T', 'R', ' '};
ffffffff80001e6b:	48 bf 52 53 50 20 50 	movabs $0x2052545020505352,%rdi
ffffffff80001e72:	54 52 20 
ffffffff80001e75:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
ffffffff80001e7a:	31 d2                	xor    %edx,%edx
ffffffff80001e7c:	b9 52 00 00 00       	mov    $0x52,%ecx
    ACPI_Info.rsdp = (struct RSDP20Descriptor*)boot_info.tag_rsdp->rsdp;
ffffffff80001e81:	48 8b 40 10          	mov    0x10(%rax),%rax
ffffffff80001e85:	48 89 05 1c 98 00 00 	mov    %rax,0x981c(%rip)        # ffffffff8000b6a8 <ACPI_Info>
    for(uint32_t i = 0; i < 8; i++)
    {
        if(test[i] == ACPI_Info.rsdp->header.signature[i]) 
ffffffff80001e8c:	38 0c 10             	cmp    %cl,(%rax,%rdx,1)
ffffffff80001e8f:	74 0f                	je     ffffffff80001ea0 <acpi_init+0x40>
            return;
    }

    printf("Valid RSDP Header. Revision %d\n", ACPI_Info.rsdp->header.revision);
    
ffffffff80001e91:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80001e95:	c3                   	retq   
ffffffff80001e96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001e9d:	00 00 00 
ffffffff80001ea0:	48 83 c2 01          	add    $0x1,%rdx
    for(uint32_t i = 0; i < 8; i++)
ffffffff80001ea4:	48 83 fa 08          	cmp    $0x8,%rdx
ffffffff80001ea8:	75 16                	jne    ffffffff80001ec0 <acpi_init+0x60>
    printf("Valid RSDP Header. Revision %d\n", ACPI_Info.rsdp->header.revision);
ffffffff80001eaa:	0f b6 70 0f          	movzbl 0xf(%rax),%esi
ffffffff80001eae:	48 c7 c7 a0 4a 00 80 	mov    $0xffffffff80004aa0,%rdi
ffffffff80001eb5:	31 c0                	xor    %eax,%eax
ffffffff80001eb7:	48 83 c4 18          	add    $0x18,%rsp
    printf("Valid RSDP Header. Revision %d\n", ACPI_Info.rsdp->header.revision);
ffffffff80001ebb:	e9 30 13 00 00       	jmpq   ffffffff800031f0 <printf_>
ffffffff80001ec0:	0f b6 4c 14 08       	movzbl 0x8(%rsp,%rdx,1),%ecx
ffffffff80001ec5:	eb c5                	jmp    ffffffff80001e8c <acpi_init+0x2c>
ffffffff80001ec7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80001ece:	00 00 

ffffffff80001ed0 <pic_EOI>:

uint64_t ticks;

void pic_EOI(uint8_t IRQ)
{
    if(IRQ >= 8)
ffffffff80001ed0:	40 80 ff 07          	cmp    $0x7,%dil
ffffffff80001ed4:	77 12                	ja     ffffffff80001ee8 <pic_EOI+0x18>
    {
        outb(PIC2_CMD, PIC_EOI);
    }
    
    outb(PIC1_CMD, PIC_EOI);
ffffffff80001ed6:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff80001edb:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80001ee0:	e9 1b e5 ff ff       	jmpq   ffffffff80000400 <outb>
ffffffff80001ee5:	0f 1f 00             	nopl   (%rax)
{
ffffffff80001ee8:	48 83 ec 08          	sub    $0x8,%rsp
        outb(PIC2_CMD, PIC_EOI);
ffffffff80001eec:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff80001ef1:	bf a0 00 00 00       	mov    $0xa0,%edi
ffffffff80001ef6:	e8 05 e5 ff ff       	callq  ffffffff80000400 <outb>
    outb(PIC1_CMD, PIC_EOI);
ffffffff80001efb:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff80001f00:	bf 20 00 00 00       	mov    $0x20,%edi
}
ffffffff80001f05:	48 83 c4 08          	add    $0x8,%rsp
    outb(PIC1_CMD, PIC_EOI);
ffffffff80001f09:	e9 f2 e4 ff ff       	jmpq   ffffffff80000400 <outb>
ffffffff80001f0e:	66 90                	xchg   %ax,%ax

ffffffff80001f10 <pic_set_mask>:

void pic_set_mask(uint8_t IRQ)
{
ffffffff80001f10:	55                   	push   %rbp
ffffffff80001f11:	53                   	push   %rbx
ffffffff80001f12:	48 83 ec 08          	sub    $0x8,%rsp
    uint16_t port;
    uint8_t value;

    if(IRQ < 8)
ffffffff80001f16:	40 80 ff 07          	cmp    $0x7,%dil
ffffffff80001f1a:	76 34                	jbe    ffffffff80001f50 <pic_set_mask+0x40>
        port = PIC1_DATA;
    }
    else
    {
        port = PIC2_DATA;
        IRQ -= 8;
ffffffff80001f1c:	8d 6f f8             	lea    -0x8(%rdi),%ebp
ffffffff80001f1f:	bb a1 00 00 00       	mov    $0xa1,%ebx
    }
    value = inb(port) | (1 << IRQ);
ffffffff80001f24:	89 df                	mov    %ebx,%edi
ffffffff80001f26:	e8 e5 e4 ff ff       	callq  ffffffff80000410 <inb>
    outb(port, value);
}
ffffffff80001f2b:	48 83 c4 08          	add    $0x8,%rsp
    value = inb(port) | (1 << IRQ);
ffffffff80001f2f:	89 e9                	mov    %ebp,%ecx
ffffffff80001f31:	be 01 00 00 00       	mov    $0x1,%esi
    outb(port, value);
ffffffff80001f36:	89 df                	mov    %ebx,%edi
    value = inb(port) | (1 << IRQ);
ffffffff80001f38:	d3 e6                	shl    %cl,%esi
}
ffffffff80001f3a:	5b                   	pop    %rbx
ffffffff80001f3b:	5d                   	pop    %rbp
    value = inb(port) | (1 << IRQ);
ffffffff80001f3c:	09 f0                	or     %esi,%eax
    outb(port, value);
ffffffff80001f3e:	0f b6 f0             	movzbl %al,%esi
ffffffff80001f41:	e9 ba e4 ff ff       	jmpq   ffffffff80000400 <outb>
ffffffff80001f46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001f4d:	00 00 00 
ffffffff80001f50:	89 fd                	mov    %edi,%ebp
ffffffff80001f52:	bb 21 00 00 00       	mov    $0x21,%ebx
ffffffff80001f57:	eb cb                	jmp    ffffffff80001f24 <pic_set_mask+0x14>
ffffffff80001f59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80001f60 <pic_clear_mask>:

void pic_clear_mask(uint8_t IRQ)
{
ffffffff80001f60:	55                   	push   %rbp
ffffffff80001f61:	53                   	push   %rbx
ffffffff80001f62:	48 83 ec 08          	sub    $0x8,%rsp
    uint16_t port;
    uint8_t value;

    if(IRQ < 8)
ffffffff80001f66:	40 80 ff 07          	cmp    $0x7,%dil
ffffffff80001f6a:	76 34                	jbe    ffffffff80001fa0 <pic_clear_mask+0x40>
        port = PIC1_DATA;
    }
    else
    {
        port = PIC2_DATA;
        IRQ -= 8;
ffffffff80001f6c:	8d 6f f8             	lea    -0x8(%rdi),%ebp
ffffffff80001f6f:	bb a1 00 00 00       	mov    $0xa1,%ebx
    }
    value = inb(port) & ~(1 << IRQ);
ffffffff80001f74:	89 df                	mov    %ebx,%edi
ffffffff80001f76:	e8 95 e4 ff ff       	callq  ffffffff80000410 <inb>
    outb(port, value);
}
ffffffff80001f7b:	48 83 c4 08          	add    $0x8,%rsp
    value = inb(port) & ~(1 << IRQ);
ffffffff80001f7f:	89 e9                	mov    %ebp,%ecx
ffffffff80001f81:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
    outb(port, value);
ffffffff80001f86:	89 df                	mov    %ebx,%edi
    value = inb(port) & ~(1 << IRQ);
ffffffff80001f88:	d3 c2                	rol    %cl,%edx
}
ffffffff80001f8a:	5b                   	pop    %rbx
ffffffff80001f8b:	5d                   	pop    %rbp
    value = inb(port) & ~(1 << IRQ);
ffffffff80001f8c:	21 d0                	and    %edx,%eax
    outb(port, value);
ffffffff80001f8e:	0f b6 f0             	movzbl %al,%esi
ffffffff80001f91:	e9 6a e4 ff ff       	jmpq   ffffffff80000400 <outb>
ffffffff80001f96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001f9d:	00 00 00 
ffffffff80001fa0:	89 fd                	mov    %edi,%ebp
ffffffff80001fa2:	bb 21 00 00 00       	mov    $0x21,%ebx
ffffffff80001fa7:	eb cb                	jmp    ffffffff80001f74 <pic_clear_mask+0x14>
ffffffff80001fa9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80001fb0 <pic_disable>:

void pic_disable()
{
ffffffff80001fb0:	48 83 ec 08          	sub    $0x8,%rsp
    outb(PIC2_DATA, 0xff);
ffffffff80001fb4:	be ff 00 00 00       	mov    $0xff,%esi
ffffffff80001fb9:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff80001fbe:	e8 3d e4 ff ff       	callq  ffffffff80000400 <outb>
    outb(PIC1_DATA, 0xff);
ffffffff80001fc3:	be ff 00 00 00       	mov    $0xff,%esi
ffffffff80001fc8:	bf 21 00 00 00       	mov    $0x21,%edi
}
ffffffff80001fcd:	48 83 c4 08          	add    $0x8,%rsp
    outb(PIC1_DATA, 0xff);
ffffffff80001fd1:	e9 2a e4 ff ff       	jmpq   ffffffff80000400 <outb>
ffffffff80001fd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80001fdd:	00 00 00 

ffffffff80001fe0 <pic_remap>:

void pic_remap()
{
ffffffff80001fe0:	55                   	push   %rbp
ffffffff80001fe1:	53                   	push   %rbx
    uint8_t mask1 = inb(PIC1_DATA);
ffffffff80001fe2:	bf 21 00 00 00       	mov    $0x21,%edi
{
ffffffff80001fe7:	48 83 ec 08          	sub    $0x8,%rsp
    uint8_t mask1 = inb(PIC1_DATA);
ffffffff80001feb:	e8 20 e4 ff ff       	callq  ffffffff80000410 <inb>
    uint8_t mask2 = inb(PIC2_DATA);
ffffffff80001ff0:	bf a1 00 00 00       	mov    $0xa1,%edi
    uint8_t mask1 = inb(PIC1_DATA);
ffffffff80001ff5:	89 c5                	mov    %eax,%ebp
    uint8_t mask2 = inb(PIC2_DATA);
ffffffff80001ff7:	e8 14 e4 ff ff       	callq  ffffffff80000410 <inb>

    outb(PIC1_CMD, 0x11);
ffffffff80001ffc:	be 11 00 00 00       	mov    $0x11,%esi
ffffffff80002001:	bf 20 00 00 00       	mov    $0x20,%edi
    uint8_t mask2 = inb(PIC2_DATA);
ffffffff80002006:	89 c3                	mov    %eax,%ebx
    outb(PIC1_CMD, 0x11);
ffffffff80002008:	e8 f3 e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff8000200d:	31 c0                	xor    %eax,%eax
ffffffff8000200f:	e8 0c e4 ff ff       	callq  ffffffff80000420 <io_wait>
    outb(PIC2_CMD, 0x11);
ffffffff80002014:	be 11 00 00 00       	mov    $0x11,%esi
ffffffff80002019:	bf a0 00 00 00       	mov    $0xa0,%edi
ffffffff8000201e:	e8 dd e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff80002023:	31 c0                	xor    %eax,%eax
ffffffff80002025:	e8 f6 e3 ff ff       	callq  ffffffff80000420 <io_wait>

    outb(PIC1_DATA, 0x20);
ffffffff8000202a:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff8000202f:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff80002034:	e8 c7 e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff80002039:	31 c0                	xor    %eax,%eax
ffffffff8000203b:	e8 e0 e3 ff ff       	callq  ffffffff80000420 <io_wait>
    outb(PIC2_DATA, 0x20);
ffffffff80002040:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff80002045:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff8000204a:	e8 b1 e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff8000204f:	31 c0                	xor    %eax,%eax
ffffffff80002051:	e8 ca e3 ff ff       	callq  ffffffff80000420 <io_wait>

    outb(PIC1_DATA, 0x04);
ffffffff80002056:	be 04 00 00 00       	mov    $0x4,%esi
ffffffff8000205b:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff80002060:	e8 9b e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff80002065:	31 c0                	xor    %eax,%eax
ffffffff80002067:	e8 b4 e3 ff ff       	callq  ffffffff80000420 <io_wait>
    outb(PIC2_DATA, 0x02);
ffffffff8000206c:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff80002071:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff80002076:	e8 85 e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff8000207b:	31 c0                	xor    %eax,%eax
ffffffff8000207d:	e8 9e e3 ff ff       	callq  ffffffff80000420 <io_wait>

    outb(PIC1_DATA, 0x01);
ffffffff80002082:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff80002087:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff8000208c:	e8 6f e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff80002091:	31 c0                	xor    %eax,%eax
ffffffff80002093:	e8 88 e3 ff ff       	callq  ffffffff80000420 <io_wait>
    outb(PIC2_DATA, 0x01);
ffffffff80002098:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8000209d:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff800020a2:	e8 59 e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff800020a7:	31 c0                	xor    %eax,%eax
ffffffff800020a9:	e8 72 e3 ff ff       	callq  ffffffff80000420 <io_wait>

    outb(PIC1_DATA, mask1);
ffffffff800020ae:	40 0f b6 f5          	movzbl %bpl,%esi
ffffffff800020b2:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff800020b7:	e8 44 e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff800020bc:	31 c0                	xor    %eax,%eax
ffffffff800020be:	e8 5d e3 ff ff       	callq  ffffffff80000420 <io_wait>
    outb(PIC2_DATA, mask2);
ffffffff800020c3:	0f b6 f3             	movzbl %bl,%esi
ffffffff800020c6:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff800020cb:	e8 30 e3 ff ff       	callq  ffffffff80000400 <outb>
    io_wait();
ffffffff800020d0:	31 c0                	xor    %eax,%eax
}
ffffffff800020d2:	48 83 c4 08          	add    $0x8,%rsp
ffffffff800020d6:	5b                   	pop    %rbx
ffffffff800020d7:	5d                   	pop    %rbp
    io_wait();
ffffffff800020d8:	e9 43 e3 ff ff       	jmpq   ffffffff80000420 <io_wait>
ffffffff800020dd:	0f 1f 00             	nopl   (%rax)

ffffffff800020e0 <pit_init>:



void pit_init(uint64_t freq)
{
ffffffff800020e0:	53                   	push   %rbx
    if(freq > 1193181)
        working_freq = 1193181;

    uint32_t divisor = 1193180 / working_freq;

    outb(0x43, 0x36);
ffffffff800020e1:	be 36 00 00 00       	mov    $0x36,%esi
{
ffffffff800020e6:	48 89 fb             	mov    %rdi,%rbx
    outb(0x43, 0x36);
ffffffff800020e9:	bf 43 00 00 00       	mov    $0x43,%edi
ffffffff800020ee:	e8 0d e3 ff ff       	callq  ffffffff80000400 <outb>
    uint32_t divisor = 1193180 / working_freq;
ffffffff800020f3:	48 81 fb dd 34 12 00 	cmp    $0x1234dd,%rbx
ffffffff800020fa:	bf dd 34 12 00       	mov    $0x1234dd,%edi
ffffffff800020ff:	b8 10 27 00 00       	mov    $0x2710,%eax
ffffffff80002104:	48 0f 46 fb          	cmovbe %rbx,%rdi
ffffffff80002108:	48 81 ff 10 27 00 00 	cmp    $0x2710,%rdi
ffffffff8000210f:	48 0f 42 f8          	cmovb  %rax,%rdi
ffffffff80002113:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
ffffffff80002118:	31 d2                	xor    %edx,%edx
ffffffff8000211a:	48 f7 f7             	div    %rdi
    outb(0x40, divisor & 0xff);
ffffffff8000211d:	bf 40 00 00 00       	mov    $0x40,%edi
ffffffff80002122:	89 c6                	mov    %eax,%esi
ffffffff80002124:	e8 d7 e2 ff ff       	callq  ffffffff80000400 <outb>
    outb(0x40, divisor >> 8);
ffffffff80002129:	5b                   	pop    %rbx
    outb(0x40, divisor >> 8);
ffffffff8000212a:	31 f6                	xor    %esi,%esi
ffffffff8000212c:	bf 40 00 00 00       	mov    $0x40,%edi
ffffffff80002131:	e9 ca e2 ff ff       	jmpq   ffffffff80000400 <outb>
ffffffff80002136:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8000213d:	00 00 00 

ffffffff80002140 <_out_buffer>:


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  if (idx < maxlen) {
ffffffff80002140:	48 39 ca             	cmp    %rcx,%rdx
ffffffff80002143:	73 04                	jae    ffffffff80002149 <_out_buffer+0x9>
    ((char*)buffer)[idx] = character;
ffffffff80002145:	40 88 3c 16          	mov    %dil,(%rsi,%rdx,1)
  }
}
ffffffff80002149:	f3 c3                	repz retq 
ffffffff8000214b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80002150 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
ffffffff80002150:	f3 c3                	repz retq 
ffffffff80002152:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80002159:	00 00 00 00 
ffffffff8000215d:	0f 1f 00             	nopl   (%rax)

ffffffff80002160 <_out_fct>:

// internal output function wrapper
static inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)idx; (void)maxlen;
  if (character) {
ffffffff80002160:	40 84 ff             	test   %dil,%dil
{
ffffffff80002163:	48 89 f0             	mov    %rsi,%rax
  if (character) {
ffffffff80002166:	74 10                	je     ffffffff80002178 <_out_fct+0x18>
    // buffer is the output fct pointer
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
ffffffff80002168:	48 8b 76 08          	mov    0x8(%rsi),%rsi
ffffffff8000216c:	40 0f be ff          	movsbl %dil,%edi
ffffffff80002170:	ff 20                	jmpq   *(%rax)
ffffffff80002172:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  }
}
ffffffff80002178:	f3 c3                	repz retq 
ffffffff8000217a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80002180 <_ntoa_format>:
}


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
ffffffff80002180:	41 57                	push   %r15
ffffffff80002182:	41 56                	push   %r14
ffffffff80002184:	41 55                	push   %r13
ffffffff80002186:	41 54                	push   %r12
ffffffff80002188:	49 89 cd             	mov    %rcx,%r13
ffffffff8000218b:	55                   	push   %rbp
ffffffff8000218c:	53                   	push   %rbx
ffffffff8000218d:	48 89 fd             	mov    %rdi,%rbp
ffffffff80002190:	4c 89 c3             	mov    %r8,%rbx
ffffffff80002193:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff80002197:	8b 84 24 80 00 00 00 	mov    0x80(%rsp),%eax
ffffffff8000219e:	48 89 34 24          	mov    %rsi,(%rsp)
ffffffff800021a2:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
ffffffff800021a7:	8b 7c 24 60          	mov    0x60(%rsp),%edi
ffffffff800021ab:	89 c6                	mov    %eax,%esi
ffffffff800021ad:	89 c1                	mov    %eax,%ecx
  // pad leading zeros
  if (!(flags & FLAGS_LEFT)) {
ffffffff800021af:	89 c2                	mov    %eax,%edx
ffffffff800021b1:	83 e6 10             	and    $0x10,%esi
ffffffff800021b4:	83 e1 03             	and    $0x3,%ecx
ffffffff800021b7:	83 e2 02             	and    $0x2,%edx
ffffffff800021ba:	89 54 24 1c          	mov    %edx,0x1c(%rsp)
ffffffff800021be:	75 79                	jne    ffffffff80002239 <_ntoa_format+0xb9>
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
ffffffff800021c0:	44 8b 54 24 78       	mov    0x78(%rsp),%r10d
ffffffff800021c5:	41 89 c0             	mov    %eax,%r8d
ffffffff800021c8:	8b 54 24 70          	mov    0x70(%rsp),%edx
ffffffff800021cc:	41 83 e0 01          	and    $0x1,%r8d
ffffffff800021d0:	45 85 d2             	test   %r10d,%r10d
ffffffff800021d3:	0f 85 d7 00 00 00    	jne    ffffffff800022b0 <_ntoa_format+0x130>
      width--;
    }
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800021d9:	49 39 d1             	cmp    %rdx,%r9
ffffffff800021dc:	73 27                	jae    ffffffff80002205 <_ntoa_format+0x85>
ffffffff800021de:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff800021e2:	75 12                	jne    ffffffff800021f6 <_ntoa_format+0x76>
ffffffff800021e4:	e9 b7 02 00 00       	jmpq   ffffffff800024a0 <_ntoa_format+0x320>
ffffffff800021e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff800021f0:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff800021f4:	74 0f                	je     ffffffff80002205 <_ntoa_format+0x85>
      buf[len++] = '0';
ffffffff800021f6:	49 83 c1 01          	add    $0x1,%r9
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800021fa:	49 39 d1             	cmp    %rdx,%r9
      buf[len++] = '0';
ffffffff800021fd:	42 c6 44 0b ff 30    	movb   $0x30,-0x1(%rbx,%r9,1)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002203:	72 eb                	jb     ffffffff800021f0 <_ntoa_format+0x70>
    }
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002205:	45 85 c0             	test   %r8d,%r8d
ffffffff80002208:	74 2f                	je     ffffffff80002239 <_ntoa_format+0xb9>
ffffffff8000220a:	44 8b 74 24 78       	mov    0x78(%rsp),%r14d
ffffffff8000220f:	4d 39 ce             	cmp    %r9,%r14
ffffffff80002212:	76 25                	jbe    ffffffff80002239 <_ntoa_format+0xb9>
ffffffff80002214:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff80002218:	75 10                	jne    ffffffff8000222a <_ntoa_format+0xaa>
ffffffff8000221a:	e9 8b 03 00 00       	jmpq   ffffffff800025aa <_ntoa_format+0x42a>
ffffffff8000221f:	90                   	nop
ffffffff80002220:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff80002224:	0f 84 76 02 00 00    	je     ffffffff800024a0 <_ntoa_format+0x320>
      buf[len++] = '0';
ffffffff8000222a:	49 83 c1 01          	add    $0x1,%r9
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff8000222e:	4d 39 f1             	cmp    %r14,%r9
      buf[len++] = '0';
ffffffff80002231:	42 c6 44 0b ff 30    	movb   $0x30,-0x1(%rbx,%r9,1)
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002237:	75 e7                	jne    ffffffff80002220 <_ntoa_format+0xa0>
    }
  }

  // handle hash
  if (flags & FLAGS_HASH) {
ffffffff80002239:	85 f6                	test   %esi,%esi
ffffffff8000223b:	74 41                	je     ffffffff8000227e <_ntoa_format+0xfe>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff8000223d:	f6 c4 04             	test   $0x4,%ah
ffffffff80002240:	0f 85 5a 01 00 00    	jne    ffffffff800023a0 <_ntoa_format+0x220>
ffffffff80002246:	4d 85 c9             	test   %r9,%r9
ffffffff80002249:	0f 85 31 01 00 00    	jne    ffffffff80002380 <_ntoa_format+0x200>
      len--;
      if (len && (base == 16U)) {
        len--;
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff8000224f:	83 7c 24 68 10       	cmpl   $0x10,0x68(%rsp)
ffffffff80002254:	0f 84 2f 03 00 00    	je     ffffffff80002589 <_ntoa_format+0x409>
      buf[len++] = 'x';
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
      buf[len++] = 'X';
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff8000225a:	83 7c 24 68 02       	cmpl   $0x2,0x68(%rsp)
ffffffff8000225f:	0f 85 37 03 00 00    	jne    ffffffff8000259c <_ntoa_format+0x41c>
      buf[len++] = 'b';
ffffffff80002265:	c6 03 62             	movb   $0x62,(%rbx)
ffffffff80002268:	48 c7 44 24 10 01 00 	movq   $0x1,0x10(%rsp)
ffffffff8000226f:	00 00 
ffffffff80002271:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
ffffffff80002276:	4c 8d 4e 01          	lea    0x1(%rsi),%r9
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
      buf[len++] = '0';
ffffffff8000227a:	c6 04 33 30          	movb   $0x30,(%rbx,%rsi,1)
    }
  }

  if (len < PRINTF_NTOA_BUFFER_SIZE) {
ffffffff8000227e:	49 83 f9 20          	cmp    $0x20,%r9
ffffffff80002282:	0f 84 38 02 00 00    	je     ffffffff800024c0 <_ntoa_format+0x340>
    if (negative) {
ffffffff80002288:	40 84 ff             	test   %dil,%dil
ffffffff8000228b:	75 4b                	jne    ffffffff800022d8 <_ntoa_format+0x158>
      buf[len++] = '-';
    }
    else if (flags & FLAGS_PLUS) {
ffffffff8000228d:	a8 04                	test   $0x4,%al
ffffffff8000228f:	0f 85 a3 01 00 00    	jne    ffffffff80002438 <_ntoa_format+0x2b8>
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
ffffffff80002295:	a8 08                	test   $0x8,%al
ffffffff80002297:	0f 84 9b 02 00 00    	je     ffffffff80002538 <_ntoa_format+0x3b8>
      buf[len++] = ' ';
ffffffff8000229d:	49 8d 41 01          	lea    0x1(%r9),%rax
ffffffff800022a1:	42 c6 04 0b 20       	movb   $0x20,(%rbx,%r9,1)
ffffffff800022a6:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff800022ab:	eb 39                	jmp    ffffffff800022e6 <_ntoa_format+0x166>
ffffffff800022ad:	0f 1f 00             	nopl   (%rax)
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
ffffffff800022b0:	45 85 c0             	test   %r8d,%r8d
ffffffff800022b3:	0f 84 97 01 00 00    	je     ffffffff80002450 <_ntoa_format+0x2d0>
ffffffff800022b9:	40 84 ff             	test   %dil,%dil
ffffffff800022bc:	75 04                	jne    ffffffff800022c2 <_ntoa_format+0x142>
ffffffff800022be:	a8 0c                	test   $0xc,%al
ffffffff800022c0:	74 05                	je     ffffffff800022c7 <_ntoa_format+0x147>
      width--;
ffffffff800022c2:	83 6c 24 78 01       	subl   $0x1,0x78(%rsp)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800022c7:	49 39 d1             	cmp    %rdx,%r9
ffffffff800022ca:	0f 82 0e ff ff ff    	jb     ffffffff800021de <_ntoa_format+0x5e>
ffffffff800022d0:	e9 35 ff ff ff       	jmpq   ffffffff8000220a <_ntoa_format+0x8a>
ffffffff800022d5:	0f 1f 00             	nopl   (%rax)
      buf[len++] = '-';
ffffffff800022d8:	49 8d 41 01          	lea    0x1(%r9),%rax
ffffffff800022dc:	42 c6 04 0b 2d       	movb   $0x2d,(%rbx,%r9,1)
ffffffff800022e1:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800022e6:	85 c9                	test   %ecx,%ecx
ffffffff800022e8:	0f 84 fa 00 00 00    	je     ffffffff800023e8 <_ntoa_format+0x268>
ffffffff800022ee:	4c 8b 7c 24 08       	mov    0x8(%rsp),%r15
    for (size_t i = len; i < width; i++) {
ffffffff800022f3:	4c 8b 64 24 10       	mov    0x10(%rsp),%r12
ffffffff800022f8:	4c 89 fa             	mov    %r15,%rdx
ffffffff800022fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    out(buf[--len], buffer, idx++, maxlen);
ffffffff80002300:	49 83 ec 01          	sub    $0x1,%r12
ffffffff80002304:	4c 8d 72 01          	lea    0x1(%rdx),%r14
ffffffff80002308:	4c 89 e9             	mov    %r13,%rcx
ffffffff8000230b:	42 0f be 3c 23       	movsbl (%rbx,%r12,1),%edi
ffffffff80002310:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002314:	ff d5                	callq  *%rbp
  while (len) {
ffffffff80002316:	4d 85 e4             	test   %r12,%r12
    out(buf[--len], buffer, idx++, maxlen);
ffffffff80002319:	4c 89 f2             	mov    %r14,%rdx
  while (len) {
ffffffff8000231c:	75 e2                	jne    ffffffff80002300 <_ntoa_format+0x180>
ffffffff8000231e:	4c 03 7c 24 10       	add    0x10(%rsp),%r15
  if (flags & FLAGS_LEFT) {
ffffffff80002323:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
ffffffff80002327:	85 c0                	test   %eax,%eax
ffffffff80002329:	74 3a                	je     ffffffff80002365 <_ntoa_format+0x1e5>
    while (idx - start_idx < width) {
ffffffff8000232b:	44 8b 74 24 78       	mov    0x78(%rsp),%r14d
ffffffff80002330:	4c 89 fa             	mov    %r15,%rdx
ffffffff80002333:	48 2b 54 24 08       	sub    0x8(%rsp),%rdx
ffffffff80002338:	49 39 d6             	cmp    %rdx,%r14
ffffffff8000233b:	76 28                	jbe    ffffffff80002365 <_ntoa_format+0x1e5>
ffffffff8000233d:	0f 1f 00             	nopl   (%rax)
      out(' ', buffer, idx++, maxlen);
ffffffff80002340:	49 8d 5f 01          	lea    0x1(%r15),%rbx
ffffffff80002344:	4c 89 fa             	mov    %r15,%rdx
ffffffff80002347:	4c 89 e9             	mov    %r13,%rcx
ffffffff8000234a:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000234e:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80002353:	ff d5                	callq  *%rbp
    while (idx - start_idx < width) {
ffffffff80002355:	48 89 da             	mov    %rbx,%rdx
ffffffff80002358:	48 2b 54 24 08       	sub    0x8(%rsp),%rdx
      out(' ', buffer, idx++, maxlen);
ffffffff8000235d:	49 89 df             	mov    %rbx,%r15
    while (idx - start_idx < width) {
ffffffff80002360:	4c 39 f2             	cmp    %r14,%rdx
ffffffff80002363:	72 db                	jb     ffffffff80002340 <_ntoa_format+0x1c0>
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
}
ffffffff80002365:	48 83 c4 28          	add    $0x28,%rsp
ffffffff80002369:	4c 89 f8             	mov    %r15,%rax
ffffffff8000236c:	5b                   	pop    %rbx
ffffffff8000236d:	5d                   	pop    %rbp
ffffffff8000236e:	41 5c                	pop    %r12
ffffffff80002370:	41 5d                	pop    %r13
ffffffff80002372:	41 5e                	pop    %r14
ffffffff80002374:	41 5f                	pop    %r15
ffffffff80002376:	c3                   	retq   
ffffffff80002377:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000237e:	00 00 
ffffffff80002380:	8b 54 24 70          	mov    0x70(%rsp),%edx
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff80002384:	4c 39 ca             	cmp    %r9,%rdx
ffffffff80002387:	0f 84 e3 00 00 00    	je     ffffffff80002470 <_ntoa_format+0x2f0>
ffffffff8000238d:	8b 54 24 78          	mov    0x78(%rsp),%edx
ffffffff80002391:	4c 39 ca             	cmp    %r9,%rdx
ffffffff80002394:	0f 84 d6 00 00 00    	je     ffffffff80002470 <_ntoa_format+0x2f0>
ffffffff8000239a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff800023a0:	49 83 f9 1f          	cmp    $0x1f,%r9
ffffffff800023a4:	0f 96 c2             	setbe  %dl
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800023a7:	83 7c 24 68 10       	cmpl   $0x10,0x68(%rsp)
ffffffff800023ac:	0f 84 1e 01 00 00    	je     ffffffff800024d0 <_ntoa_format+0x350>
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800023b2:	83 7c 24 68 02       	cmpl   $0x2,0x68(%rsp)
ffffffff800023b7:	0f 85 a3 00 00 00    	jne    ffffffff80002460 <_ntoa_format+0x2e0>
ffffffff800023bd:	84 d2                	test   %dl,%dl
ffffffff800023bf:	0f 84 9b 00 00 00    	je     ffffffff80002460 <_ntoa_format+0x2e0>
ffffffff800023c5:	49 8d 71 01          	lea    0x1(%r9),%rsi
      buf[len++] = 'b';
ffffffff800023c9:	42 c6 04 0b 62       	movb   $0x62,(%rbx,%r9,1)
ffffffff800023ce:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
ffffffff800023d3:	48 83 7c 24 10 1f    	cmpq   $0x1f,0x10(%rsp)
ffffffff800023d9:	0f 86 92 fe ff ff    	jbe    ffffffff80002271 <_ntoa_format+0xf1>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800023df:	85 c9                	test   %ecx,%ecx
ffffffff800023e1:	4c 8b 7c 24 08       	mov    0x8(%rsp),%r15
ffffffff800023e6:	75 3a                	jne    ffffffff80002422 <_ntoa_format+0x2a2>
ffffffff800023e8:	44 8b 74 24 78       	mov    0x78(%rsp),%r14d
    for (size_t i = len; i < width; i++) {
ffffffff800023ed:	4c 3b 74 24 10       	cmp    0x10(%rsp),%r14
ffffffff800023f2:	0f 86 50 01 00 00    	jbe    ffffffff80002548 <_ntoa_format+0x3c8>
ffffffff800023f8:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
ffffffff800023fd:	49 01 d6             	add    %rdx,%r14
ffffffff80002400:	4c 2b 74 24 10       	sub    0x10(%rsp),%r14
ffffffff80002405:	0f 1f 00             	nopl   (%rax)
      out(' ', buffer, idx++, maxlen);
ffffffff80002408:	4c 8d 7a 01          	lea    0x1(%rdx),%r15
ffffffff8000240c:	4c 89 e9             	mov    %r13,%rcx
ffffffff8000240f:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002413:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80002418:	ff d5                	callq  *%rbp
    for (size_t i = len; i < width; i++) {
ffffffff8000241a:	4d 39 f7             	cmp    %r14,%r15
ffffffff8000241d:	4c 89 fa             	mov    %r15,%rdx
ffffffff80002420:	75 e6                	jne    ffffffff80002408 <_ntoa_format+0x288>
  while (len) {
ffffffff80002422:	48 83 7c 24 10 00    	cmpq   $0x0,0x10(%rsp)
ffffffff80002428:	0f 85 c5 fe ff ff    	jne    ffffffff800022f3 <_ntoa_format+0x173>
ffffffff8000242e:	e9 f0 fe ff ff       	jmpq   ffffffff80002323 <_ntoa_format+0x1a3>
ffffffff80002433:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      buf[len++] = '+';  // ignore the space if the '+' exists
ffffffff80002438:	49 8d 41 01          	lea    0x1(%r9),%rax
ffffffff8000243c:	42 c6 04 0b 2b       	movb   $0x2b,(%rbx,%r9,1)
ffffffff80002441:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff80002446:	e9 9b fe ff ff       	jmpq   ffffffff800022e6 <_ntoa_format+0x166>
ffffffff8000244b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002450:	49 39 d1             	cmp    %rdx,%r9
ffffffff80002453:	0f 82 85 fd ff ff    	jb     ffffffff800021de <_ntoa_format+0x5e>
ffffffff80002459:	e9 db fd ff ff       	jmpq   ffffffff80002239 <_ntoa_format+0xb9>
ffffffff8000245e:	66 90                	xchg   %ax,%ax
ffffffff80002460:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
ffffffff80002465:	e9 69 ff ff ff       	jmpq   ffffffff800023d3 <_ntoa_format+0x253>
ffffffff8000246a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      if (len && (base == 16U)) {
ffffffff80002470:	4d 89 c8             	mov    %r9,%r8
ffffffff80002473:	49 83 e8 01          	sub    $0x1,%r8
ffffffff80002477:	0f 95 c2             	setne  %dl
ffffffff8000247a:	83 7c 24 68 10       	cmpl   $0x10,0x68(%rsp)
ffffffff8000247f:	40 0f 94 c6          	sete   %sil
ffffffff80002483:	40 20 f2             	and    %sil,%dl
ffffffff80002486:	0f 84 d9 00 00 00    	je     ffffffff80002565 <_ntoa_format+0x3e5>
        len--;
ffffffff8000248c:	49 8d 71 fe          	lea    -0x2(%r9),%rsi
ffffffff80002490:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
ffffffff80002495:	eb 3e                	jmp    ffffffff800024d5 <_ntoa_format+0x355>
ffffffff80002497:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000249e:	00 00 
  if (flags & FLAGS_HASH) {
ffffffff800024a0:	85 f6                	test   %esi,%esi
ffffffff800024a2:	74 6c                	je     ffffffff80002510 <_ntoa_format+0x390>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff800024a4:	f6 c4 04             	test   $0x4,%ah
ffffffff800024a7:	41 b9 20 00 00 00    	mov    $0x20,%r9d
ffffffff800024ad:	0f 84 d1 fe ff ff    	je     ffffffff80002384 <_ntoa_format+0x204>
ffffffff800024b3:	e9 e8 fe ff ff       	jmpq   ffffffff800023a0 <_ntoa_format+0x220>
ffffffff800024b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff800024bf:	00 
ffffffff800024c0:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff800024c7:	00 00 
ffffffff800024c9:	e9 18 fe ff ff       	jmpq   ffffffff800022e6 <_ntoa_format+0x166>
ffffffff800024ce:	66 90                	xchg   %ax,%ax
ffffffff800024d0:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800024d5:	89 c6                	mov    %eax,%esi
ffffffff800024d7:	83 e6 20             	and    $0x20,%esi
ffffffff800024da:	75 08                	jne    ffffffff800024e4 <_ntoa_format+0x364>
ffffffff800024dc:	84 d2                	test   %dl,%dl
ffffffff800024de:	0f 85 8e 00 00 00    	jne    ffffffff80002572 <_ntoa_format+0x3f2>
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff800024e4:	85 f6                	test   %esi,%esi
ffffffff800024e6:	0f 84 e7 fe ff ff    	je     ffffffff800023d3 <_ntoa_format+0x253>
ffffffff800024ec:	84 d2                	test   %dl,%dl
ffffffff800024ee:	0f 84 df fe ff ff    	je     ffffffff800023d3 <_ntoa_format+0x253>
      buf[len++] = 'X';
ffffffff800024f4:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
ffffffff800024f9:	c6 04 33 58          	movb   $0x58,(%rbx,%rsi,1)
ffffffff800024fd:	48 83 c6 01          	add    $0x1,%rsi
ffffffff80002501:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
ffffffff80002506:	e9 c8 fe ff ff       	jmpq   ffffffff800023d3 <_ntoa_format+0x253>
ffffffff8000250b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff80002510:	85 c9                	test   %ecx,%ecx
ffffffff80002512:	75 3e                	jne    ffffffff80002552 <_ntoa_format+0x3d2>
ffffffff80002514:	44 8b 74 24 78       	mov    0x78(%rsp),%r14d
    for (size_t i = len; i < width; i++) {
ffffffff80002519:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff80002520:	00 00 
ffffffff80002522:	49 83 fe 20          	cmp    $0x20,%r14
ffffffff80002526:	0f 87 cc fe ff ff    	ja     ffffffff800023f8 <_ntoa_format+0x278>
ffffffff8000252c:	e9 bd fd ff ff       	jmpq   ffffffff800022ee <_ntoa_format+0x16e>
ffffffff80002531:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
ffffffff80002538:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
ffffffff8000253d:	e9 9d fe ff ff       	jmpq   ffffffff800023df <_ntoa_format+0x25f>
ffffffff80002542:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
ffffffff80002548:	4c 8b 7c 24 08       	mov    0x8(%rsp),%r15
ffffffff8000254d:	e9 d0 fe ff ff       	jmpq   ffffffff80002422 <_ntoa_format+0x2a2>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff80002552:	4c 8b 7c 24 08       	mov    0x8(%rsp),%r15
ffffffff80002557:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff8000255e:	00 00 
ffffffff80002560:	e9 8e fd ff ff       	jmpq   ffffffff800022f3 <_ntoa_format+0x173>
      len--;
ffffffff80002565:	4d 89 c1             	mov    %r8,%r9
ffffffff80002568:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff8000256d:	e9 35 fe ff ff       	jmpq   ffffffff800023a7 <_ntoa_format+0x227>
      buf[len++] = 'x';
ffffffff80002572:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
ffffffff80002577:	c6 04 33 78          	movb   $0x78,(%rbx,%rsi,1)
ffffffff8000257b:	48 83 c6 01          	add    $0x1,%rsi
ffffffff8000257f:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
ffffffff80002584:	e9 4a fe ff ff       	jmpq   ffffffff800023d3 <_ntoa_format+0x253>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
ffffffff80002589:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
ffffffff80002590:	00 00 
ffffffff80002592:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80002597:	e9 39 ff ff ff       	jmpq   ffffffff800024d5 <_ntoa_format+0x355>
      buf[len++] = '0';
ffffffff8000259c:	c6 03 30             	movb   $0x30,(%rbx)
ffffffff8000259f:	41 b9 01 00 00 00    	mov    $0x1,%r9d
ffffffff800025a5:	e9 de fc ff ff       	jmpq   ffffffff80002288 <_ntoa_format+0x108>
  if (flags & FLAGS_HASH) {
ffffffff800025aa:	85 f6                	test   %esi,%esi
ffffffff800025ac:	74 17                	je     ffffffff800025c5 <_ntoa_format+0x445>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
ffffffff800025ae:	f6 c4 04             	test   $0x4,%ah
ffffffff800025b1:	0f 84 cd fd ff ff    	je     ffffffff80002384 <_ntoa_format+0x204>
ffffffff800025b7:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff800025be:	00 00 
ffffffff800025c0:	e9 1a fe ff ff       	jmpq   ffffffff800023df <_ntoa_format+0x25f>
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800025c5:	85 c9                	test   %ecx,%ecx
    for (size_t i = len; i < width; i++) {
ffffffff800025c7:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
ffffffff800025ce:	00 00 
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
ffffffff800025d0:	0f 85 18 fd ff ff    	jne    ffffffff800022ee <_ntoa_format+0x16e>
    for (size_t i = len; i < width; i++) {
ffffffff800025d6:	49 83 fe 20          	cmp    $0x20,%r14
ffffffff800025da:	0f 87 18 fe ff ff    	ja     ffffffff800023f8 <_ntoa_format+0x278>
ffffffff800025e0:	e9 09 fd ff ff       	jmpq   ffffffff800022ee <_ntoa_format+0x16e>
ffffffff800025e5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800025ec:	00 00 00 00 

ffffffff800025f0 <_ntoa_long>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
ffffffff800025f0:	41 55                	push   %r13
ffffffff800025f2:	41 54                	push   %r12
ffffffff800025f4:	4c 89 c0             	mov    %r8,%rax
ffffffff800025f7:	55                   	push   %rbp
ffffffff800025f8:	53                   	push   %rbx
ffffffff800025f9:	48 89 d3             	mov    %rdx,%rbx
ffffffff800025fc:	48 83 ec 28          	sub    $0x28,%rsp
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
ffffffff80002600:	4d 85 c0             	test   %r8,%r8
{
ffffffff80002603:	4c 8b 54 24 50       	mov    0x50(%rsp),%r10
ffffffff80002608:	8b 6c 24 68          	mov    0x68(%rsp),%ebp
  if (!value) {
ffffffff8000260c:	75 13                	jne    ffffffff80002621 <_ntoa_long+0x31>
    flags &= ~FLAGS_HASH;
ffffffff8000260e:	89 ea                	mov    %ebp,%edx
ffffffff80002610:	83 e2 ef             	and    $0xffffffef,%edx
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff80002613:	81 e5 00 04 00 00    	and    $0x400,%ebp
    flags &= ~FLAGS_HASH;
ffffffff80002619:	89 d5                	mov    %edx,%ebp
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff8000261b:	0f 85 7f 00 00 00    	jne    ffffffff800026a0 <_ntoa_long+0xb0>
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80002621:	89 ea                	mov    %ebp,%edx
ffffffff80002623:	83 e2 20             	and    $0x20,%edx
ffffffff80002626:	83 fa 01             	cmp    $0x1,%edx
ffffffff80002629:	45 19 db             	sbb    %r11d,%r11d
ffffffff8000262c:	45 31 c0             	xor    %r8d,%r8d
ffffffff8000262f:	41 83 e3 20          	and    $0x20,%r11d
ffffffff80002633:	41 83 c3 37          	add    $0x37,%r11d
ffffffff80002637:	eb 0d                	jmp    ffffffff80002646 <_ntoa_long+0x56>
ffffffff80002639:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002640:	49 83 f8 1f          	cmp    $0x1f,%r8
ffffffff80002644:	77 26                	ja     ffffffff8000266c <_ntoa_long+0x7c>
ffffffff80002646:	31 d2                	xor    %edx,%edx
ffffffff80002648:	49 f7 f2             	div    %r10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff8000264b:	44 8d 6a 30          	lea    0x30(%rdx),%r13d
ffffffff8000264f:	45 8d 24 13          	lea    (%r11,%rdx,1),%r12d
ffffffff80002653:	48 83 fa 09          	cmp    $0x9,%rdx
ffffffff80002657:	44 89 ea             	mov    %r13d,%edx
ffffffff8000265a:	41 0f 47 d4          	cmova  %r12d,%edx
ffffffff8000265e:	49 83 c0 01          	add    $0x1,%r8
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002662:	48 85 c0             	test   %rax,%rax
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80002665:	42 88 54 04 ff       	mov    %dl,-0x1(%rsp,%r8,1)
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff8000266a:	75 d4                	jne    ffffffff80002640 <_ntoa_long+0x50>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
ffffffff8000266c:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80002670:	45 0f b6 c9          	movzbl %r9b,%r9d
ffffffff80002674:	48 89 da             	mov    %rbx,%rdx
ffffffff80002677:	55                   	push   %rbp
ffffffff80002678:	8b 44 24 70          	mov    0x70(%rsp),%eax
ffffffff8000267c:	50                   	push   %rax
ffffffff8000267d:	8b 44 24 70          	mov    0x70(%rsp),%eax
ffffffff80002681:	50                   	push   %rax
ffffffff80002682:	41 52                	push   %r10
ffffffff80002684:	41 51                	push   %r9
ffffffff80002686:	4d 89 c1             	mov    %r8,%r9
ffffffff80002689:	4c 8d 44 24 30       	lea    0x30(%rsp),%r8
ffffffff8000268e:	e8 ed fa ff ff       	callq  ffffffff80002180 <_ntoa_format>
}
ffffffff80002693:	48 83 c4 58          	add    $0x58,%rsp
ffffffff80002697:	5b                   	pop    %rbx
ffffffff80002698:	5d                   	pop    %rbp
ffffffff80002699:	41 5c                	pop    %r12
ffffffff8000269b:	41 5d                	pop    %r13
ffffffff8000269d:	c3                   	retq   
ffffffff8000269e:	66 90                	xchg   %ax,%ax
  size_t len = 0U;
ffffffff800026a0:	45 31 c0             	xor    %r8d,%r8d
ffffffff800026a3:	eb c7                	jmp    ffffffff8000266c <_ntoa_long+0x7c>
ffffffff800026a5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800026ac:	00 00 00 00 

ffffffff800026b0 <_ntoa_long_long>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
ffffffff800026b0:	41 55                	push   %r13
ffffffff800026b2:	41 54                	push   %r12
ffffffff800026b4:	4c 89 c0             	mov    %r8,%rax
ffffffff800026b7:	55                   	push   %rbp
ffffffff800026b8:	53                   	push   %rbx
ffffffff800026b9:	48 89 d3             	mov    %rdx,%rbx
ffffffff800026bc:	48 83 ec 28          	sub    $0x28,%rsp
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;

  // no hash for 0 values
  if (!value) {
ffffffff800026c0:	4d 85 c0             	test   %r8,%r8
{
ffffffff800026c3:	4c 8b 54 24 50       	mov    0x50(%rsp),%r10
ffffffff800026c8:	8b 6c 24 68          	mov    0x68(%rsp),%ebp
  if (!value) {
ffffffff800026cc:	75 13                	jne    ffffffff800026e1 <_ntoa_long_long+0x31>
    flags &= ~FLAGS_HASH;
ffffffff800026ce:	89 ea                	mov    %ebp,%edx
ffffffff800026d0:	83 e2 ef             	and    $0xffffffef,%edx
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff800026d3:	81 e5 00 04 00 00    	and    $0x400,%ebp
    flags &= ~FLAGS_HASH;
ffffffff800026d9:	89 d5                	mov    %edx,%ebp
  if (!(flags & FLAGS_PRECISION) || value) {
ffffffff800026db:	0f 85 7f 00 00 00    	jne    ffffffff80002760 <_ntoa_long_long+0xb0>
    do {
      const char digit = (char)(value % base);
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff800026e1:	89 ea                	mov    %ebp,%edx
ffffffff800026e3:	83 e2 20             	and    $0x20,%edx
ffffffff800026e6:	83 fa 01             	cmp    $0x1,%edx
ffffffff800026e9:	45 19 db             	sbb    %r11d,%r11d
ffffffff800026ec:	45 31 c0             	xor    %r8d,%r8d
ffffffff800026ef:	41 83 e3 20          	and    $0x20,%r11d
ffffffff800026f3:	41 83 c3 37          	add    $0x37,%r11d
ffffffff800026f7:	eb 0d                	jmp    ffffffff80002706 <_ntoa_long_long+0x56>
ffffffff800026f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002700:	49 83 f8 1f          	cmp    $0x1f,%r8
ffffffff80002704:	77 26                	ja     ffffffff8000272c <_ntoa_long_long+0x7c>
ffffffff80002706:	31 d2                	xor    %edx,%edx
ffffffff80002708:	49 f7 f2             	div    %r10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff8000270b:	44 8d 6a 30          	lea    0x30(%rdx),%r13d
ffffffff8000270f:	45 8d 24 13          	lea    (%r11,%rdx,1),%r12d
ffffffff80002713:	48 83 fa 09          	cmp    $0x9,%rdx
ffffffff80002717:	44 89 ea             	mov    %r13d,%edx
ffffffff8000271a:	41 0f 47 d4          	cmova  %r12d,%edx
ffffffff8000271e:	49 83 c0 01          	add    $0x1,%r8
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff80002722:	48 85 c0             	test   %rax,%rax
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
ffffffff80002725:	42 88 54 04 ff       	mov    %dl,-0x1(%rsp,%r8,1)
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
ffffffff8000272a:	75 d4                	jne    ffffffff80002700 <_ntoa_long_long+0x50>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
ffffffff8000272c:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80002730:	45 0f b6 c9          	movzbl %r9b,%r9d
ffffffff80002734:	48 89 da             	mov    %rbx,%rdx
ffffffff80002737:	55                   	push   %rbp
ffffffff80002738:	8b 44 24 70          	mov    0x70(%rsp),%eax
ffffffff8000273c:	50                   	push   %rax
ffffffff8000273d:	8b 44 24 70          	mov    0x70(%rsp),%eax
ffffffff80002741:	50                   	push   %rax
ffffffff80002742:	41 52                	push   %r10
ffffffff80002744:	41 51                	push   %r9
ffffffff80002746:	4d 89 c1             	mov    %r8,%r9
ffffffff80002749:	4c 8d 44 24 30       	lea    0x30(%rsp),%r8
ffffffff8000274e:	e8 2d fa ff ff       	callq  ffffffff80002180 <_ntoa_format>
}
ffffffff80002753:	48 83 c4 58          	add    $0x58,%rsp
ffffffff80002757:	5b                   	pop    %rbx
ffffffff80002758:	5d                   	pop    %rbp
ffffffff80002759:	41 5c                	pop    %r12
ffffffff8000275b:	41 5d                	pop    %r13
ffffffff8000275d:	c3                   	retq   
ffffffff8000275e:	66 90                	xchg   %ax,%ax
  size_t len = 0U;
ffffffff80002760:	45 31 c0             	xor    %r8d,%r8d
ffffffff80002763:	eb c7                	jmp    ffffffff8000272c <_ntoa_long_long+0x7c>
ffffffff80002765:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8000276c:	00 00 00 00 

ffffffff80002770 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
ffffffff80002770:	41 57                	push   %r15
ffffffff80002772:	41 56                	push   %r14
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
ffffffff80002774:	48 c7 c0 50 21 00 80 	mov    $0xffffffff80002150,%rax
{
ffffffff8000277b:	41 55                	push   %r13
ffffffff8000277d:	41 54                	push   %r12
ffffffff8000277f:	49 89 f7             	mov    %rsi,%r15
ffffffff80002782:	55                   	push   %rbp
ffffffff80002783:	53                   	push   %rbx
ffffffff80002784:	48 89 fd             	mov    %rdi,%rbp
ffffffff80002787:	49 89 d6             	mov    %rdx,%r14
ffffffff8000278a:	49 89 cd             	mov    %rcx,%r13
ffffffff8000278d:	48 83 ec 38          	sub    $0x38,%rsp
    out = _out_null;
ffffffff80002791:	48 85 f6             	test   %rsi,%rsi
ffffffff80002794:	48 0f 44 e8          	cmove  %rax,%rbp
{
ffffffff80002798:	4c 89 04 24          	mov    %r8,(%rsp)
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
ffffffff8000279c:	31 db                	xor    %ebx,%ebx
  while (*format)
ffffffff8000279e:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
ffffffff800027a3:	40 84 ff             	test   %dil,%dil
ffffffff800027a6:	74 26                	je     ffffffff800027ce <_vsnprintf+0x5e>
ffffffff800027a8:	49 83 c5 01          	add    $0x1,%r13
    if (*format != '%') {
ffffffff800027ac:	40 80 ff 25          	cmp    $0x25,%dil
ffffffff800027b0:	74 46                	je     ffffffff800027f8 <_vsnprintf+0x88>
      out(*format, buffer, idx++, maxlen);
ffffffff800027b2:	4c 8d 63 01          	lea    0x1(%rbx),%r12
        out(*format, buffer, idx++, maxlen);
ffffffff800027b6:	48 89 da             	mov    %rbx,%rdx
ffffffff800027b9:	4c 89 f1             	mov    %r14,%rcx
ffffffff800027bc:	4c 89 fe             	mov    %r15,%rsi
ffffffff800027bf:	ff d5                	callq  *%rbp
  while (*format)
ffffffff800027c1:	41 0f be 7d 00       	movsbl 0x0(%r13),%edi
        out(*format, buffer, idx++, maxlen);
ffffffff800027c6:	4c 89 e3             	mov    %r12,%rbx
  while (*format)
ffffffff800027c9:	40 84 ff             	test   %dil,%dil
ffffffff800027cc:	75 da                	jne    ffffffff800027a8 <_vsnprintf+0x38>
        break;
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
ffffffff800027ce:	49 8d 56 ff          	lea    -0x1(%r14),%rdx
ffffffff800027d2:	4c 39 f3             	cmp    %r14,%rbx
ffffffff800027d5:	4c 89 f1             	mov    %r14,%rcx
ffffffff800027d8:	4c 89 fe             	mov    %r15,%rsi
ffffffff800027db:	48 0f 42 d3          	cmovb  %rbx,%rdx
ffffffff800027df:	31 ff                	xor    %edi,%edi
ffffffff800027e1:	ff d5                	callq  *%rbp

  // return written chars without terminating \0
  return (int)idx;
}
ffffffff800027e3:	48 83 c4 38          	add    $0x38,%rsp
ffffffff800027e7:	89 d8                	mov    %ebx,%eax
ffffffff800027e9:	5b                   	pop    %rbx
ffffffff800027ea:	5d                   	pop    %rbp
ffffffff800027eb:	41 5c                	pop    %r12
ffffffff800027ed:	41 5d                	pop    %r13
ffffffff800027ef:	41 5e                	pop    %r14
ffffffff800027f1:	41 5f                	pop    %r15
ffffffff800027f3:	c3                   	retq   
ffffffff800027f4:	0f 1f 40 00          	nopl   0x0(%rax)
    flags = 0U;
ffffffff800027f8:	31 c9                	xor    %ecx,%ecx
ffffffff800027fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
      switch (*format) {
ffffffff80002800:	41 0f be 45 00       	movsbl 0x0(%r13),%eax
ffffffff80002805:	49 8d 75 01          	lea    0x1(%r13),%rsi
ffffffff80002809:	48 89 f7             	mov    %rsi,%rdi
ffffffff8000280c:	8d 50 e0             	lea    -0x20(%rax),%edx
ffffffff8000280f:	80 fa 10             	cmp    $0x10,%dl
ffffffff80002812:	77 3c                	ja     ffffffff80002850 <_vsnprintf+0xe0>
ffffffff80002814:	0f b6 d2             	movzbl %dl,%edx
ffffffff80002817:	ff 24 d5 40 4b 00 80 	jmpq   *-0x7fffb4c0(,%rdx,8)
ffffffff8000281e:	66 90                	xchg   %ax,%ax
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
ffffffff80002820:	83 c9 01             	or     $0x1,%ecx
ffffffff80002823:	49 89 f5             	mov    %rsi,%r13
ffffffff80002826:	eb d8                	jmp    ffffffff80002800 <_vsnprintf+0x90>
ffffffff80002828:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000282f:	00 
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
ffffffff80002830:	83 c9 04             	or     $0x4,%ecx
ffffffff80002833:	eb ee                	jmp    ffffffff80002823 <_vsnprintf+0xb3>
ffffffff80002835:	0f 1f 00             	nopl   (%rax)
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
ffffffff80002838:	83 c9 02             	or     $0x2,%ecx
ffffffff8000283b:	eb e6                	jmp    ffffffff80002823 <_vsnprintf+0xb3>
ffffffff8000283d:	0f 1f 00             	nopl   (%rax)
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
ffffffff80002840:	83 c9 10             	or     $0x10,%ecx
ffffffff80002843:	eb de                	jmp    ffffffff80002823 <_vsnprintf+0xb3>
ffffffff80002845:	0f 1f 00             	nopl   (%rax)
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
ffffffff80002848:	83 c9 08             	or     $0x8,%ecx
ffffffff8000284b:	eb d6                	jmp    ffffffff80002823 <_vsnprintf+0xb3>
ffffffff8000284d:	0f 1f 00             	nopl   (%rax)
  return (ch >= '0') && (ch <= '9');
ffffffff80002850:	8d 50 d0             	lea    -0x30(%rax),%edx
    if (_is_digit(*format)) {
ffffffff80002853:	80 fa 09             	cmp    $0x9,%dl
ffffffff80002856:	0f 86 54 02 00 00    	jbe    ffffffff80002ab0 <_vsnprintf+0x340>
    width = 0U;
ffffffff8000285c:	45 31 e4             	xor    %r12d,%r12d
    else if (*format == '*') {
ffffffff8000285f:	3c 2a                	cmp    $0x2a,%al
ffffffff80002861:	0f 84 75 07 00 00    	je     ffffffff80002fdc <_vsnprintf+0x86c>
    precision = 0U;
ffffffff80002867:	45 31 d2             	xor    %r10d,%r10d
    if (*format == '.') {
ffffffff8000286a:	3c 2e                	cmp    $0x2e,%al
ffffffff8000286c:	0f 84 73 02 00 00    	je     ffffffff80002ae5 <_vsnprintf+0x375>
    switch (*format) {
ffffffff80002872:	3c 6a                	cmp    $0x6a,%al
ffffffff80002874:	74 12                	je     ffffffff80002888 <_vsnprintf+0x118>
ffffffff80002876:	0f 8e bc 02 00 00    	jle    ffffffff80002b38 <_vsnprintf+0x3c8>
ffffffff8000287c:	3c 6c                	cmp    $0x6c,%al
ffffffff8000287e:	74 30                	je     ffffffff800028b0 <_vsnprintf+0x140>
ffffffff80002880:	3c 7a                	cmp    $0x7a,%al
ffffffff80002882:	0f 85 d0 02 00 00    	jne    ffffffff80002b58 <_vsnprintf+0x3e8>
ffffffff80002888:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
ffffffff8000288d:	4c 8d 6f 01          	lea    0x1(%rdi),%r13
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
ffffffff80002891:	80 cd 01             	or     $0x1,%ch
    switch (*format) {
ffffffff80002894:	8d 50 db             	lea    -0x25(%rax),%edx
ffffffff80002897:	80 fa 53             	cmp    $0x53,%dl
ffffffff8000289a:	0f 87 00 02 00 00    	ja     ffffffff80002aa0 <_vsnprintf+0x330>
ffffffff800028a0:	0f b6 d2             	movzbl %dl,%edx
ffffffff800028a3:	ff 24 d5 c8 4b 00 80 	jmpq   *-0x7fffb438(,%rdx,8)
ffffffff800028aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        if (*format == 'l') {
ffffffff800028b0:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
ffffffff800028b5:	3c 6c                	cmp    $0x6c,%al
ffffffff800028b7:	0f 84 98 04 00 00    	je     ffffffff80002d55 <_vsnprintf+0x5e5>
        flags |= FLAGS_LONG;
ffffffff800028bd:	80 cd 01             	or     $0x1,%ch
ffffffff800028c0:	4c 8d 6f 01          	lea    0x1(%rdi),%r13
ffffffff800028c4:	eb ce                	jmp    ffffffff80002894 <_vsnprintf+0x124>
ffffffff800028c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800028cd:	00 00 00 
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
ffffffff800028d0:	48 8b 34 24          	mov    (%rsp),%rsi
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
ffffffff800028d4:	83 c9 21             	or     $0x21,%ecx
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
ffffffff800028d7:	8b 06                	mov    (%rsi),%eax
ffffffff800028d9:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff800028dc:	0f 87 45 08 00 00    	ja     ffffffff80003127 <_vsnprintf+0x9b7>
ffffffff800028e2:	89 c2                	mov    %eax,%edx
ffffffff800028e4:	48 03 56 10          	add    0x10(%rsi),%rdx
ffffffff800028e8:	83 c0 08             	add    $0x8,%eax
ffffffff800028eb:	89 06                	mov    %eax,(%rsi)
ffffffff800028ed:	51                   	push   %rcx
ffffffff800028ee:	6a 10                	pushq  $0x10
ffffffff800028f0:	45 31 c9             	xor    %r9d,%r9d
ffffffff800028f3:	41 52                	push   %r10
ffffffff800028f5:	6a 10                	pushq  $0x10
ffffffff800028f7:	4c 8b 02             	mov    (%rdx),%r8
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
ffffffff800028fa:	48 89 da             	mov    %rbx,%rdx
ffffffff800028fd:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002900:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002903:	48 89 ef             	mov    %rbp,%rdi
ffffffff80002906:	e8 a5 fd ff ff       	callq  ffffffff800026b0 <_ntoa_long_long>
ffffffff8000290b:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8000290f:	48 89 c3             	mov    %rax,%rbx
ffffffff80002912:	e9 87 fe ff ff       	jmpq   ffffffff8000279e <_vsnprintf+0x2e>
ffffffff80002917:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000291e:	00 00 
ffffffff80002920:	4c 8d 43 01          	lea    0x1(%rbx),%r8
        if (!(flags & FLAGS_LEFT)) {
ffffffff80002924:	83 e1 02             	and    $0x2,%ecx
ffffffff80002927:	4c 89 c0             	mov    %r8,%rax
ffffffff8000292a:	0f 84 47 04 00 00    	je     ffffffff80002d77 <_vsnprintf+0x607>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff80002930:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002934:	8b 16                	mov    (%rsi),%edx
ffffffff80002936:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002939:	0f 87 34 06 00 00    	ja     ffffffff80002f73 <_vsnprintf+0x803>
ffffffff8000293f:	89 d1                	mov    %edx,%ecx
ffffffff80002941:	48 03 4e 10          	add    0x10(%rsi),%rcx
ffffffff80002945:	83 c2 08             	add    $0x8,%edx
ffffffff80002948:	89 16                	mov    %edx,(%rsi)
ffffffff8000294a:	0f be 39             	movsbl (%rcx),%edi
ffffffff8000294d:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
ffffffff80002952:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002955:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff8000295a:	48 89 da             	mov    %rbx,%rdx
ffffffff8000295d:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002960:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff80002962:	41 83 fc 01          	cmp    $0x1,%r12d
ffffffff80002966:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
ffffffff8000296b:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
ffffffff80002970:	0f 86 e8 02 00 00    	jbe    ffffffff80002c5e <_vsnprintf+0x4ee>
ffffffff80002976:	41 8d 4c 24 fe       	lea    -0x2(%r12),%ecx
ffffffff8000297b:	48 83 c3 02          	add    $0x2,%rbx
ffffffff8000297f:	48 89 c2             	mov    %rax,%rdx
ffffffff80002982:	48 89 5c 24 10       	mov    %rbx,0x10(%rsp)
ffffffff80002987:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
ffffffff8000298c:	48 01 cb             	add    %rcx,%rbx
            out(' ', buffer, idx++, maxlen);
ffffffff8000298f:	4c 8d 62 01          	lea    0x1(%rdx),%r12
ffffffff80002993:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002996:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002999:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff8000299e:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff800029a0:	49 39 dc             	cmp    %rbx,%r12
ffffffff800029a3:	4c 89 e2             	mov    %r12,%rdx
ffffffff800029a6:	75 e7                	jne    ffffffff8000298f <_vsnprintf+0x21f>
ffffffff800029a8:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
ffffffff800029ad:	48 03 5c 24 08       	add    0x8(%rsp),%rbx
        break;
ffffffff800029b2:	e9 e7 fd ff ff       	jmpq   ffffffff8000279e <_vsnprintf+0x2e>
ffffffff800029b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800029be:	00 00 
        out('%', buffer, idx++, maxlen);
ffffffff800029c0:	4c 8d 63 01          	lea    0x1(%rbx),%r12
ffffffff800029c4:	48 89 da             	mov    %rbx,%rdx
ffffffff800029c7:	4c 89 f1             	mov    %r14,%rcx
ffffffff800029ca:	4c 89 fe             	mov    %r15,%rsi
ffffffff800029cd:	bf 25 00 00 00       	mov    $0x25,%edi
ffffffff800029d2:	4c 89 e3             	mov    %r12,%rbx
ffffffff800029d5:	ff d5                	callq  *%rbp
        break;
ffffffff800029d7:	e9 c2 fd ff ff       	jmpq   ffffffff8000279e <_vsnprintf+0x2e>
ffffffff800029dc:	0f 1f 40 00          	nopl   0x0(%rax)
        if (*format == 'x' || *format == 'X') {
ffffffff800029e0:	89 c2                	mov    %eax,%edx
ffffffff800029e2:	83 e2 df             	and    $0xffffffdf,%edx
ffffffff800029e5:	80 fa 58             	cmp    $0x58,%dl
ffffffff800029e8:	0f 84 66 02 00 00    	je     ffffffff80002c54 <_vsnprintf+0x4e4>
        else if (*format == 'o') {
ffffffff800029ee:	3c 6f                	cmp    $0x6f,%al
ffffffff800029f0:	0f 84 b6 04 00 00    	je     ffffffff80002eac <_vsnprintf+0x73c>
        else if (*format == 'b') {
ffffffff800029f6:	3c 62                	cmp    $0x62,%al
ffffffff800029f8:	0f 84 20 05 00 00    	je     ffffffff80002f1e <_vsnprintf+0x7ae>
          flags &= ~FLAGS_HASH;   // no hash for dec format
ffffffff800029fe:	83 e1 ef             	and    $0xffffffef,%ecx
ffffffff80002a01:	bf 0a 00 00 00       	mov    $0xa,%edi
        if (*format == 'X') {
ffffffff80002a06:	3c 58                	cmp    $0x58,%al
ffffffff80002a08:	0f 84 3c 03 00 00    	je     ffffffff80002d4a <_vsnprintf+0x5da>
        if ((*format != 'i') && (*format != 'd')) {
ffffffff80002a0e:	3c 69                	cmp    $0x69,%al
ffffffff80002a10:	74 08                	je     ffffffff80002a1a <_vsnprintf+0x2aa>
ffffffff80002a12:	3c 64                	cmp    $0x64,%al
ffffffff80002a14:	0f 85 33 03 00 00    	jne    ffffffff80002d4d <_vsnprintf+0x5dd>
          flags &= ~FLAGS_ZEROPAD;
ffffffff80002a1a:	89 ca                	mov    %ecx,%edx
ffffffff80002a1c:	83 e2 fe             	and    $0xfffffffe,%edx
ffffffff80002a1f:	f6 c5 04             	test   $0x4,%ch
ffffffff80002a22:	0f 45 ca             	cmovne %edx,%ecx
ffffffff80002a25:	48 8b 14 24          	mov    (%rsp),%rdx
ffffffff80002a29:	89 ce                	mov    %ecx,%esi
ffffffff80002a2b:	81 e6 00 02 00 00    	and    $0x200,%esi
        if ((*format == 'i') || (*format == 'd')) {
ffffffff80002a31:	3c 69                	cmp    $0x69,%al
ffffffff80002a33:	8b 12                	mov    (%rdx),%edx
ffffffff80002a35:	0f 84 b8 02 00 00    	je     ffffffff80002cf3 <_vsnprintf+0x583>
ffffffff80002a3b:	3c 64                	cmp    $0x64,%al
ffffffff80002a3d:	0f 84 b0 02 00 00    	je     ffffffff80002cf3 <_vsnprintf+0x583>
          if (flags & FLAGS_LONG_LONG) {
ffffffff80002a43:	85 f6                	test   %esi,%esi
ffffffff80002a45:	0f 85 38 04 00 00    	jne    ffffffff80002e83 <_vsnprintf+0x713>
          else if (flags & FLAGS_LONG) {
ffffffff80002a4b:	f6 c5 01             	test   $0x1,%ch
ffffffff80002a4e:	0f 85 a1 04 00 00    	jne    ffffffff80002ef5 <_vsnprintf+0x785>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff80002a54:	f6 c1 40             	test   $0x40,%cl
ffffffff80002a57:	0f 84 6e 04 00 00    	je     ffffffff80002ecb <_vsnprintf+0x75b>
ffffffff80002a5d:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002a60:	0f 87 d2 05 00 00    	ja     ffffffff80003038 <_vsnprintf+0x8c8>
ffffffff80002a66:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002a6a:	89 d0                	mov    %edx,%eax
ffffffff80002a6c:	83 c2 08             	add    $0x8,%edx
ffffffff80002a6f:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80002a73:	89 16                	mov    %edx,(%rsi)
ffffffff80002a75:	44 0f b6 00          	movzbl (%rax),%r8d
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
ffffffff80002a79:	51                   	push   %rcx
ffffffff80002a7a:	41 54                	push   %r12
ffffffff80002a7c:	45 31 c9             	xor    %r9d,%r9d
ffffffff80002a7f:	41 52                	push   %r10
ffffffff80002a81:	57                   	push   %rdi
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff80002a82:	48 89 da             	mov    %rbx,%rdx
ffffffff80002a85:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002a88:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002a8b:	48 89 ef             	mov    %rbp,%rdi
ffffffff80002a8e:	e8 5d fb ff ff       	callq  ffffffff800025f0 <_ntoa_long>
ffffffff80002a93:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80002a97:	48 89 c3             	mov    %rax,%rbx
ffffffff80002a9a:	e9 ff fc ff ff       	jmpq   ffffffff8000279e <_vsnprintf+0x2e>
ffffffff80002a9f:	90                   	nop
        out(*format, buffer, idx++, maxlen);
ffffffff80002aa0:	4c 8d 63 01          	lea    0x1(%rbx),%r12
    switch (*format) {
ffffffff80002aa4:	0f be f8             	movsbl %al,%edi
ffffffff80002aa7:	e9 0a fd ff ff       	jmpq   ffffffff800027b6 <_vsnprintf+0x46>
ffffffff80002aac:	0f 1f 40 00          	nopl   0x0(%rax)
  unsigned int i = 0U;
ffffffff80002ab0:	45 31 e4             	xor    %r12d,%r12d
ffffffff80002ab3:	eb 0a                	jmp    ffffffff80002abf <_vsnprintf+0x34f>
ffffffff80002ab5:	0f 1f 00             	nopl   (%rax)
  while (_is_digit(**str)) {
ffffffff80002ab8:	49 89 f5             	mov    %rsi,%r13
ffffffff80002abb:	48 83 c6 01          	add    $0x1,%rsi
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
ffffffff80002abf:	43 8d 14 a4          	lea    (%r12,%r12,4),%edx
ffffffff80002ac3:	44 8d 64 50 d0       	lea    -0x30(%rax,%rdx,2),%r12d
  while (_is_digit(**str)) {
ffffffff80002ac8:	0f be 06             	movsbl (%rsi),%eax
  return (ch >= '0') && (ch <= '9');
ffffffff80002acb:	8d 50 d0             	lea    -0x30(%rax),%edx
  while (_is_digit(**str)) {
ffffffff80002ace:	80 fa 09             	cmp    $0x9,%dl
ffffffff80002ad1:	76 e5                	jbe    ffffffff80002ab8 <_vsnprintf+0x348>
ffffffff80002ad3:	49 8d 7d 02          	lea    0x2(%r13),%rdi
    width = 0U;
ffffffff80002ad7:	49 89 f5             	mov    %rsi,%r13
    precision = 0U;
ffffffff80002ada:	45 31 d2             	xor    %r10d,%r10d
    if (*format == '.') {
ffffffff80002add:	3c 2e                	cmp    $0x2e,%al
ffffffff80002adf:	0f 85 8d fd ff ff    	jne    ffffffff80002872 <_vsnprintf+0x102>
      if (_is_digit(*format)) {
ffffffff80002ae5:	41 0f be 45 01       	movsbl 0x1(%r13),%eax
      flags |= FLAGS_PRECISION;
ffffffff80002aea:	80 cd 04             	or     $0x4,%ch
  return (ch >= '0') && (ch <= '9');
ffffffff80002aed:	8d 50 d0             	lea    -0x30(%rax),%edx
      if (_is_digit(*format)) {
ffffffff80002af0:	80 fa 09             	cmp    $0x9,%dl
ffffffff80002af3:	76 1e                	jbe    ffffffff80002b13 <_vsnprintf+0x3a3>
      else if (*format == '*') {
ffffffff80002af5:	3c 2a                	cmp    $0x2a,%al
ffffffff80002af7:	0f 84 3f 06 00 00    	je     ffffffff8000313c <_vsnprintf+0x9cc>
      format++;
ffffffff80002afd:	49 89 fd             	mov    %rdi,%r13
      else if (*format == '*') {
ffffffff80002b00:	48 83 c7 01          	add    $0x1,%rdi
ffffffff80002b04:	e9 69 fd ff ff       	jmpq   ffffffff80002872 <_vsnprintf+0x102>
ffffffff80002b09:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  while (_is_digit(**str)) {
ffffffff80002b10:	4c 89 ef             	mov    %r13,%rdi
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
ffffffff80002b13:	43 8d 14 92          	lea    (%r10,%r10,4),%edx
ffffffff80002b17:	4c 8d 6f 01          	lea    0x1(%rdi),%r13
ffffffff80002b1b:	44 8d 54 50 d0       	lea    -0x30(%rax,%rdx,2),%r10d
  while (_is_digit(**str)) {
ffffffff80002b20:	0f be 47 01          	movsbl 0x1(%rdi),%eax
  return (ch >= '0') && (ch <= '9');
ffffffff80002b24:	8d 50 d0             	lea    -0x30(%rax),%edx
  while (_is_digit(**str)) {
ffffffff80002b27:	80 fa 09             	cmp    $0x9,%dl
ffffffff80002b2a:	76 e4                	jbe    ffffffff80002b10 <_vsnprintf+0x3a0>
ffffffff80002b2c:	48 83 c7 02          	add    $0x2,%rdi
ffffffff80002b30:	e9 3d fd ff ff       	jmpq   ffffffff80002872 <_vsnprintf+0x102>
ffffffff80002b35:	0f 1f 00             	nopl   (%rax)
    switch (*format) {
ffffffff80002b38:	3c 68                	cmp    $0x68,%al
ffffffff80002b3a:	75 1c                	jne    ffffffff80002b58 <_vsnprintf+0x3e8>
        if (*format == 'h') {
ffffffff80002b3c:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
ffffffff80002b41:	3c 68                	cmp    $0x68,%al
ffffffff80002b43:	0f 84 1d 02 00 00    	je     ffffffff80002d66 <_vsnprintf+0x5f6>
        flags |= FLAGS_SHORT;
ffffffff80002b49:	80 c9 80             	or     $0x80,%cl
ffffffff80002b4c:	4c 8d 6f 01          	lea    0x1(%rdi),%r13
ffffffff80002b50:	e9 3f fd ff ff       	jmpq   ffffffff80002894 <_vsnprintf+0x124>
ffffffff80002b55:	0f 1f 00             	nopl   (%rax)
    switch (*format) {
ffffffff80002b58:	49 89 fd             	mov    %rdi,%r13
ffffffff80002b5b:	e9 34 fd ff ff       	jmpq   ffffffff80002894 <_vsnprintf+0x124>
        const char* p = va_arg(va, char*);
ffffffff80002b60:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002b64:	8b 16                	mov    (%rsi),%edx
ffffffff80002b66:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002b69:	0f 87 2e 04 00 00    	ja     ffffffff80002f9d <_vsnprintf+0x82d>
ffffffff80002b6f:	89 d0                	mov    %edx,%eax
ffffffff80002b71:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80002b75:	83 c2 08             	add    $0x8,%edx
ffffffff80002b78:	89 16                	mov    %edx,(%rsi)
ffffffff80002b7a:	4c 8b 08             	mov    (%rax),%r9
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
ffffffff80002b7d:	45 85 d2             	test   %r10d,%r10d
ffffffff80002b80:	41 0f be 39          	movsbl (%r9),%edi
ffffffff80002b84:	0f 85 54 01 00 00    	jne    ffffffff80002cde <_vsnprintf+0x56e>
  for (s = str; *s && maxsize--; ++s);
ffffffff80002b8a:	40 84 ff             	test   %dil,%dil
ffffffff80002b8d:	48 c7 c6 fe ff ff ff 	mov    $0xfffffffffffffffe,%rsi
ffffffff80002b94:	0f 84 b8 03 00 00    	je     ffffffff80002f52 <_vsnprintf+0x7e2>
ffffffff80002b9a:	4c 89 c8             	mov    %r9,%rax
ffffffff80002b9d:	eb 11                	jmp    ffffffff80002bb0 <_vsnprintf+0x440>
ffffffff80002b9f:	90                   	nop
ffffffff80002ba0:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80002ba5:	48 29 c2             	sub    %rax,%rdx
ffffffff80002ba8:	4c 01 ca             	add    %r9,%rdx
ffffffff80002bab:	48 01 f2             	add    %rsi,%rdx
ffffffff80002bae:	74 09                	je     ffffffff80002bb9 <_vsnprintf+0x449>
ffffffff80002bb0:	48 83 c0 01          	add    $0x1,%rax
ffffffff80002bb4:	80 38 00             	cmpb   $0x0,(%rax)
ffffffff80002bb7:	75 e7                	jne    ffffffff80002ba0 <_vsnprintf+0x430>
ffffffff80002bb9:	44 29 c8             	sub    %r9d,%eax
ffffffff80002bbc:	89 44 24 20          	mov    %eax,0x20(%rsp)
        if (flags & FLAGS_PRECISION) {
ffffffff80002bc0:	89 c8                	mov    %ecx,%eax
ffffffff80002bc2:	25 00 04 00 00       	and    $0x400,%eax
ffffffff80002bc7:	89 44 24 18          	mov    %eax,0x18(%rsp)
ffffffff80002bcb:	74 0f                	je     ffffffff80002bdc <_vsnprintf+0x46c>
          l = (l < precision ? l : precision);
ffffffff80002bcd:	8b 44 24 20          	mov    0x20(%rsp),%eax
ffffffff80002bd1:	44 39 d0             	cmp    %r10d,%eax
ffffffff80002bd4:	41 0f 47 c2          	cmova  %r10d,%eax
ffffffff80002bd8:	89 44 24 20          	mov    %eax,0x20(%rsp)
        if (!(flags & FLAGS_LEFT)) {
ffffffff80002bdc:	83 e1 02             	and    $0x2,%ecx
ffffffff80002bdf:	89 4c 24 24          	mov    %ecx,0x24(%rsp)
ffffffff80002be3:	0f 84 0e 02 00 00    	je     ffffffff80002df7 <_vsnprintf+0x687>
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80002be9:	40 84 ff             	test   %dil,%dil
ffffffff80002bec:	0f 84 94 00 00 00    	je     ffffffff80002c86 <_vsnprintf+0x516>
ffffffff80002bf2:	49 29 d9             	sub    %rbx,%r9
ffffffff80002bf5:	44 89 64 24 28       	mov    %r12d,0x28(%rsp)
ffffffff80002bfa:	44 89 54 24 10       	mov    %r10d,0x10(%rsp)
ffffffff80002bff:	44 8b 64 24 18       	mov    0x18(%rsp),%r12d
ffffffff80002c04:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
ffffffff80002c09:	4c 89 6c 24 18       	mov    %r13,0x18(%rsp)
ffffffff80002c0e:	49 89 dd             	mov    %rbx,%r13
ffffffff80002c11:	eb 27                	jmp    ffffffff80002c3a <_vsnprintf+0x4ca>
ffffffff80002c13:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
          out(*(p++), buffer, idx++, maxlen);
ffffffff80002c18:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002c1b:	4c 89 ea             	mov    %r13,%rdx
ffffffff80002c1e:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002c21:	ff d5                	callq  *%rbp
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80002c23:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
          out(*(p++), buffer, idx++, maxlen);
ffffffff80002c28:	49 8d 5d 01          	lea    0x1(%r13),%rbx
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80002c2c:	41 0f be 7c 05 01    	movsbl 0x1(%r13,%rax,1),%edi
ffffffff80002c32:	40 84 ff             	test   %dil,%dil
ffffffff80002c35:	74 39                	je     ffffffff80002c70 <_vsnprintf+0x500>
          out(*(p++), buffer, idx++, maxlen);
ffffffff80002c37:	49 89 dd             	mov    %rbx,%r13
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80002c3a:	45 85 e4             	test   %r12d,%r12d
ffffffff80002c3d:	74 d9                	je     ffffffff80002c18 <_vsnprintf+0x4a8>
ffffffff80002c3f:	8b 44 24 10          	mov    0x10(%rsp),%eax
ffffffff80002c43:	85 c0                	test   %eax,%eax
ffffffff80002c45:	8d 50 ff             	lea    -0x1(%rax),%edx
ffffffff80002c48:	0f 84 68 02 00 00    	je     ffffffff80002eb6 <_vsnprintf+0x746>
ffffffff80002c4e:	89 54 24 10          	mov    %edx,0x10(%rsp)
ffffffff80002c52:	eb c4                	jmp    ffffffff80002c18 <_vsnprintf+0x4a8>
ffffffff80002c54:	bf 10 00 00 00       	mov    $0x10,%edi
ffffffff80002c59:	e9 a8 fd ff ff       	jmpq   ffffffff80002a06 <_vsnprintf+0x296>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff80002c5e:	4c 89 c3             	mov    %r8,%rbx
ffffffff80002c61:	e9 38 fb ff ff       	jmpq   ffffffff8000279e <_vsnprintf+0x2e>
ffffffff80002c66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80002c6d:	00 00 00 
ffffffff80002c70:	44 8b 64 24 28       	mov    0x28(%rsp),%r12d
ffffffff80002c75:	4c 8b 6c 24 18       	mov    0x18(%rsp),%r13
        if (flags & FLAGS_LEFT) {
ffffffff80002c7a:	8b 44 24 24          	mov    0x24(%rsp),%eax
ffffffff80002c7e:	85 c0                	test   %eax,%eax
ffffffff80002c80:	0f 84 18 fb ff ff    	je     ffffffff8000279e <_vsnprintf+0x2e>
          while (l++ < width) {
ffffffff80002c86:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
ffffffff80002c8a:	41 39 cc             	cmp    %ecx,%r12d
ffffffff80002c8d:	0f 86 0b fb ff ff    	jbe    ffffffff8000279e <_vsnprintf+0x2e>
ffffffff80002c93:	41 83 ec 01          	sub    $0x1,%r12d
ffffffff80002c97:	48 89 da             	mov    %rbx,%rdx
ffffffff80002c9a:	4c 89 6c 24 08       	mov    %r13,0x8(%rsp)
ffffffff80002c9f:	44 89 e0             	mov    %r12d,%eax
ffffffff80002ca2:	4c 8d 63 01          	lea    0x1(%rbx),%r12
ffffffff80002ca6:	29 c8                	sub    %ecx,%eax
ffffffff80002ca8:	4c 01 e0             	add    %r12,%rax
ffffffff80002cab:	4d 89 e5             	mov    %r12,%r13
ffffffff80002cae:	48 89 c3             	mov    %rax,%rbx
ffffffff80002cb1:	eb 09                	jmp    ffffffff80002cbc <_vsnprintf+0x54c>
ffffffff80002cb3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
ffffffff80002cb8:	49 83 c5 01          	add    $0x1,%r13
            out(' ', buffer, idx++, maxlen);
ffffffff80002cbc:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002cbf:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002cc2:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80002cc7:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff80002cc9:	49 39 dd             	cmp    %rbx,%r13
ffffffff80002ccc:	4c 89 ea             	mov    %r13,%rdx
ffffffff80002ccf:	75 e7                	jne    ffffffff80002cb8 <_vsnprintf+0x548>
ffffffff80002cd1:	4c 89 eb             	mov    %r13,%rbx
ffffffff80002cd4:	4c 8b 6c 24 08       	mov    0x8(%rsp),%r13
        break;
ffffffff80002cd9:	e9 c0 fa ff ff       	jmpq   ffffffff8000279e <_vsnprintf+0x2e>
  for (s = str; *s && maxsize--; ++s);
ffffffff80002cde:	40 84 ff             	test   %dil,%dil
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
ffffffff80002ce1:	44 89 d6             	mov    %r10d,%esi
  for (s = str; *s && maxsize--; ++s);
ffffffff80002ce4:	0f 84 68 02 00 00    	je     ffffffff80002f52 <_vsnprintf+0x7e2>
ffffffff80002cea:	48 83 ee 01          	sub    $0x1,%rsi
ffffffff80002cee:	e9 a7 fe ff ff       	jmpq   ffffffff80002b9a <_vsnprintf+0x42a>
          if (flags & FLAGS_LONG_LONG) {
ffffffff80002cf3:	85 f6                	test   %esi,%esi
ffffffff80002cf5:	0f 85 bd 03 00 00    	jne    ffffffff800030b8 <_vsnprintf+0x948>
          else if (flags & FLAGS_LONG) {
ffffffff80002cfb:	f6 c5 01             	test   $0x1,%ch
ffffffff80002cfe:	0f 85 7e 03 00 00    	jne    ffffffff80003082 <_vsnprintf+0x912>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff80002d04:	f6 c1 40             	test   $0x40,%cl
ffffffff80002d07:	0f 84 1b 02 00 00    	je     ffffffff80002f28 <_vsnprintf+0x7b8>
ffffffff80002d0d:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002d10:	0f 87 b1 02 00 00    	ja     ffffffff80002fc7 <_vsnprintf+0x857>
ffffffff80002d16:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002d1a:	89 d0                	mov    %edx,%eax
ffffffff80002d1c:	83 c2 08             	add    $0x8,%edx
ffffffff80002d1f:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80002d23:	89 16                	mov    %edx,(%rsi)
ffffffff80002d25:	44 0f be 08          	movsbl (%rax),%r9d
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff80002d29:	44 89 c8             	mov    %r9d,%eax
ffffffff80002d2c:	51                   	push   %rcx
ffffffff80002d2d:	41 54                	push   %r12
ffffffff80002d2f:	c1 f8 1f             	sar    $0x1f,%eax
ffffffff80002d32:	41 52                	push   %r10
ffffffff80002d34:	57                   	push   %rdi
ffffffff80002d35:	41 89 c0             	mov    %eax,%r8d
ffffffff80002d38:	45 31 c8             	xor    %r9d,%r8d
ffffffff80002d3b:	41 c1 e9 1f          	shr    $0x1f,%r9d
ffffffff80002d3f:	41 29 c0             	sub    %eax,%r8d
ffffffff80002d42:	4d 63 c0             	movslq %r8d,%r8
ffffffff80002d45:	e9 38 fd ff ff       	jmpq   ffffffff80002a82 <_vsnprintf+0x312>
          flags |= FLAGS_UPPERCASE;
ffffffff80002d4a:	83 c9 20             	or     $0x20,%ecx
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
ffffffff80002d4d:	83 e1 f3             	and    $0xfffffff3,%ecx
ffffffff80002d50:	e9 c5 fc ff ff       	jmpq   ffffffff80002a1a <_vsnprintf+0x2aa>
ffffffff80002d55:	41 0f b6 45 02       	movzbl 0x2(%r13),%eax
          flags |= FLAGS_LONG_LONG;
ffffffff80002d5a:	80 cd 03             	or     $0x3,%ch
ffffffff80002d5d:	49 83 c5 03          	add    $0x3,%r13
ffffffff80002d61:	e9 2e fb ff ff       	jmpq   ffffffff80002894 <_vsnprintf+0x124>
ffffffff80002d66:	41 0f b6 45 02       	movzbl 0x2(%r13),%eax
          flags |= FLAGS_CHAR;
ffffffff80002d6b:	80 c9 c0             	or     $0xc0,%cl
ffffffff80002d6e:	49 83 c5 03          	add    $0x3,%r13
ffffffff80002d72:	e9 1d fb ff ff       	jmpq   ffffffff80002894 <_vsnprintf+0x124>
          while (l++ < width) {
ffffffff80002d77:	41 83 fc 01          	cmp    $0x1,%r12d
ffffffff80002d7b:	0f 86 de 01 00 00    	jbe    ffffffff80002f5f <_vsnprintf+0x7ef>
ffffffff80002d81:	41 8d 44 24 fe       	lea    -0x2(%r12),%eax
ffffffff80002d86:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
ffffffff80002d8b:	4d 89 c5             	mov    %r8,%r13
ffffffff80002d8e:	4c 01 c0             	add    %r8,%rax
ffffffff80002d91:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
ffffffff80002d96:	eb 0f                	jmp    ffffffff80002da7 <_vsnprintf+0x637>
ffffffff80002d98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80002d9f:	00 
ffffffff80002da0:	4c 89 eb             	mov    %r13,%rbx
ffffffff80002da3:	49 83 c5 01          	add    $0x1,%r13
            out(' ', buffer, idx++, maxlen);
ffffffff80002da7:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002daa:	48 89 da             	mov    %rbx,%rdx
ffffffff80002dad:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002db0:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80002db5:	4d 89 ec             	mov    %r13,%r12
ffffffff80002db8:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff80002dba:	4c 3b 6c 24 08       	cmp    0x8(%rsp),%r13
ffffffff80002dbf:	75 df                	jne    ffffffff80002da0 <_vsnprintf+0x630>
ffffffff80002dc1:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
ffffffff80002dc6:	48 83 c3 02          	add    $0x2,%rbx
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff80002dca:	48 8b 0c 24          	mov    (%rsp),%rcx
ffffffff80002dce:	8b 01                	mov    (%rcx),%eax
ffffffff80002dd0:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff80002dd3:	0f 87 d9 01 00 00    	ja     ffffffff80002fb2 <_vsnprintf+0x842>
ffffffff80002dd9:	89 c2                	mov    %eax,%edx
ffffffff80002ddb:	48 03 51 10          	add    0x10(%rcx),%rdx
ffffffff80002ddf:	83 c0 08             	add    $0x8,%eax
ffffffff80002de2:	89 01                	mov    %eax,(%rcx)
ffffffff80002de4:	0f be 3a             	movsbl (%rdx),%edi
ffffffff80002de7:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002dea:	4c 89 e2             	mov    %r12,%rdx
ffffffff80002ded:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002df0:	ff d5                	callq  *%rbp
ffffffff80002df2:	e9 a7 f9 ff ff       	jmpq   ffffffff8000279e <_vsnprintf+0x2e>
          while (l++ < width) {
ffffffff80002df7:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
ffffffff80002dfb:	41 39 cc             	cmp    %ecx,%r12d
ffffffff80002dfe:	8d 41 01             	lea    0x1(%rcx),%eax
ffffffff80002e01:	0f 86 63 01 00 00    	jbe    ffffffff80002f6a <_vsnprintf+0x7fa>
ffffffff80002e07:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
ffffffff80002e0c:	4c 8d 43 01          	lea    0x1(%rbx),%r8
ffffffff80002e10:	44 89 64 24 20       	mov    %r12d,0x20(%rsp)
ffffffff80002e15:	4c 89 6c 24 28       	mov    %r13,0x28(%rsp)
ffffffff80002e1a:	48 89 da             	mov    %rbx,%rdx
ffffffff80002e1d:	44 89 54 24 08       	mov    %r10d,0x8(%rsp)
ffffffff80002e22:	29 c8                	sub    %ecx,%eax
ffffffff80002e24:	4c 89 4c 24 10       	mov    %r9,0x10(%rsp)
ffffffff80002e29:	4d 89 c5             	mov    %r8,%r13
ffffffff80002e2c:	4c 01 c0             	add    %r8,%rax
ffffffff80002e2f:	49 89 c4             	mov    %rax,%r12
ffffffff80002e32:	eb 08                	jmp    ffffffff80002e3c <_vsnprintf+0x6cc>
ffffffff80002e34:	0f 1f 40 00          	nopl   0x0(%rax)
ffffffff80002e38:	49 83 c5 01          	add    $0x1,%r13
            out(' ', buffer, idx++, maxlen);
ffffffff80002e3c:	4c 89 f1             	mov    %r14,%rcx
ffffffff80002e3f:	4c 89 fe             	mov    %r15,%rsi
ffffffff80002e42:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80002e47:	ff d5                	callq  *%rbp
          while (l++ < width) {
ffffffff80002e49:	4d 39 e5             	cmp    %r12,%r13
            out(' ', buffer, idx++, maxlen);
ffffffff80002e4c:	4c 89 eb             	mov    %r13,%rbx
ffffffff80002e4f:	4c 89 ea             	mov    %r13,%rdx
          while (l++ < width) {
ffffffff80002e52:	75 e4                	jne    ffffffff80002e38 <_vsnprintf+0x6c8>
ffffffff80002e54:	4c 8b 4c 24 10       	mov    0x10(%rsp),%r9
ffffffff80002e59:	44 8b 64 24 20       	mov    0x20(%rsp),%r12d
ffffffff80002e5e:	44 8b 54 24 08       	mov    0x8(%rsp),%r10d
ffffffff80002e63:	4c 8b 6c 24 28       	mov    0x28(%rsp),%r13
ffffffff80002e68:	41 0f be 39          	movsbl (%r9),%edi
ffffffff80002e6c:	41 8d 44 24 01       	lea    0x1(%r12),%eax
ffffffff80002e71:	89 44 24 20          	mov    %eax,0x20(%rsp)
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
ffffffff80002e75:	40 84 ff             	test   %dil,%dil
ffffffff80002e78:	0f 85 74 fd ff ff    	jne    ffffffff80002bf2 <_vsnprintf+0x482>
ffffffff80002e7e:	e9 1b f9 ff ff       	jmpq   ffffffff8000279e <_vsnprintf+0x2e>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
ffffffff80002e83:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002e86:	0f 87 97 01 00 00    	ja     ffffffff80003023 <_vsnprintf+0x8b3>
ffffffff80002e8c:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002e90:	89 d0                	mov    %edx,%eax
ffffffff80002e92:	83 c2 08             	add    $0x8,%edx
ffffffff80002e95:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80002e99:	89 16                	mov    %edx,(%rsi)
ffffffff80002e9b:	51                   	push   %rcx
ffffffff80002e9c:	45 31 c9             	xor    %r9d,%r9d
ffffffff80002e9f:	41 54                	push   %r12
ffffffff80002ea1:	41 52                	push   %r10
ffffffff80002ea3:	57                   	push   %rdi
ffffffff80002ea4:	4c 8b 00             	mov    (%rax),%r8
ffffffff80002ea7:	e9 4e fa ff ff       	jmpq   ffffffff800028fa <_vsnprintf+0x18a>
ffffffff80002eac:	bf 08 00 00 00       	mov    $0x8,%edi
ffffffff80002eb1:	e9 97 fe ff ff       	jmpq   ffffffff80002d4d <_vsnprintf+0x5dd>
ffffffff80002eb6:	4c 89 e8             	mov    %r13,%rax
ffffffff80002eb9:	44 8b 64 24 28       	mov    0x28(%rsp),%r12d
ffffffff80002ebe:	4c 8b 6c 24 18       	mov    0x18(%rsp),%r13
ffffffff80002ec3:	48 89 c3             	mov    %rax,%rbx
ffffffff80002ec6:	e9 af fd ff ff       	jmpq   ffffffff80002c7a <_vsnprintf+0x50a>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff80002ecb:	f6 c1 80             	test   $0x80,%cl
ffffffff80002ece:	0f 84 8e 01 00 00    	je     ffffffff80003062 <_vsnprintf+0x8f2>
ffffffff80002ed4:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002ed7:	0f 87 70 01 00 00    	ja     ffffffff8000304d <_vsnprintf+0x8dd>
ffffffff80002edd:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002ee1:	89 d0                	mov    %edx,%eax
ffffffff80002ee3:	83 c2 08             	add    $0x8,%edx
ffffffff80002ee6:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80002eea:	89 16                	mov    %edx,(%rsi)
ffffffff80002eec:	44 0f b7 00          	movzwl (%rax),%r8d
ffffffff80002ef0:	e9 84 fb ff ff       	jmpq   ffffffff80002a79 <_vsnprintf+0x309>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
ffffffff80002ef5:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002ef8:	0f 87 8a 00 00 00    	ja     ffffffff80002f88 <_vsnprintf+0x818>
ffffffff80002efe:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002f02:	89 d0                	mov    %edx,%eax
ffffffff80002f04:	83 c2 08             	add    $0x8,%edx
ffffffff80002f07:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80002f0b:	89 16                	mov    %edx,(%rsi)
ffffffff80002f0d:	51                   	push   %rcx
ffffffff80002f0e:	45 31 c9             	xor    %r9d,%r9d
ffffffff80002f11:	41 54                	push   %r12
ffffffff80002f13:	41 52                	push   %r10
ffffffff80002f15:	57                   	push   %rdi
ffffffff80002f16:	4c 8b 00             	mov    (%rax),%r8
ffffffff80002f19:	e9 64 fb ff ff       	jmpq   ffffffff80002a82 <_vsnprintf+0x312>
ffffffff80002f1e:	bf 02 00 00 00       	mov    $0x2,%edi
ffffffff80002f23:	e9 25 fe ff ff       	jmpq   ffffffff80002d4d <_vsnprintf+0x5dd>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff80002f28:	f6 c1 80             	test   $0x80,%cl
ffffffff80002f2b:	0f 84 56 02 00 00    	je     ffffffff80003187 <_vsnprintf+0xa17>
ffffffff80002f31:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002f34:	0f 87 38 02 00 00    	ja     ffffffff80003172 <_vsnprintf+0xa02>
ffffffff80002f3a:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002f3e:	89 d0                	mov    %edx,%eax
ffffffff80002f40:	83 c2 08             	add    $0x8,%edx
ffffffff80002f43:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80002f47:	89 16                	mov    %edx,(%rsi)
ffffffff80002f49:	44 0f bf 08          	movswl (%rax),%r9d
ffffffff80002f4d:	e9 d7 fd ff ff       	jmpq   ffffffff80002d29 <_vsnprintf+0x5b9>
  for (s = str; *s && maxsize--; ++s);
ffffffff80002f52:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%rsp)
ffffffff80002f59:	00 
ffffffff80002f5a:	e9 61 fc ff ff       	jmpq   ffffffff80002bc0 <_vsnprintf+0x450>
          while (l++ < width) {
ffffffff80002f5f:	49 89 dc             	mov    %rbx,%r12
ffffffff80002f62:	4c 89 c3             	mov    %r8,%rbx
ffffffff80002f65:	e9 60 fe ff ff       	jmpq   ffffffff80002dca <_vsnprintf+0x65a>
          while (l++ < width) {
ffffffff80002f6a:	89 44 24 20          	mov    %eax,0x20(%rsp)
ffffffff80002f6e:	e9 02 ff ff ff       	jmpq   ffffffff80002e75 <_vsnprintf+0x705>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff80002f73:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002f77:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
ffffffff80002f7b:	48 8d 51 08          	lea    0x8(%rcx),%rdx
ffffffff80002f7f:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80002f83:	e9 c2 f9 ff ff       	jmpq   ffffffff8000294a <_vsnprintf+0x1da>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
ffffffff80002f88:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002f8c:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff80002f90:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80002f94:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80002f98:	e9 70 ff ff ff       	jmpq   ffffffff80002f0d <_vsnprintf+0x79d>
        const char* p = va_arg(va, char*);
ffffffff80002f9d:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002fa1:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff80002fa5:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80002fa9:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80002fad:	e9 c8 fb ff ff       	jmpq   ffffffff80002b7a <_vsnprintf+0x40a>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
ffffffff80002fb2:	48 8b 0c 24          	mov    (%rsp),%rcx
ffffffff80002fb6:	48 8b 51 08          	mov    0x8(%rcx),%rdx
ffffffff80002fba:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff80002fbe:	48 89 41 08          	mov    %rax,0x8(%rcx)
ffffffff80002fc2:	e9 1d fe ff ff       	jmpq   ffffffff80002de4 <_vsnprintf+0x674>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff80002fc7:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80002fcb:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff80002fcf:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80002fd3:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80002fd7:	e9 49 fd ff ff       	jmpq   ffffffff80002d25 <_vsnprintf+0x5b5>
      const int w = va_arg(va, int);
ffffffff80002fdc:	48 8b 3c 24          	mov    (%rsp),%rdi
ffffffff80002fe0:	8b 17                	mov    (%rdi),%edx
ffffffff80002fe2:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80002fe5:	77 2a                	ja     ffffffff80003011 <_vsnprintf+0x8a1>
ffffffff80002fe7:	89 d0                	mov    %edx,%eax
ffffffff80002fe9:	48 03 47 10          	add    0x10(%rdi),%rax
ffffffff80002fed:	83 c2 08             	add    $0x8,%edx
ffffffff80002ff0:	89 17                	mov    %edx,(%rdi)
ffffffff80002ff2:	44 8b 20             	mov    (%rax),%r12d
      if (w < 0) {
ffffffff80002ff5:	45 85 e4             	test   %r12d,%r12d
ffffffff80002ff8:	79 06                	jns    ffffffff80003000 <_vsnprintf+0x890>
        flags |= FLAGS_LEFT;    // reverse padding
ffffffff80002ffa:	83 c9 02             	or     $0x2,%ecx
        width = (unsigned int)-w;
ffffffff80002ffd:	41 f7 dc             	neg    %r12d
ffffffff80003000:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
ffffffff80003005:	49 8d 7d 02          	lea    0x2(%r13),%rdi
    width = 0U;
ffffffff80003009:	49 89 f5             	mov    %rsi,%r13
ffffffff8000300c:	e9 c9 fa ff ff       	jmpq   ffffffff80002ada <_vsnprintf+0x36a>
      const int w = va_arg(va, int);
ffffffff80003011:	48 8b 3c 24          	mov    (%rsp),%rdi
ffffffff80003015:	48 8b 47 08          	mov    0x8(%rdi),%rax
ffffffff80003019:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff8000301d:	48 89 57 08          	mov    %rdx,0x8(%rdi)
ffffffff80003021:	eb cf                	jmp    ffffffff80002ff2 <_vsnprintf+0x882>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
ffffffff80003023:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003027:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff8000302b:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff8000302f:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003033:	e9 63 fe ff ff       	jmpq   ffffffff80002e9b <_vsnprintf+0x72b>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff80003038:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000303c:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff80003040:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80003044:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003048:	e9 28 fa ff ff       	jmpq   ffffffff80002a75 <_vsnprintf+0x305>
ffffffff8000304d:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003051:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff80003055:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80003059:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff8000305d:	e9 8a fe ff ff       	jmpq   ffffffff80002eec <_vsnprintf+0x77c>
ffffffff80003062:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003065:	0f 87 83 00 00 00    	ja     ffffffff800030ee <_vsnprintf+0x97e>
ffffffff8000306b:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000306f:	89 d0                	mov    %edx,%eax
ffffffff80003071:	83 c2 08             	add    $0x8,%edx
ffffffff80003074:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003078:	89 16                	mov    %edx,(%rsi)
ffffffff8000307a:	44 8b 00             	mov    (%rax),%r8d
ffffffff8000307d:	e9 f7 f9 ff ff       	jmpq   ffffffff80002a79 <_vsnprintf+0x309>
            const long value = va_arg(va, long);
ffffffff80003082:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003085:	77 7c                	ja     ffffffff80003103 <_vsnprintf+0x993>
ffffffff80003087:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000308b:	89 d0                	mov    %edx,%eax
ffffffff8000308d:	83 c2 08             	add    $0x8,%edx
ffffffff80003090:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003094:	89 16                	mov    %edx,(%rsi)
ffffffff80003096:	4c 8b 08             	mov    (%rax),%r9
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff80003099:	51                   	push   %rcx
ffffffff8000309a:	41 54                	push   %r12
ffffffff8000309c:	41 52                	push   %r10
ffffffff8000309e:	57                   	push   %rdi
ffffffff8000309f:	4c 89 c8             	mov    %r9,%rax
ffffffff800030a2:	48 c1 f8 3f          	sar    $0x3f,%rax
ffffffff800030a6:	49 89 c0             	mov    %rax,%r8
ffffffff800030a9:	4d 31 c8             	xor    %r9,%r8
ffffffff800030ac:	49 c1 e9 3f          	shr    $0x3f,%r9
ffffffff800030b0:	49 29 c0             	sub    %rax,%r8
ffffffff800030b3:	e9 ca f9 ff ff       	jmpq   ffffffff80002a82 <_vsnprintf+0x312>
            const long long value = va_arg(va, long long);
ffffffff800030b8:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff800030bb:	77 58                	ja     ffffffff80003115 <_vsnprintf+0x9a5>
ffffffff800030bd:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800030c1:	89 d0                	mov    %edx,%eax
ffffffff800030c3:	83 c2 08             	add    $0x8,%edx
ffffffff800030c6:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff800030ca:	89 16                	mov    %edx,(%rsi)
ffffffff800030cc:	4c 8b 08             	mov    (%rax),%r9
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
ffffffff800030cf:	51                   	push   %rcx
ffffffff800030d0:	41 54                	push   %r12
ffffffff800030d2:	41 52                	push   %r10
ffffffff800030d4:	57                   	push   %rdi
ffffffff800030d5:	4c 89 c8             	mov    %r9,%rax
ffffffff800030d8:	48 c1 f8 3f          	sar    $0x3f,%rax
ffffffff800030dc:	49 89 c0             	mov    %rax,%r8
ffffffff800030df:	4d 31 c8             	xor    %r9,%r8
ffffffff800030e2:	49 c1 e9 3f          	shr    $0x3f,%r9
ffffffff800030e6:	49 29 c0             	sub    %rax,%r8
ffffffff800030e9:	e9 0c f8 ff ff       	jmpq   ffffffff800028fa <_vsnprintf+0x18a>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
ffffffff800030ee:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800030f2:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff800030f6:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff800030fa:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff800030fe:	e9 77 ff ff ff       	jmpq   ffffffff8000307a <_vsnprintf+0x90a>
            const long value = va_arg(va, long);
ffffffff80003103:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003107:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff8000310b:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff8000310f:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003113:	eb 81                	jmp    ffffffff80003096 <_vsnprintf+0x926>
            const long long value = va_arg(va, long long);
ffffffff80003115:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003119:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff8000311d:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff80003121:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003125:	eb a5                	jmp    ffffffff800030cc <_vsnprintf+0x95c>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
ffffffff80003127:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff8000312b:	48 8b 56 08          	mov    0x8(%rsi),%rdx
ffffffff8000312f:	48 8d 42 08          	lea    0x8(%rdx),%rax
ffffffff80003133:	48 89 46 08          	mov    %rax,0x8(%rsi)
ffffffff80003137:	e9 b1 f7 ff ff       	jmpq   ffffffff800028ed <_vsnprintf+0x17d>
        const int prec = (int)va_arg(va, int);
ffffffff8000313c:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003140:	8b 16                	mov    (%rsi),%edx
ffffffff80003142:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff80003145:	77 5c                	ja     ffffffff800031a3 <_vsnprintf+0xa33>
ffffffff80003147:	89 d0                	mov    %edx,%eax
ffffffff80003149:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff8000314d:	83 c2 08             	add    $0x8,%edx
ffffffff80003150:	89 16                	mov    %edx,(%rsi)
        precision = prec > 0 ? (unsigned int)prec : 0U;
ffffffff80003152:	8b 10                	mov    (%rax),%edx
ffffffff80003154:	41 ba 00 00 00 00    	mov    $0x0,%r10d
ffffffff8000315a:	49 8d 7d 03          	lea    0x3(%r13),%rdi
ffffffff8000315e:	85 d2                	test   %edx,%edx
ffffffff80003160:	44 0f 49 10          	cmovns (%rax),%r10d
ffffffff80003164:	41 0f b6 45 02       	movzbl 0x2(%r13),%eax
        format++;
ffffffff80003169:	49 83 c5 02          	add    $0x2,%r13
ffffffff8000316d:	e9 00 f7 ff ff       	jmpq   ffffffff80002872 <_vsnprintf+0x102>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff80003172:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003176:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff8000317a:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff8000317e:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff80003182:	e9 c2 fd ff ff       	jmpq   ffffffff80002f49 <_vsnprintf+0x7d9>
ffffffff80003187:	83 fa 2f             	cmp    $0x2f,%edx
ffffffff8000318a:	77 29                	ja     ffffffff800031b5 <_vsnprintf+0xa45>
ffffffff8000318c:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff80003190:	89 d0                	mov    %edx,%eax
ffffffff80003192:	83 c2 08             	add    $0x8,%edx
ffffffff80003195:	48 03 46 10          	add    0x10(%rsi),%rax
ffffffff80003199:	89 16                	mov    %edx,(%rsi)
ffffffff8000319b:	44 8b 08             	mov    (%rax),%r9d
ffffffff8000319e:	e9 86 fb ff ff       	jmpq   ffffffff80002d29 <_vsnprintf+0x5b9>
        const int prec = (int)va_arg(va, int);
ffffffff800031a3:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800031a7:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff800031ab:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff800031af:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff800031b3:	eb 9d                	jmp    ffffffff80003152 <_vsnprintf+0x9e2>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
ffffffff800031b5:	48 8b 34 24          	mov    (%rsp),%rsi
ffffffff800031b9:	48 8b 46 08          	mov    0x8(%rsi),%rax
ffffffff800031bd:	48 8d 50 08          	lea    0x8(%rax),%rdx
ffffffff800031c1:	48 89 56 08          	mov    %rdx,0x8(%rsi)
ffffffff800031c5:	eb d4                	jmp    ffffffff8000319b <_vsnprintf+0xa2b>
ffffffff800031c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800031ce:	00 00 

ffffffff800031d0 <_out_char>:
  if (character) {
ffffffff800031d0:	40 84 ff             	test   %dil,%dil
ffffffff800031d3:	75 0b                	jne    ffffffff800031e0 <_out_char+0x10>
}
ffffffff800031d5:	f3 c3                	repz retq 
ffffffff800031d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800031de:	00 00 
    _putchar(character);
ffffffff800031e0:	40 0f be ff          	movsbl %dil,%edi
ffffffff800031e4:	e9 c7 01 00 00       	jmpq   ffffffff800033b0 <_putchar>
ffffffff800031e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff800031f0 <printf_>:


///////////////////////////////////////////////////////////////////////////////

int printf_(const char* format, ...)
{
ffffffff800031f0:	48 83 ec 58          	sub    $0x58,%rsp
  va_list va;
  va_start(va, format);
ffffffff800031f4:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
{
ffffffff800031f9:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
ffffffff800031fe:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff80003203:	48 8d 74 24 07       	lea    0x7(%rsp),%rsi
ffffffff80003208:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
{
ffffffff8000320d:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
  va_start(va, format);
ffffffff80003212:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff80003217:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
{
ffffffff8000321c:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff80003221:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
ffffffff80003228:	48 89 f9             	mov    %rdi,%rcx
ffffffff8000322b:	48 c7 c7 d0 31 00 80 	mov    $0xffffffff800031d0,%rdi
{
ffffffff80003232:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  va_start(va, format);
ffffffff80003237:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
ffffffff8000323e:	00 
ffffffff8000323f:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff80003244:	e8 27 f5 ff ff       	callq  ffffffff80002770 <_vsnprintf>
  va_end(va);
  return ret;
}
ffffffff80003249:	48 83 c4 58          	add    $0x58,%rsp
ffffffff8000324d:	c3                   	retq   
ffffffff8000324e:	66 90                	xchg   %ax,%ax

ffffffff80003250 <sprintf_>:


int sprintf_(char* buffer, const char* format, ...)
{
ffffffff80003250:	48 83 ec 58          	sub    $0x58,%rsp
  va_list va;
  va_start(va, format);
ffffffff80003254:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
{
ffffffff80003259:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff8000325e:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
{
ffffffff80003263:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
ffffffff80003268:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff8000326d:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  va_start(va, format);
ffffffff80003274:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff80003279:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff8000327e:	48 89 f1             	mov    %rsi,%rcx
ffffffff80003281:	48 89 fe             	mov    %rdi,%rsi
ffffffff80003284:	48 c7 c7 40 21 00 80 	mov    $0xffffffff80002140,%rdi
{
ffffffff8000328b:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  va_start(va, format);
ffffffff80003290:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%rsp)
ffffffff80003297:	00 
ffffffff80003298:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
ffffffff8000329d:	e8 ce f4 ff ff       	callq  ffffffff80002770 <_vsnprintf>
  va_end(va);
  return ret;
}
ffffffff800032a2:	48 83 c4 58          	add    $0x58,%rsp
ffffffff800032a6:	c3                   	retq   
ffffffff800032a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800032ae:	00 00 

ffffffff800032b0 <snprintf_>:


int snprintf_(char* buffer, size_t count, const char* format, ...)
{
ffffffff800032b0:	48 83 ec 58          	sub    $0x58,%rsp
  va_list va;
  va_start(va, format);
ffffffff800032b4:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
{
ffffffff800032b9:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff800032be:	4c 8d 44 24 08       	lea    0x8(%rsp),%r8
{
ffffffff800032c3:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff800032c8:	48 89 d1             	mov    %rdx,%rcx
ffffffff800032cb:	48 89 f2             	mov    %rsi,%rdx
  va_start(va, format);
ffffffff800032ce:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
ffffffff800032d3:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff800032d8:	48 89 fe             	mov    %rdi,%rsi
ffffffff800032db:	48 c7 c7 40 21 00 80 	mov    $0xffffffff80002140,%rdi
{
ffffffff800032e2:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  va_start(va, format);
ffffffff800032e7:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%rsp)
ffffffff800032ee:	00 
ffffffff800032ef:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff800032f4:	e8 77 f4 ff ff       	callq  ffffffff80002770 <_vsnprintf>
  va_end(va);
  return ret;
}
ffffffff800032f9:	48 83 c4 58          	add    $0x58,%rsp
ffffffff800032fd:	c3                   	retq   
ffffffff800032fe:	66 90                	xchg   %ax,%ax

ffffffff80003300 <vprintf_>:


int vprintf_(const char* format, va_list va)
{
ffffffff80003300:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80003304:	49 89 f0             	mov    %rsi,%r8
ffffffff80003307:	48 89 f9             	mov    %rdi,%rcx
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
ffffffff8000330a:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
ffffffff8000330f:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
ffffffff80003316:	48 c7 c7 d0 31 00 80 	mov    $0xffffffff800031d0,%rdi
ffffffff8000331d:	e8 4e f4 ff ff       	callq  ffffffff80002770 <_vsnprintf>
}
ffffffff80003322:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80003326:	c3                   	retq   
ffffffff80003327:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000332e:	00 00 

ffffffff80003330 <vsnprintf_>:


int vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
ffffffff80003330:	49 89 c8             	mov    %rcx,%r8
  return _vsnprintf(_out_buffer, buffer, count, format, va);
ffffffff80003333:	48 89 d1             	mov    %rdx,%rcx
ffffffff80003336:	48 89 f2             	mov    %rsi,%rdx
ffffffff80003339:	48 89 fe             	mov    %rdi,%rsi
ffffffff8000333c:	48 c7 c7 40 21 00 80 	mov    $0xffffffff80002140,%rdi
ffffffff80003343:	e9 28 f4 ff ff       	jmpq   ffffffff80002770 <_vsnprintf>
ffffffff80003348:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000334f:	00 

ffffffff80003350 <fctprintf>:
}


int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
ffffffff80003350:	48 83 ec 68          	sub    $0x68,%rsp
  va_list va;
  va_start(va, format);
ffffffff80003354:	48 8d 44 24 70       	lea    0x70(%rsp),%rax
{
ffffffff80003359:	4c 89 44 24 50       	mov    %r8,0x50(%rsp)
  const out_fct_wrap_type out_fct_wrap = { out, arg };
ffffffff8000335e:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff80003363:	4c 8d 44 24 18       	lea    0x18(%rsp),%r8
ffffffff80003368:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
{
ffffffff8000336d:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
  va_start(va, format);
ffffffff80003372:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
ffffffff80003377:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
  const out_fct_wrap_type out_fct_wrap = { out, arg };
ffffffff8000337c:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff80003381:	48 89 d1             	mov    %rdx,%rcx
ffffffff80003384:	48 c7 c7 60 21 00 80 	mov    $0xffffffff80002160,%rdi
ffffffff8000338b:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
{
ffffffff80003392:	4c 89 4c 24 58       	mov    %r9,0x58(%rsp)
  va_start(va, format);
ffffffff80003397:	c7 44 24 18 18 00 00 	movl   $0x18,0x18(%rsp)
ffffffff8000339e:	00 
ffffffff8000339f:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
ffffffff800033a4:	e8 c7 f3 ff ff       	callq  ffffffff80002770 <_vsnprintf>
  va_end(va);
  return ret;
ffffffff800033a9:	48 83 c4 68          	add    $0x68,%rsp
ffffffff800033ad:	c3                   	retq   
ffffffff800033ae:	66 90                	xchg   %ax,%ax

ffffffff800033b0 <_putchar>:
#include "../device/console/console.h"

void _putchar(char character)
{
    
    putchar(character);
ffffffff800033b0:	40 0f b6 ff          	movzbl %dil,%edi
ffffffff800033b4:	e9 a7 e3 ff ff       	jmpq   ffffffff80001760 <putchar>
ffffffff800033b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff800033c0 <pagewalk>:
#include <stdint.h>
#include <stddef.h>


void pagewalk()
{
ffffffff800033c0:	eb fe                	jmp    ffffffff800033c0 <pagewalk>
ffffffff800033c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff800033c9:	00 00 00 
ffffffff800033cc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff800033d0 <print_gdt>:
uint8_t ist2[4096];

void print_gdt()
{

}
ffffffff800033d0:	f3 c3                	repz retq 
ffffffff800033d2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff800033d9:	00 00 00 00 
ffffffff800033dd:	0f 1f 00             	nopl   (%rax)

ffffffff800033e0 <gdt_init>:

void gdt_init()
{
    gdt.null0.raw = 0x00;
    gdt.kcode.raw = 0x00AF9A000000FFFF;
ffffffff800033e0:	48 b8 ff ff 00 00 00 	movabs $0xaf9a000000ffff,%rax
ffffffff800033e7:	9a af 00 
    tss.ist1 = (uint64_t)ist1 + sizeof(ist1);

    gdtr.base = (uint64_t)&gdt;
    gdtr.limit = sizeof(gdt);

    gdt_load((uint64_t*)&gdtr, 0x50);
ffffffff800033ea:	be 50 00 00 00       	mov    $0x50,%esi
ffffffff800033ef:	48 c7 c7 60 e7 00 80 	mov    $0xffffffff8000e760,%rdi
    gdt.kcode.raw = 0x00AF9A000000FFFF;
ffffffff800033f6:	48 89 05 0b b4 00 00 	mov    %rax,0xb40b(%rip)        # ffffffff8000e808 <gdt+0x8>
    gdt.kdata.raw = 0x00AF92000000FFFF;
ffffffff800033fd:	48 b8 ff ff 00 00 00 	movabs $0xaf92000000ffff,%rax
ffffffff80003404:	92 af 00 
    gdt.null0.raw = 0x00;
ffffffff80003407:	48 c7 05 ee b3 00 00 	movq   $0x0,0xb3ee(%rip)        # ffffffff8000e800 <gdt>
ffffffff8000340e:	00 00 00 00 
    gdt.kdata.raw = 0x00AF92000000FFFF;
ffffffff80003412:	48 89 05 f7 b3 00 00 	mov    %rax,0xb3f7(%rip)        # ffffffff8000e810 <gdt+0x10>
    gdt.ucode.raw = 0x00AFFA000000FFFF;
ffffffff80003419:	48 b8 ff ff 00 00 00 	movabs $0xaffa000000ffff,%rax
ffffffff80003420:	fa af 00 
    gdt.null1.raw = 0x00;
ffffffff80003423:	48 c7 05 ea b3 00 00 	movq   $0x0,0xb3ea(%rip)        # ffffffff8000e818 <gdt+0x18>
ffffffff8000342a:	00 00 00 00 
    gdt.ucode.raw = 0x00AFFA000000FFFF;
ffffffff8000342e:	48 89 05 eb b3 00 00 	mov    %rax,0xb3eb(%rip)        # ffffffff8000e820 <gdt+0x20>
    gdt.udata.raw = 0x00AFF2000000FFFF;
ffffffff80003435:	48 b8 ff ff 00 00 00 	movabs $0xaff2000000ffff,%rax
ffffffff8000343c:	f2 af 00 
    gdt.null2.raw = 0x00;
ffffffff8000343f:	48 c7 05 e6 b3 00 00 	movq   $0x0,0xb3e6(%rip)        # ffffffff8000e830 <gdt+0x30>
ffffffff80003446:	00 00 00 00 
    gdt.udata.raw = 0x00AFF2000000FFFF;
ffffffff8000344a:	48 89 05 d7 b3 00 00 	mov    %rax,0xb3d7(%rip)        # ffffffff8000e828 <gdt+0x28>
    gdt.tss_entry.base0 = (uint64_t)&tss & 0xFFFF;
ffffffff80003451:	48 c7 c0 80 e7 00 80 	mov    $0xffffffff8000e780,%rax
    gdt.null3.raw = 0x00;
ffffffff80003458:	48 c7 05 d5 b3 00 00 	movq   $0x0,0xb3d5(%rip)        # ffffffff8000e838 <gdt+0x38>
ffffffff8000345f:	00 00 00 00 
    gdt.tss_entry.base16 = ((uint64_t)&tss >> 16) & 0xFF;
ffffffff80003463:	48 89 c2             	mov    %rax,%rdx
    gdt.tss_entry.base0 = (uint64_t)&tss & 0xFFFF;
ffffffff80003466:	66 89 05 e5 b3 00 00 	mov    %ax,0xb3e5(%rip)        # ffffffff8000e852 <gdt+0x52>
    gdt.null4.raw = 0x00;
ffffffff8000346d:	48 c7 05 c8 b3 00 00 	movq   $0x0,0xb3c8(%rip)        # ffffffff8000e840 <gdt+0x40>
ffffffff80003474:	00 00 00 00 
    gdt.tss_entry.base16 = ((uint64_t)&tss >> 16) & 0xFF;
ffffffff80003478:	48 c1 ea 10          	shr    $0x10,%rdx
    gdt.null5.raw = 0x00;
ffffffff8000347c:	48 c7 05 c1 b3 00 00 	movq   $0x0,0xb3c1(%rip)        # ffffffff8000e848 <gdt+0x48>
ffffffff80003483:	00 00 00 00 
    gdt.tss_entry.segment_type = 0x09;      //64 bit TSS
ffffffff80003487:	c6 05 c7 b3 00 00 89 	movb   $0x89,0xb3c7(%rip)        # ffffffff8000e855 <gdt+0x55>
    gdt.tss_entry.base16 = ((uint64_t)&tss >> 16) & 0xFF;
ffffffff8000348e:	88 15 c0 b3 00 00    	mov    %dl,0xb3c0(%rip)        # ffffffff8000e854 <gdt+0x54>
    gdt.tss_entry.base24 = ((uint64_t)&tss >> 24) & 0xFF;
ffffffff80003494:	48 89 c2             	mov    %rax,%rdx
    gdt.tss_entry.base32 = ((uint64_t)&tss >> 32) & 0xFFFFFFFF;
ffffffff80003497:	48 c1 e8 20          	shr    $0x20,%rax
ffffffff8000349b:	89 05 b7 b3 00 00    	mov    %eax,0xb3b7(%rip)        # ffffffff8000e858 <gdt+0x58>
    gdt.tss_entry.limit0 = sizeof(tss);
ffffffff800034a1:	b8 68 00 00 00       	mov    $0x68,%eax
    gdt.tss_entry.base24 = ((uint64_t)&tss >> 24) & 0xFF;
ffffffff800034a6:	48 c1 ea 18          	shr    $0x18,%rdx
    gdt.tss_entry.limit0 = sizeof(tss);
ffffffff800034aa:	66 89 05 9f b3 00 00 	mov    %ax,0xb39f(%rip)        # ffffffff8000e850 <gdt+0x50>
    gdt.tss_entry.reserved0 = 0;
ffffffff800034b1:	0f b6 05 9e b3 00 00 	movzbl 0xb39e(%rip),%eax        # ffffffff8000e856 <gdt+0x56>
    gdt.tss_entry.base24 = ((uint64_t)&tss >> 24) & 0xFF;
ffffffff800034b8:	88 15 99 b3 00 00    	mov    %dl,0xb399(%rip)        # ffffffff8000e857 <gdt+0x57>
    gdtr.limit = sizeof(gdt);
ffffffff800034be:	ba 60 00 00 00       	mov    $0x60,%edx
    gdt.tss_entry.reserved1 = 0;
ffffffff800034c3:	c7 05 8f b3 00 00 00 	movl   $0x0,0xb38f(%rip)        # ffffffff8000e85c <gdt+0x5c>
ffffffff800034ca:	00 00 00 
    tss.reserved0 = 0x00;
ffffffff800034cd:	c7 05 a9 b2 00 00 00 	movl   $0x0,0xb2a9(%rip)        # ffffffff8000e780 <tss>
ffffffff800034d4:	00 00 00 
    tss.RSP0 = (uint64_t)stack + sizeof(stack);
ffffffff800034d7:	48 c7 05 a2 b2 00 00 	movq   $0xffffffff8000a260,0xb2a2(%rip)        # ffffffff8000e784 <tss+0x4>
ffffffff800034de:	60 a2 00 80 
    tss.ist1 = (uint64_t)ist1 + sizeof(ist1);
ffffffff800034e2:	48 c7 05 b7 b2 00 00 	movq   $0xffffffff8000e6c0,0xb2b7(%rip)        # ffffffff8000e7a4 <tss+0x24>
ffffffff800034e9:	c0 e6 00 80 
    gdtr.base = (uint64_t)&gdt;
ffffffff800034ed:	48 c7 05 6a b2 00 00 	movq   $0xffffffff8000e800,0xb26a(%rip)        # ffffffff8000e762 <gdtr+0x2>
ffffffff800034f4:	00 e8 00 80 
    gdt.tss_entry.reserved0 = 0;
ffffffff800034f8:	83 e0 40             	and    $0x40,%eax
    gdtr.limit = sizeof(gdt);
ffffffff800034fb:	66 89 15 5e b2 00 00 	mov    %dx,0xb25e(%rip)        # ffffffff8000e760 <gdtr>
    gdt.tss_entry.reserved0 = 0;
ffffffff80003502:	88 05 4e b3 00 00    	mov    %al,0xb34e(%rip)        # ffffffff8000e856 <gdt+0x56>
    gdt_load((uint64_t*)&gdtr, 0x50);
ffffffff80003508:	e9 33 cb ff ff       	jmpq   ffffffff80000040 <gdt_load>
ffffffff8000350d:	0f 1f 00             	nopl   (%rax)

ffffffff80003510 <memset>:
#include "kstring.h"

void* memset(void* s, uint64_t c, uint64_t len)
{
    unsigned char* p=s;
    while(len--)
ffffffff80003510:	48 85 d2             	test   %rdx,%rdx
{
ffffffff80003513:	48 89 f8             	mov    %rdi,%rax
    while(len--)
ffffffff80003516:	74 15                	je     ffffffff8000352d <memset+0x1d>
ffffffff80003518:	48 01 fa             	add    %rdi,%rdx
    unsigned char* p=s;
ffffffff8000351b:	48 89 f9             	mov    %rdi,%rcx
ffffffff8000351e:	66 90                	xchg   %ax,%ax
    {
        *p++ = (unsigned char)c;
ffffffff80003520:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80003524:	40 88 71 ff          	mov    %sil,-0x1(%rcx)
    while(len--)
ffffffff80003528:	48 39 d1             	cmp    %rdx,%rcx
ffffffff8000352b:	75 f3                	jne    ffffffff80003520 <memset+0x10>
    }
    return s;
}
ffffffff8000352d:	f3 c3                	repz retq 
ffffffff8000352f:	90                   	nop

ffffffff80003530 <memcmp>:

int memcmp(const void* str1, const void* str2, size_t n)
{
    if(!n)
        return 0;
ffffffff80003530:	31 c0                	xor    %eax,%eax
    if(!n)
ffffffff80003532:	48 85 d2             	test   %rdx,%rdx
ffffffff80003535:	74 36                	je     ffffffff8000356d <memcmp+0x3d>

    while(--n && *(uint8_t*)str1 == *(uint8_t*)str2)
ffffffff80003537:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff8000353b:	44 0f b6 06          	movzbl (%rsi),%r8d
ffffffff8000353f:	0f b6 0f             	movzbl (%rdi),%ecx
ffffffff80003542:	74 23                	je     ffffffff80003567 <memcmp+0x37>
ffffffff80003544:	41 38 c8             	cmp    %cl,%r8b
ffffffff80003547:	75 1e                	jne    ffffffff80003567 <memcmp+0x37>
ffffffff80003549:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8000354e:	eb 09                	jmp    ffffffff80003559 <memcmp+0x29>
ffffffff80003550:	48 83 c0 01          	add    $0x1,%rax
ffffffff80003554:	44 38 c1             	cmp    %r8b,%cl
ffffffff80003557:	75 0e                	jne    ffffffff80003567 <memcmp+0x37>
ffffffff80003559:	48 39 c2             	cmp    %rax,%rdx
ffffffff8000355c:	0f b6 0c 07          	movzbl (%rdi,%rax,1),%ecx
ffffffff80003560:	44 0f b6 04 06       	movzbl (%rsi,%rax,1),%r8d
ffffffff80003565:	75 e9                	jne    ffffffff80003550 <memcmp+0x20>
    {
        str1 = (uint8_t*)str1 + 1;
        str2 = (uint8_t*)str2 + 1;
    }

    return (*((uint8_t*)str1) - *((uint8_t*)str2));
ffffffff80003567:	0f b6 c1             	movzbl %cl,%eax
ffffffff8000356a:	44 29 c0             	sub    %r8d,%eax
ffffffff8000356d:	f3 c3                	repz retq 
ffffffff8000356f:	90                   	nop

ffffffff80003570 <kernel>:




void kernel()
{
ffffffff80003570:	48 83 ec 08          	sub    $0x8,%rsp

    //printf("Kernel Now\n");
    serial_init(0x3F8);     //COM1
ffffffff80003574:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff80003579:	e8 12 e6 ff ff       	callq  ffffffff80001b90 <serial_init>
    gdt_init();
ffffffff8000357e:	31 c0                	xor    %eax,%eax
ffffffff80003580:	e8 5b fe ff ff       	callq  ffffffff800033e0 <gdt_init>
    idt_init();
ffffffff80003585:	31 c0                	xor    %eax,%eax
ffffffff80003587:	e8 b4 00 00 00       	callq  ffffffff80003640 <idt_init>
    fb_init();
ffffffff8000358c:	31 c0                	xor    %eax,%eax
ffffffff8000358e:	e8 9d e0 ff ff       	callq  ffffffff80001630 <fb_init>
    console_init();
ffffffff80003593:	31 c0                	xor    %eax,%eax
ffffffff80003595:	e8 a6 e4 ff ff       	callq  ffffffff80001a40 <console_init>

    serial_write(0x3F8, 'm');
ffffffff8000359a:	be 6d 00 00 00       	mov    $0x6d,%esi
ffffffff8000359f:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800035a4:	e8 17 e7 ff ff       	callq  ffffffff80001cc0 <serial_write>

    pmm_init();
ffffffff800035a9:	31 c0                	xor    %eax,%eax
ffffffff800035ab:	e8 20 dc ff ff       	callq  ffffffff800011d0 <pmm_init>
    vmm_init();
ffffffff800035b0:	31 c0                	xor    %eax,%eax
ffffffff800035b2:	e8 99 d2 ff ff       	callq  ffffffff80000850 <vmm_init>

    

    serial_write(0x3F8, 'k');
ffffffff800035b7:	be 6b 00 00 00       	mov    $0x6b,%esi
ffffffff800035bc:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800035c1:	e8 fa e6 ff ff       	callq  ffffffff80001cc0 <serial_write>
    
    serial_write_str(SERIAL_PORT1, "Testing!\n\rMore Testing!");
ffffffff800035c6:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800035cb:	48 c7 c6 68 4e 00 80 	mov    $0xffffffff80004e68,%rsi
ffffffff800035d2:	e8 19 e7 ff ff       	callq  ffffffff80001cf0 <serial_write_str>
    //fb_clearscreen(FB_COLOR_BLUE);

    //int_test();

 
    printf("Kernel Done!\n");
ffffffff800035d7:	48 c7 c7 80 4e 00 80 	mov    $0xffffffff80004e80,%rdi
ffffffff800035de:	31 c0                	xor    %eax,%eax
ffffffff800035e0:	e8 0b fc ff ff       	callq  ffffffff800031f0 <printf_>
ffffffff800035e5:	eb fe                	jmp    ffffffff800035e5 <kernel+0x75>
ffffffff800035e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff800035ee:	00 00 

ffffffff800035f0 <create_descriptor>:

void create_descriptor(uint16_t index, void* isr, uint8_t ist, uint8_t cs, uint8_t attr)
{
    struct idt_entry* entry = &idt[index];

    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff800035f0:	0f b7 ff             	movzwl %di,%edi
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800035f3:	48 89 f0             	mov    %rsi,%rax
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
    entry->ist = ist;
    entry->kernel_cs = cs;
ffffffff800035f6:	0f b6 c9             	movzbl %cl,%ecx
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff800035f9:	48 c1 e7 04          	shl    $0x4,%rdi
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800035fd:	48 c1 e8 10          	shr    $0x10,%rax
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80003601:	66 89 b7 80 e8 00 80 	mov    %si,-0x7fff1780(%rdi)
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003608:	48 c1 ee 20          	shr    $0x20,%rsi
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff8000360c:	66 89 87 86 e8 00 80 	mov    %ax,-0x7fff177a(%rdi)
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003613:	89 b7 88 e8 00 80    	mov    %esi,-0x7fff1778(%rdi)
    entry->ist = ist;
ffffffff80003619:	88 97 84 e8 00 80    	mov    %dl,-0x7fff177c(%rdi)
    entry->kernel_cs = cs;
ffffffff8000361f:	66 89 8f 82 e8 00 80 	mov    %cx,-0x7fff177e(%rdi)
    entry->attributes = attr;
ffffffff80003626:	44 88 87 85 e8 00 80 	mov    %r8b,-0x7fff177b(%rdi)
    entry->reserved = 0;
ffffffff8000362d:	c7 87 8c e8 00 80 00 	movl   $0x0,-0x7fff1774(%rdi)
ffffffff80003634:	00 00 00 
}
ffffffff80003637:	c3                   	retq   
ffffffff80003638:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8000363f:	00 

ffffffff80003640 <idt_init>:

void idt_init()
{
    //uint64_t idt_ptr = hh_code_to_phys((uint64_t)&idt[0]);
    idtr.base = (uint64_t)&idt[0];
ffffffff80003640:	48 c7 c0 80 e8 00 80 	mov    $0xffffffff8000e880,%rax
    idtr.limit = (uint16_t)(sizeof(idt) - 1);
ffffffff80003647:	b9 ff 0f 00 00       	mov    $0xfff,%ecx
{
ffffffff8000364c:	48 83 ec 08          	sub    $0x8,%rsp
ffffffff80003650:	48 8d b8 f0 02 00 00 	lea    0x2f0(%rax),%rdi
    idtr.limit = (uint16_t)(sizeof(idt) - 1);
ffffffff80003657:	66 89 0d 0a b2 00 00 	mov    %cx,0xb20a(%rip)        # ffffffff8000e868 <idtr>
    idtr.base = (uint64_t)&idt[0];
ffffffff8000365e:	48 89 05 05 b2 00 00 	mov    %rax,0xb205(%rip)        # ffffffff8000e86a <idtr+0x2>
ffffffff80003665:	48 c7 c1 48 02 00 80 	mov    $0xffffffff80000248,%rcx
ffffffff8000366c:	0f 1f 40 00          	nopl   0x0(%rax)

    for(uint8_t index = 0; index < 47; index++)
    {
        create_descriptor(index, isr_stub_table[index], 0x00, 0x08, 0x8E);
ffffffff80003670:	48 8b 11             	mov    (%rcx),%rdx
    entry->ist = ist;
ffffffff80003673:	c6 40 04 00          	movb   $0x0,0x4(%rax)
ffffffff80003677:	48 83 c0 10          	add    $0x10,%rax
    entry->attributes = attr;
ffffffff8000367b:	c6 40 f5 8e          	movb   $0x8e,-0xb(%rax)
    entry->reserved = 0;
ffffffff8000367f:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%rax)
ffffffff80003686:	48 83 c1 08          	add    $0x8,%rcx
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff8000368a:	66 89 50 f0          	mov    %dx,-0x10(%rax)
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff8000368e:	48 89 d6             	mov    %rdx,%rsi
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003691:	48 c1 ea 20          	shr    $0x20,%rdx
ffffffff80003695:	89 50 f8             	mov    %edx,-0x8(%rax)
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003698:	48 c1 ee 10          	shr    $0x10,%rsi
    entry->kernel_cs = cs;
ffffffff8000369c:	ba 08 00 00 00       	mov    $0x8,%edx
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800036a1:	66 89 70 f6          	mov    %si,-0xa(%rax)
    entry->kernel_cs = cs;
ffffffff800036a5:	66 89 50 f2          	mov    %dx,-0xe(%rax)
    for(uint8_t index = 0; index < 47; index++)
ffffffff800036a9:	48 39 f8             	cmp    %rdi,%rax
ffffffff800036ac:	75 c2                	jne    ffffffff80003670 <idt_init+0x30>
    }

    create_descriptor(127, isr_stub_table[48], 0x00, 0x08, 0x8E);
ffffffff800036ae:	48 8b 05 13 cd ff ff 	mov    -0x32ed(%rip),%rax        # ffffffff800003c8 <isr_stub_table+0x180>
    entry->kernel_cs = cs;
ffffffff800036b5:	c7 05 b3 b9 00 00 08 	movl   $0x8e000008,0xb9b3(%rip)        # ffffffff8000f072 <idt+0x7f2>
ffffffff800036bc:	00 00 8e 
    entry->reserved = 0;
ffffffff800036bf:	c7 05 b3 b9 00 00 00 	movl   $0x0,0xb9b3(%rip)        # ffffffff8000f07c <idt+0x7fc>
ffffffff800036c6:	00 00 00 
    entry->kernel_cs = cs;
ffffffff800036c9:	c7 05 af b9 00 00 08 	movl   $0x8e000008,0xb9af(%rip)        # ffffffff8000f082 <idt+0x802>
ffffffff800036d0:	00 00 8e 
    entry->reserved = 0;
ffffffff800036d3:	c7 05 af b9 00 00 00 	movl   $0x0,0xb9af(%rip)        # ffffffff8000f08c <idt+0x80c>
ffffffff800036da:	00 00 00 
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff800036dd:	66 89 05 8c b9 00 00 	mov    %ax,0xb98c(%rip)        # ffffffff8000f070 <idt+0x7f0>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800036e4:	48 89 c2             	mov    %rax,%rdx
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff800036e7:	48 c1 e8 20          	shr    $0x20,%rax
ffffffff800036eb:	89 05 87 b9 00 00    	mov    %eax,0xb987(%rip)        # ffffffff8000f078 <idt+0x7f8>
    create_descriptor(128, isr_stub_table[49], 0x00, 0x08, 0x8E);
ffffffff800036f1:	48 8b 05 d8 cc ff ff 	mov    -0x3328(%rip),%rax        # ffffffff800003d0 <isr_stub_table+0x188>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff800036f8:	48 c1 ea 10          	shr    $0x10,%rdx
ffffffff800036fc:	66 89 15 73 b9 00 00 	mov    %dx,0xb973(%rip)        # ffffffff8000f076 <idt+0x7f6>
    entry->base15_0 = (uint64_t)isr & 0xFFFF;
ffffffff80003703:	66 89 05 76 b9 00 00 	mov    %ax,0xb976(%rip)        # ffffffff8000f080 <idt+0x800>
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff8000370a:	48 89 c2             	mov    %rax,%rdx
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff8000370d:	48 c1 e8 20          	shr    $0x20,%rax
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff80003711:	48 c1 ea 10          	shr    $0x10,%rdx
    entry->base63_32 = ((uint64_t)isr >> 32) & 0xFFFFFFFF;
ffffffff80003715:	89 05 6d b9 00 00    	mov    %eax,0xb96d(%rip)        # ffffffff8000f088 <idt+0x808>

    pic_remap();
ffffffff8000371b:	31 c0                	xor    %eax,%eax
    entry->base31_16 = ((uint64_t)isr >> 16) & 0xFFFF;
ffffffff8000371d:	66 89 15 62 b9 00 00 	mov    %dx,0xb962(%rip)        # ffffffff8000f086 <idt+0x806>
    pic_remap();
ffffffff80003724:	e8 b7 e8 ff ff       	callq  ffffffff80001fe0 <pic_remap>
    pic_disable();
ffffffff80003729:	31 c0                	xor    %eax,%eax
ffffffff8000372b:	e8 80 e8 ff ff       	callq  ffffffff80001fb0 <pic_disable>

    

    idt_load(&idtr);
ffffffff80003730:	48 c7 c7 68 e8 00 80 	mov    $0xffffffff8000e868,%rdi
ffffffff80003737:	e8 9c cc ff ff       	callq  ffffffff800003d8 <idt_load>

    pit_init(10000);
ffffffff8000373c:	bf 10 27 00 00       	mov    $0x2710,%edi
ffffffff80003741:	e8 9a e9 ff ff       	callq  ffffffff800020e0 <pit_init>

    pic_clear_mask(1);
ffffffff80003746:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8000374b:	e8 10 e8 ff ff       	callq  ffffffff80001f60 <pic_clear_mask>
    pic_clear_mask(0);
ffffffff80003750:	31 ff                	xor    %edi,%edi


    //__asm__ volatile ("lidt %0" : : "m"(idtr));
    //__asm__ volatile ("sti");
}
ffffffff80003752:	48 83 c4 08          	add    $0x8,%rsp
    pic_clear_mask(0);
ffffffff80003756:	e9 05 e8 ff ff       	jmpq   ffffffff80001f60 <pic_clear_mask>
ffffffff8000375b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80003760 <interrupt_handler>:

uint64_t interrupt_handler(uint64_t rsp)
{
ffffffff80003760:	55                   	push   %rbp
ffffffff80003761:	53                   	push   %rbx
ffffffff80003762:	48 89 fb             	mov    %rdi,%rbx
ffffffff80003765:	48 83 ec 08          	sub    $0x8,%rsp
    struct interrupt_stack_frame* frame = (struct interrupt_stack_frame*)rsp;
    
    if(frame->int_no < 32)
ffffffff80003769:	48 8b 77 78          	mov    0x78(%rdi),%rsi
ffffffff8000376d:	48 83 fe 1f          	cmp    $0x1f,%rsi
ffffffff80003771:	77 1d                	ja     ffffffff80003790 <interrupt_handler+0x30>
    {
        if(frame->cs == 0x08)
ffffffff80003773:	48 83 bf 90 00 00 00 	cmpq   $0x8,0x90(%rdi)
ffffffff8000377a:	08 
ffffffff8000377b:	74 63                	je     ffffffff800037e0 <interrupt_handler+0x80>
    {
        printf("Syscall 127\n");
        return rsp;
    }
    return rsp;
ffffffff8000377d:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80003781:	48 89 d8             	mov    %rbx,%rax
ffffffff80003784:	5b                   	pop    %rbx
ffffffff80003785:	5d                   	pop    %rbp
ffffffff80003786:	c3                   	retq   
ffffffff80003787:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000378e:	00 00 
    else if (frame->int_no < 48)
ffffffff80003790:	48 83 fe 2f          	cmp    $0x2f,%rsi
ffffffff80003794:	77 32                	ja     ffffffff800037c8 <interrupt_handler+0x68>
        uint64_t irq = frame->int_no - 32;
ffffffff80003796:	48 8d 6e e0          	lea    -0x20(%rsi),%rbp
        if(irq > 1)
ffffffff8000379a:	48 83 fd 01          	cmp    $0x1,%rbp
ffffffff8000379e:	0f 87 fc 00 00 00    	ja     ffffffff800038a0 <interrupt_handler+0x140>
        switch(irq)
ffffffff800037a4:	0f 84 e6 00 00 00    	je     ffffffff80003890 <interrupt_handler+0x130>
                pit_ticks++;
ffffffff800037aa:	48 83 05 ae b0 00 00 	addq   $0x1,0xb0ae(%rip)        # ffffffff8000e860 <pit_ticks>
ffffffff800037b1:	01 
        pic_EOI(irq);
ffffffff800037b2:	89 ef                	mov    %ebp,%edi
ffffffff800037b4:	e8 17 e7 ff ff       	callq  ffffffff80001ed0 <pic_EOI>
ffffffff800037b9:	48 83 c4 08          	add    $0x8,%rsp
ffffffff800037bd:	48 89 d8             	mov    %rbx,%rax
ffffffff800037c0:	5b                   	pop    %rbx
ffffffff800037c1:	5d                   	pop    %rbp
ffffffff800037c2:	c3                   	retq   
ffffffff800037c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    else if (frame->int_no == 127)
ffffffff800037c8:	48 83 fe 7f          	cmp    $0x7f,%rsi
ffffffff800037cc:	75 af                	jne    ffffffff8000377d <interrupt_handler+0x1d>
        printf("Syscall 127\n");
ffffffff800037ce:	48 c7 c7 13 4f 00 80 	mov    $0xffffffff80004f13,%rdi
ffffffff800037d5:	31 c0                	xor    %eax,%eax
ffffffff800037d7:	e8 14 fa ff ff       	callq  ffffffff800031f0 <printf_>
        return rsp;
ffffffff800037dc:	eb 9f                	jmp    ffffffff8000377d <interrupt_handler+0x1d>
ffffffff800037de:	66 90                	xchg   %ax,%ax
            uint64_t cr2 = read_cr2();
ffffffff800037e0:	31 c0                	xor    %eax,%eax
ffffffff800037e2:	e8 89 c8 ff ff       	callq  ffffffff80000070 <read_cr2>
ffffffff800037e7:	48 89 c5             	mov    %rax,%rbp
            serial_write(0x3F8, frame->int_no + 65);
ffffffff800037ea:	0f b6 43 78          	movzbl 0x78(%rbx),%eax
ffffffff800037ee:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff800037f3:	8d 70 41             	lea    0x41(%rax),%esi
ffffffff800037f6:	40 0f b6 f6          	movzbl %sil,%esi
ffffffff800037fa:	e8 c1 e4 ff ff       	callq  ffffffff80001cc0 <serial_write>
            printf("\nCPU Exception! INT %d   ERR %x  CR2 %p\n", frame->int_no, frame->err_no, cr2);
ffffffff800037ff:	48 8b 93 80 00 00 00 	mov    0x80(%rbx),%rdx
ffffffff80003806:	48 8b 73 78          	mov    0x78(%rbx),%rsi
ffffffff8000380a:	48 89 e9             	mov    %rbp,%rcx
ffffffff8000380d:	48 c7 c7 90 4e 00 80 	mov    $0xffffffff80004e90,%rdi
ffffffff80003814:	31 c0                	xor    %eax,%eax
ffffffff80003816:	e8 d5 f9 ff ff       	callq  ffffffff800031f0 <printf_>
            printf(_exception_messages[frame->int_no]);
ffffffff8000381b:	48 8b 43 78          	mov    0x78(%rbx),%rax
ffffffff8000381f:	48 8b 3c c5 40 50 00 	mov    -0x7fffafc0(,%rax,8),%rdi
ffffffff80003826:	80 
ffffffff80003827:	31 c0                	xor    %eax,%eax
ffffffff80003829:	e8 c2 f9 ff ff       	callq  ffffffff800031f0 <printf_>
            printf("\n");
ffffffff8000382e:	48 c7 c7 11 4f 00 80 	mov    $0xffffffff80004f11,%rdi
ffffffff80003835:	31 c0                	xor    %eax,%eax
ffffffff80003837:	e8 b4 f9 ff ff       	callq  ffffffff800031f0 <printf_>
            printf("SS: %x  RSP: %x  RFLAGS: %x  CS: %x  RIP: %x\n", frame->ss, frame->rsp, frame->rflags, frame->cs, frame->rip);
ffffffff8000383c:	48 8b 8b 98 00 00 00 	mov    0x98(%rbx),%rcx
ffffffff80003843:	48 8b 93 a0 00 00 00 	mov    0xa0(%rbx),%rdx
ffffffff8000384a:	48 c7 c7 c0 4e 00 80 	mov    $0xffffffff80004ec0,%rdi
ffffffff80003851:	48 8b b3 a8 00 00 00 	mov    0xa8(%rbx),%rsi
ffffffff80003858:	4c 8b 8b 88 00 00 00 	mov    0x88(%rbx),%r9
ffffffff8000385f:	31 c0                	xor    %eax,%eax
ffffffff80003861:	4c 8b 83 90 00 00 00 	mov    0x90(%rbx),%r8
ffffffff80003868:	e8 83 f9 ff ff       	callq  ffffffff800031f0 <printf_>
            printf("rax: %x  rdi: %x", frame->rax, frame->rdi);
ffffffff8000386d:	48 8b 53 48          	mov    0x48(%rbx),%rdx
ffffffff80003871:	48 8b 73 70          	mov    0x70(%rbx),%rsi
ffffffff80003875:	48 c7 c7 ee 4e 00 80 	mov    $0xffffffff80004eee,%rdi
ffffffff8000387c:	31 c0                	xor    %eax,%eax
ffffffff8000387e:	e8 6d f9 ff ff       	callq  ffffffff800031f0 <printf_>
            asm("cli");
ffffffff80003883:	fa                   	cli    
            asm("hlt");
ffffffff80003884:	f4                   	hlt    
ffffffff80003885:	eb fe                	jmp    ffffffff80003885 <interrupt_handler+0x125>
ffffffff80003887:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8000388e:	00 00 
                kbd_handle();
ffffffff80003890:	31 c0                	xor    %eax,%eax
ffffffff80003892:	e8 e9 e4 ff ff       	callq  ffffffff80001d80 <kbd_handle>
                break;
ffffffff80003897:	e9 16 ff ff ff       	jmpq   ffffffff800037b2 <interrupt_handler+0x52>
ffffffff8000389c:	0f 1f 40 00          	nopl   0x0(%rax)
            printf("INT: %d  IRQ: %d  \n", frame->int_no, irq);
ffffffff800038a0:	48 89 ea             	mov    %rbp,%rdx
ffffffff800038a3:	48 c7 c7 ff 4e 00 80 	mov    $0xffffffff80004eff,%rdi
ffffffff800038aa:	31 c0                	xor    %eax,%eax
ffffffff800038ac:	e8 3f f9 ff ff       	callq  ffffffff800031f0 <printf_>
ffffffff800038b1:	e9 fc fe ff ff       	jmpq   ffffffff800037b2 <interrupt_handler+0x52>
